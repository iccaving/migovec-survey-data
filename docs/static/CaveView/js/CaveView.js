(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.CV = {}));
}(this, (function (exports) { 'use strict';

	var scope;

	if ( self ) {
		scope = self;
	} else {
		scope = window;
	}

	if ( scope.TextDecoder === undefined ) {

		var TextDecoder$1 = function () {};

		TextDecoder$1.prototype.decode = function ( bytes ) {

			const l = bytes.length;

			var encoded = '';

			for ( var i = 0; i < l; i++ ) {

				encoded += '%' + bytes[ i ].toString( 16 );

			}

			return decodeURIComponent( encoded );


		};

		scope.TextDecoder = TextDecoder$1;

	}

	// Polyfills

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, - 52 );

	}

	if ( Number.isInteger === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function ( value ) {

			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

		};

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( 'name' in Function.prototype === false ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

			}

		} );

	}

	if ( Object.assign === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		Object.assign = function ( target ) {

			if ( target === undefined || target === null ) {

				throw new TypeError( 'Cannot convert undefined or null to object' );

			}

			const output = Object( target );

			for ( let index = 1; index < arguments.length; index ++ ) {

				const source = arguments[ index ];

				if ( source !== undefined && source !== null ) {

					for ( const nextKey in source ) {

						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

							output[ nextKey ] = source[ nextKey ];

						}

					}

				}

			}

			return output;

		};

	}

	const VERSION = '2.1.test5';

	const MATERIAL_LINE       = 1;
	const MATERIAL_SURFACE    = 2;

	const CAMERA_NONE         = 0;
	const CAMERA_ORTHOGRAPHIC = 1;
	const CAMERA_PERSPECTIVE  = 2;
	const CAMERA_ANAGLYPH     = 3;

	const CAMERA_OFFSET       = 600;

	// preset camera views

	const VIEW_NONE           = 0;
	const VIEW_PLAN           = 1;
	const VIEW_ELEVATION_N    = 2;
	const VIEW_ELEVATION_S    = 3;
	const VIEW_ELEVATION_E    = 4;
	const VIEW_ELEVATION_W    = 5;

	// mouse selection operation mode

	const MOUSE_MODE_NORMAL     = 0;
	const MOUSE_MODE_ROUTE_EDIT = 1;
	const MOUSE_MODE_DISTANCE   = 2;
	const MOUSE_MODE_TRACE_EDIT = 3;
	const MOUSE_MODE_ENTRANCES  = 4;

	// shading types

	const SHADING_HEIGHT       = 1;
	const SHADING_LENGTH       = 2;
	const SHADING_INCLINATION  = 3;
	const SHADING_CURSOR       = 4;
	const SHADING_SINGLE       = 5;
	const SHADING_SURVEY       = 6;
	const SHADING_OVERLAY      = 7;
	const SHADING_SHADED       = 8;
	const SHADING_RELIEF       = 8;
	const SHADING_DEPTH        = 9;
	const SHADING_PATH         = 10;
	const SHADING_DEPTH_CURSOR = 11;
	const SHADING_DISTANCE     = 13;
	const SHADING_BECK         = 14;
	const SHADING_CONTOURS     = 15;
	const SHADING_LOCATION     = 16;
	const SHADING_SURFACE      = 17;

	// layer tags for scene objects

	const FEATURE_SURVEY        = 0;
	const LEG_CAVE              = 1;
	const LEG_SPLAY             = 2;
	const LEG_SURFACE           = 3;
	const FEATURE_BOX           = 4;
	const FEATURE_SELECTED_BOX  = 5;
	const FEATURE_ENTRANCES     = 6;
	const FEATURE_TERRAIN       = 7;
	const FEATURE_STATIONS      = 8;
	const FEATURE_TRACES        = 9;
	const FACE_WALLS            = 11;
	const FACE_SCRAPS           = 12;
	const LABEL_STATION         = 13;
	const SURVEY_WARNINGS       = 14;
	const LABEL_STATION_COMMENT = 15;
	const CLUSTER_MARKERS       = 16;
	const FEATURE_ENTRANCE_DOTS = 17;

	const WALL_OVAL             = 1; // based on Therion .lox types
	const WALL_SQUARE           = 2;
	const WALL_DIAMOND          = 3;


	// flags in legs exported by Cave models

	const NORMAL  = 0;
	const SURFACE = 1;
	const SPLAY   = 2;
	const DIVING  = 3;

	const STATION_NORMAL = 0;
	const STATION_ENTRANCE = 1;

	const TERRAIN_BASIC   = 0;
	const TERRAIN_STENCIL = 1;
	const TERRAIN_BLEND   = 2;

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			const listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			const listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				const index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice( 0 );

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;

	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const CubeUVRefractionMapping = 307;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedShort565Type = 1019;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBIntegerFormat = 1032;
	const RGBAIntegerFormat = 1033;

	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const GammaEncoding = 3007;
	const RGBEEncoding = 3002;
	const LogLuvEncoding = 3003;
	const RGBM7Encoding = 3004;
	const RGBM16Encoding = 3005;
	const RGBDEncoding = 3006;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	const KeepStencilOp = 7680;
	const IncrementStencilOp = 7682;
	const EqualStencilFunc = 514;
	const AlwaysStencilFunc = 519;

	const StaticDrawUsage = 35044;
	const GLSL3 = '300 es';

	const _lut = [];

	for ( let i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	let _seed = 1234567;

	const MathUtils = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			const d0 = Math.random() * 0xffffffff | 0;
			const d1 = Math.random() * 0xffffffff | 0;
			const d2 = Math.random() * 0xffffffff | 0;
			const d3 = Math.random() * 0xffffffff | 0;
			const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
				_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
				_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
				_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

			// .toUpperCase() here flattens concatenated strings to save heap memory space.
			return uuid.toUpperCase();

		},

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		// Deterministic pseudo-random float in the interval [ 0, 1 ]

		seededRandom: function ( s ) {

			if ( s !== undefined ) _seed = s % 2147483647;

			// Park-Miller algorithm

			_seed = _seed * 16807 % 2147483647;

			return ( _seed - 1 ) / 2147483646;

		},

		degToRad: function ( degrees ) {

			return degrees * MathUtils.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * MathUtils.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			const cos = Math.cos;
			const sin = Math.sin;

			const c2 = cos( b / 2 );
			const s2 = sin( b / 2 );

			const c13 = cos( ( a + c ) / 2 );
			const s13 = sin( ( a + c ) / 2 );

			const c1_3 = cos( ( a - c ) / 2 );
			const s1_3 = sin( ( a - c ) / 2 );

			const c3_1 = cos( ( c - a ) / 2 );
			const s3_1 = sin( ( c - a ) / 2 );

			switch ( order ) {

				case 'XYX':
					q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
					break;

				case 'YZY':
					q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
					break;

				case 'ZXZ':
					q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
					break;

				case 'XZX':
					q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
					break;

				case 'YXY':
					q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
					break;

				case 'ZYZ':
					q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
					break;

				default:
					console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

			}

		}

	};

	class Vector2 {

		constructor( x = 0, y = 0 ) {

			Object.defineProperty( this, 'isVector2', { value: true } );

			this.x = x;
			this.y = y;

		}

		get width() {

			return this.x;

		}

		set width( value ) {

			this.x = value;

		}

		get height() {

			return this.y;

		}

		set height( value ) {

			this.y = value;

		}

		set( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y;

		}

		cross( v ) {

			return this.x * v.y - this.y * v.x;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		angle() {

			// computes the angle in radians with respect to the positive x-axis

			const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		}

		rotateAround( center, angle ) {

			const c = Math.cos( angle ), s = Math.sin( angle );

			const x = this.x - center.x;
			const y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();

			return this;

		}

	}

	class Matrix3 {

		constructor() {

			Object.defineProperty( this, 'isMatrix3', { value: true } );

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		}

		clone() {

			return new this.constructor().fromArray( this.elements );

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		}

		setFromMatrix4( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		}

		invert() {

			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
				n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
				n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		}

		transpose() {

			let tmp;
			const m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		}

		getNormalMatrix( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).copy( this ).invert().transpose();

		}

		transposeIntoArray( r ) {

			const m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		}

		setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

			const c = Math.cos( rotation );
			const s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

			return this;

		}

		scale( sx, sy ) {

			const te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		}

		rotate( theta ) {

			const c = Math.cos( theta );
			const s = Math.sin( theta );

			const te = this.elements;

			const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		}

		translate( tx, ty ) {

			const te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

	}

	let _canvas;

	const ImageUtils = {

		getDataURL: function ( image ) {

			if ( /^data:/i.test( image.src ) ) {

				return image.src;

			}

			if ( typeof HTMLCanvasElement == 'undefined' ) {

				return image.src;

			}

			let canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	};

	let textureId = 0;

	function Texture( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';

		this.image = image;
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.version = 0;
		this.onUpdate = null;

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Texture,

		isTexture: true,

		updateMatrix: function () {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function ( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			const output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				const image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = MathUtils.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					let url;

					if ( Array.isArray( image ) ) {

						// process array of images e.g. CubeTexture

						url = [];

						for ( let i = 0, l = image.length; i < l; i ++ ) {

							// check cube texture with data textures

							if ( image[ i ].isDataTexture ) {

								url.push( serializeImage( image[ i ].image ) );

							} else {

								url.push( serializeImage( image[ i ] ) );

							}

						}

					} else {

						// process single image

						url = serializeImage( image );

					}

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}

						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}

						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

	} );

	Object.defineProperty( Texture.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	function serializeImage( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			// default images

			return ImageUtils.getDataURL( image );

		} else {

			if ( image.data ) {

				// images of DataTexture

				return {
					data: Array.prototype.slice.call( image.data ),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};

			} else {

				console.warn( 'THREE.Texture: Unable to serialize Texture.' );
				return {};

			}

		}

	}

	class Vector4 {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			Object.defineProperty( this, 'isVector4', { value: true } );

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

		}

		get width() {

			return this.z;

		}

		set width( value ) {

			this.z = value;

		}

		get height() {

			return this.w;

		}

		set height( value ) {

			this.w = value;

		}

		set( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setW( w ) {

			this.w = w;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z, this.w );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z, w = this.w;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		setAxisAngleFromQuaternion( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			const s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		}

		setAxisAngleFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle, x, y, z; // variables for result
			const epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				const xx = ( m11 + 1 ) / 2;
				const yy = ( m22 + 1 ) / 2;
				const zz = ( m33 + 1 ) / 2;
				const xy = ( m12 + m21 ) / 4;
				const xz = ( m13 + m31 ) / 4;
				const yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				( m13 - m31 ) * ( m13 - m31 ) +
				( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;
			this.w = v1.w + ( v2.w - v1.w ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();

			return this;

		}

	}

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {

		this.width = width;
		this.height = height;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.image = {};
		this.texture.image.width = width;
		this.texture.image.height = height;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.texture.image.width = width;
				this.texture.image.height = height;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data || null, width: width || 1, height: height || 1 };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.needsUpdate = true;

	}

	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	class Quaternion {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			Object.defineProperty( this, 'isQuaternion', { value: true } );

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

		}

		static slerp( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		}

		static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			let x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					const sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				const tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

		static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

			const x0 = src0[ srcOffset0 ];
			const y0 = src0[ srcOffset0 + 1 ];
			const z0 = src0[ srcOffset0 + 2 ];
			const w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 ];
			const y1 = src1[ srcOffset1 + 1 ];
			const z1 = src1[ srcOffset1 + 2 ];
			const w1 = src1[ srcOffset1 + 3 ];

			dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

			return dst;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get w() {

			return this._w;

		}

		set w( value ) {

			this._w = value;
			this._onChangeCallback();

		}

		set( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._w );

		}

		copy( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		}

		setFromEuler( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;

			const c1 = cos( x / 2 );
			const c2 = cos( y / 2 );
			const c3 = cos( z / 2 );

			const s1 = sin( x / 2 );
			const s2 = sin( y / 2 );
			const s3 = sin( z / 2 );

			switch ( order ) {

				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		}

		setFromAxisAngle( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			const halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33;

			if ( trace > 0 ) {

				const s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		}

		setFromUnitVectors( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			const EPS = 0.000001;

			let r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		}

		angleTo( q ) {

			return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

		}

		rotateTowards( q, step ) {

			const angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			const t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		}

		identity() {

			return this.set( 0, 0, 0, 1 );

		}

		invert() {

			// quaternion is assumed to have unit length

			return this.conjugate();

		}

		conjugate() {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		}

		dot( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		}

		lengthSq() {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		}

		length() {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		}

		normalize() {

			let l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		}

		multiply( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		}

		premultiply( q ) {

			return this.multiplyQuaternions( q, this );

		}

		multiplyQuaternions( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		}

		slerp( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			const x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		}

		equals( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		}

		fromArray( array, offset = 0 ) {

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

	}

	class Vector3 {

		constructor( x = 0, y = 0, z = 0 ) {

			Object.defineProperty( this, 'isVector3', { value: true } );

			this.x = x;
			this.y = y;
			this.z = z;

		}

		set( x, y, z ) {

			if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		}

		multiply( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		}

		multiplyVectors( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		}

		applyEuler( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

		}

		applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		}

		applyNormalMatrix( m ) {

			return this.applyMatrix3( m ).normalize();

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		}

		applyQuaternion( q ) {

			const x = this.x, y = this.y, z = this.z;
			const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		}

		project( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		}

		unproject( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		}

		transformDirection( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		}

		// TODO lengthSquared?

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;

			return this;

		}

		cross( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		}

		crossVectors( a, b ) {

			const ax = a.x, ay = a.y, az = a.z;
			const bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		}

		projectOnVector( v ) {

			const denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			const scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		}

		projectOnPlane( planeNormal ) {

			_vector.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector );

		}

		reflect( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		}

		setFromSpherical( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		}

		setFromSphericalCoords( radius, phi, theta ) {

			const sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		}

		setFromCylindrical( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		}

		setFromCylindricalCoords( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		}

		setFromMatrixPosition( m ) {

			const e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		}

		setFromMatrixScale( m ) {

			const sx = this.setFromMatrixColumn( m, 0 ).length();
			const sy = this.setFromMatrixColumn( m, 1 ).length();
			const sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		}

		setFromMatrixColumn( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		}

		setFromMatrix3Column( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();

			return this;

		}

	}

	const _vector = /*@__PURE__*/ new Vector3();
	const _quaternion = /*@__PURE__*/ new Quaternion();

	class Box3 {

		constructor( min, max ) {

			Object.defineProperty( this, 'isBox3', { value: true } );

			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromArray( array ) {

			let minX = + Infinity;
			let minY = + Infinity;
			let minZ = + Infinity;

			let maxX = - Infinity;
			let maxY = - Infinity;
			let maxZ = - Infinity;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const x = array[ i ];
				const y = array[ i + 1 ];
				const z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		}

		setFromBufferAttribute( attribute ) {

			let minX = + Infinity;
			let minY = + Infinity;
			let minZ = + Infinity;

			let maxX = - Infinity;
			let maxY = - Infinity;
			let maxZ = - Infinity;

			for ( let i = 0, l = attribute.count; i < l; i ++ ) {

				const x = attribute.getX( i );
				const y = attribute.getY( i );
				const z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		setFromObject( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		}

		getCenter( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		expandByObject( object ) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix( false, false );

			const geometry = object.geometry;

			if ( geometry !== undefined ) {

				if ( geometry.boundingBox === null ) {

					geometry.computeBoundingBox();

				}

				_box.copy( geometry.boundingBox );
				_box.applyMatrix4( object.matrixWorld );

				this.union( _box );

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				this.expandByObject( children[ i ] );

			}

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		}

		intersectsBox( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		}

		intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, _vector$1 );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		intersectsPlane( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		}

		intersectsTriangle( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( _center );
			_extents.subVectors( this.max, _center );

			// translate triangle to aabb origin
			_v0.subVectors( triangle.a, _center );
			_v1.subVectors( triangle.b, _center );
			_v2.subVectors( triangle.c, _center );

			// compute edge vectors for triangle
			_f0.subVectors( _v1, _v0 );
			_f1.subVectors( _v2, _v1 );
			_f2.subVectors( _v0, _v2 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			];
			if ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors( _f0, _f1 );
			axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

			return satForAxes( axes, _v0, _v1, _v2, _extents );

		}

		clampPoint( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			const clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );

			return clampedPoint.sub( point ).length();

		}

		getBoundingSphere( target ) {

			if ( target === undefined ) {

				console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
				//target = new Sphere(); // removed to avoid cyclic dependency

			}

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$1 ).length() * 0.5;

			return target;

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( _points );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	function satForAxes( axes, v0, v1, v2, extents ) {

		for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the seperating axis
			const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the seperating axis
			const p0 = v0.dot( _testAxis );
			const p1 = v1.dot( _testAxis );
			const p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;

			}

		}

		return true;

	}

	const _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	];

	const _vector$1 = /*@__PURE__*/ new Vector3();

	const _box = /*@__PURE__*/ new Box3();

	// triangle centered vertices

	const _v0 = /*@__PURE__*/ new Vector3();
	const _v1 = /*@__PURE__*/ new Vector3();
	const _v2 = /*@__PURE__*/ new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/ new Vector3();
	const _f1 = /*@__PURE__*/ new Vector3();
	const _f2 = /*@__PURE__*/ new Vector3();

	const _center = /*@__PURE__*/ new Vector3();
	const _extents = /*@__PURE__*/ new Vector3();
	const _triangleNormal = /*@__PURE__*/ new Vector3();
	const _testAxis = /*@__PURE__*/ new Vector3();

	const _box$1 = /*@__PURE__*/ new Box3();

	class Sphere {

		constructor( center, radius ) {

			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : - 1;

		}

		set( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		}

		setFromPoints( points, optionalCenter ) {

			const center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				_box$1.setFromPoints( points ).getCenter( center );

			}

			let maxRadiusSq = 0;

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		}

		isEmpty() {

			return ( this.radius < 0 );

		}

		makeEmpty() {

			this.center.set( 0, 0, 0 );
			this.radius = - 1;

			return this;

		}

		containsPoint( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		}

		distanceToPoint( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		}

		intersectsSphere( sphere ) {

			const radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		}

		intersectsBox( box ) {

			return box.intersectsSphere( this );

		}

		intersectsPlane( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		}

		clampPoint( point, target ) {

			const deltaLengthSq = this.center.distanceToSquared( point );

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();

			}

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		}

		getBoundingBox( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();

			}

			if ( this.isEmpty() ) {

				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		}

		applyMatrix4( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		}

		translate( offset ) {

			this.center.add( offset );

			return this;

		}

		equals( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	}

	const _vector1 = /*@__PURE__*/ new Vector3();
	const _vector2 = /*@__PURE__*/ new Vector3();
	const _normalMatrix = /*@__PURE__*/ new Matrix3();

	class Plane {

		constructor( normal, constant ) {

			Object.defineProperty( this, 'isPlane', { value: true } );

			// normal is assumed to be normalized

			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;

		}

		set( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		}

		setComponents( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		}

		setFromNormalAndCoplanarPoint( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		}

		setFromCoplanarPoints( a, b, c ) {

			const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		}

		normalize() {

			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		}

		negate() {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		}

		distanceToPoint( point ) {

			return this.normal.dot( point ) + this.constant;

		}

		distanceToSphere( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		}

		projectPoint( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		}

		intersectLine( line, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .intersectLine() target is now required' );
				target = new Vector3();

			}

			const direction = line.delta( _vector1 );

			const denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		}

		intersectsLine( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint( line.start );
			const endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		}

		intersectsBox( box ) {

			return box.intersectsPlane( this );

		}

		intersectsSphere( sphere ) {

			return sphere.intersectsPlane( this );

		}

		coplanarPoint( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		}

		applyMatrix4( matrix, optionalNormalMatrix ) {

			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		}

		translate( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		}

		equals( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	}

	const _sphere = /*@__PURE__*/ new Sphere();
	const _vector$2 = /*@__PURE__*/ new Vector3();

	class Frustum {

		constructor( p0, p1, p2, p3, p4, p5 ) {

			this.planes = [

				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()

			];

		}

		set( p0, p1, p2, p3, p4, p5 ) {

			const planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( frustum ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		}

		setFromProjectionMatrix( m ) {

			const planes = this.planes;
			const me = m.elements;
			const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		}

		intersectsObject( object ) {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( _sphere );

		}

		intersectsSprite( sprite ) {

			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( _sphere );

		}

		intersectsSphere( sphere ) {

			const planes = this.planes;
			const center = sphere.center;
			const negRadius = - sphere.radius;

			for ( let i = 0; i < 6; i ++ ) {

				const distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		}

		intersectsBox( box ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				const plane = planes[ i ];

				// corner at max distance

				_vector$2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( _vector$2 ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		containsPoint( point ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	}

	class Matrix4 {

		constructor() {

			Object.defineProperty( this, 'isMatrix4', { value: true } );

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		clone() {

			return new Matrix4().fromArray( this.elements );

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		}

		copyPosition( m ) {

			const te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		}

		makeBasis( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		}

		extractRotation( m ) {

			// this method does not support reflection matrices

			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$1.setFromMatrixColumn( m, 0 ).length();
			const scaleY = 1 / _v1$1.setFromMatrixColumn( m, 1 ).length();
			const scaleZ = 1 / _v1$1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromEuler( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			const te = this.elements;

			const x = euler.x, y = euler.y, z = euler.z;
			const a = Math.cos( x ), b = Math.sin( x );
			const c = Math.cos( y ), d = Math.sin( y );
			const e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromQuaternion( q ) {

			return this.compose( _zero, q, _one );

		}

		lookAt( eye, target, up ) {

			const te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		}

		multiply( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		}

		transpose() {

			const te = this.elements;
			let tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		}

		setPosition( x, y, z ) {

			const te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		}

		invert() {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
				n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
				n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
				n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		}

		scale( v ) {

			const te = this.elements;
			const x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		}

		getMaxScaleOnAxis() {

			const te = this.elements;

			const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		}

		makeTranslation( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationX( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationY( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		}

		makeRotationZ( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationAxis( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos( angle );
			const s = Math.sin( angle );
			const t = 1 - c;
			const x = axis.x, y = axis.y, z = axis.z;
			const tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeScale( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeShear( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		compose( position, quaternion, scale ) {

			const te = this.elements;

			const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			const x2 = x + x,	y2 = y + y, z2 = z + z;
			const xx = x * x2, xy = x * y2, xz = x * z2;
			const yy = y * y2, yz = y * z2, zz = z * z2;
			const wx = w * x2, wy = w * y2, wz = w * z2;

			const sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		}

		decompose( position, quaternion, scale ) {

			const te = this.elements;

			let sx = _v1$1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			const sy = _v1$1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			const sz = _v1$1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			const det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1.copy( this );

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;

			_m1.elements[ 0 ] *= invSX;
			_m1.elements[ 1 ] *= invSX;
			_m1.elements[ 2 ] *= invSX;

			_m1.elements[ 4 ] *= invSY;
			_m1.elements[ 5 ] *= invSY;
			_m1.elements[ 6 ] *= invSY;

			_m1.elements[ 8 ] *= invSZ;
			_m1.elements[ 9 ] *= invSZ;
			_m1.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		}

		makePerspective( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			const te = this.elements;
			const x = 2 * near / ( right - left );
			const y = 2 * near / ( top - bottom );

			const a = ( right + left ) / ( right - left );
			const b = ( top + bottom ) / ( top - bottom );
			const c = - ( far + near ) / ( far - near );
			const d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		}

		makeOrthographic( left, right, top, bottom, near, far ) {

			const te = this.elements;
			const w = 1.0 / ( right - left );
			const h = 1.0 / ( top - bottom );
			const p = 1.0 / ( far - near );

			const x = ( right + left ) * w;
			const y = ( top + bottom ) * h;
			const z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	}

	const _v1$1 = /*@__PURE__*/ new Vector3();
	const _m1 = /*@__PURE__*/ new Matrix4();
	const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
	const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
	const _x = /*@__PURE__*/ new Vector3();
	const _y = /*@__PURE__*/ new Vector3();
	const _z = /*@__PURE__*/ new Vector3();

	const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	const _hslA = { h: 0, s: 0, l: 0 };
	const _hslB = { h: 0, s: 0, l: 0 };

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) t += 1;
		if ( t > 1 ) t -= 1;
		if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
		if ( t < 1 / 2 ) return q;
		if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
		return p;

	}

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	class Color {

		constructor( r, g, b ) {

			Object.defineProperty( this, 'isColor', { value: true } );

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string
				return this.set( r );

			}

			return this.setRGB( r, g, b );

		}

		set( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		}

		setScalar( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		}

		setHex( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		}

		setRGB( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		}

		setHSL( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = MathUtils.euclideanModulo( h, 1 );
			s = MathUtils.clamp( s, 0, 1 );
			l = MathUtils.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				const q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		}

		setStyle( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			let m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				let color;
				const name = m[ 1 ];
				const components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 4 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 4 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat( color[ 1 ] ) / 360;
							const s = parseInt( color[ 2 ], 10 ) / 100;
							const l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 4 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

				// hex color

				const hex = m[ 1 ];
				const size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				return this.setColorName( style );

			}

			return this;

		}

		setColorName( style ) {

			// color keywords
			const hex = _colorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

			return this;

		}

		clone() {

			return new this.constructor( this.r, this.g, this.b );

		}

		copy( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		}

		copyGammaToLinear( color, gammaFactor = 2.0 ) {

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		}

		copyLinearToGamma( color, gammaFactor = 2.0 ) {

			const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		}

		convertGammaToLinear( gammaFactor ) {

			this.copyGammaToLinear( this, gammaFactor );

			return this;

		}

		convertLinearToGamma( gammaFactor ) {

			this.copyLinearToGamma( this, gammaFactor );

			return this;

		}

		copySRGBToLinear( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		}

		copyLinearToSRGB( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		}

		convertSRGBToLinear() {

			this.copySRGBToLinear( this );

			return this;

		}

		convertLinearToSRGB() {

			this.copyLinearToSRGB( this );

			return this;

		}

		getHex() {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		}

		getHexString() {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		}

		getHSL( target ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( target === undefined ) {

				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };

			}

			const r = this.r, g = this.g, b = this.b;

			const max = Math.max( r, g, b );
			const min = Math.min( r, g, b );

			let hue, saturation;
			const lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				const delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		}

		getStyle() {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		}

		offsetHSL( h, s, l ) {

			this.getHSL( _hslA );

			_hslA.h += h; _hslA.s += s; _hslA.l += l;

			this.setHSL( _hslA.h, _hslA.s, _hslA.l );

			return this;

		}

		add( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		}

		addColors( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		}

		addScalar( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		}

		sub( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		}

		multiply( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		}

		multiplyScalar( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		}

		lerp( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		}

		lerpHSL( color, alpha ) {

			this.getHSL( _hslA );
			color.getHSL( _hslB );

			const h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
			const s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
			const l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		}

		equals( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		}

		fromArray( array, offset = 0 ) {

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.r = attribute.getX( index );
			this.g = attribute.getY( index );
			this.b = attribute.getZ( index );

			if ( attribute.normalized === true ) {

				// assuming Uint8Array

				this.r /= 255;
				this.g /= 255;
				this.b /= 255;

			}

			return this;

		}

		toJSON() {

			return this.getHex();

		}

	}

	Color.NAMES = _colorKeywords;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	function WebGLAnimation() {

		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame( time, frame ) {

			animationLoop( time, frame );

			requestId = context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				requestId = context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				context.cancelAnimationFrame( requestId );

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	function WebGLAttributes( gl, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		const buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			const array = attribute.array;
			const usage = attribute.usage;

			const buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			let type = gl.FLOAT;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				if ( attribute.isFloat16BufferAttribute ) {

					if ( isWebGL2 ) {

						type = gl.HALF_FLOAT;

					} else {

						console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

					}

				} else {

					type = gl.UNSIGNED_SHORT;

				}

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			const array = attribute.array;
			const updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else {

				if ( isWebGL2 ) {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count );

				} else {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				}

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isGLBufferAttribute ) {

				const cached = buffers.get( attribute );

				if ( ! cached || cached.version < attribute.version ) {

					buffers.set( attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					} );

				}

				return;

			}

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	const _vector$3 = new Vector3();
	const _vector2$1 = new Vector2();

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback: function () {},

		setUsage: function ( value ) {

			this.usage = value;

			return this;

		},

		copy: function ( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = colors.length; i < l; i ++ ) {

				let color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		applyMatrix3: function ( m ) {

			if ( this.itemSize === 2 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector2$1.fromBufferAttribute( this, i );
					_vector2$1.applyMatrix3( m );

					this.setXY( i, _vector2$1.x, _vector2$1.y );

				}

			} else if ( this.itemSize === 3 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector$3.fromBufferAttribute( this, i );
					_vector$3.applyMatrix3( m );

					this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

				}

			}

			return this;

		},

		applyMatrix4: function ( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.x = this.getX( i );
				_vector$3.y = this.getY( i );
				_vector$3.z = this.getZ( i );

				_vector$3.applyMatrix4( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

			return this;

		},

		applyNormalMatrix: function ( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.x = this.getX( i );
				_vector$3.y = this.getY( i );
				_vector$3.z = this.getZ( i );

				_vector$3.applyNormalMatrix( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

			return this;

		},

		transformDirection: function ( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.x = this.getX( i );
				_vector$3.y = this.getY( i );
				_vector$3.z = this.getZ( i );

				_vector$3.transformDirection( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

			return this;

		},

		set: function ( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		},

		toJSON: function () {

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call( this.array ),
				normalized: this.normalized
			};

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

	function Float16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Float16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	class DirectGeometry {

		constructor() {

			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];

			this.groups = [];

			this.morphTargets = {};

			this.skinWeights = [];
			this.skinIndices = [];

			// this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		computeGroups( geometry ) {

			const groups = [];

			let group, i;
			let materialIndex = undefined;

			const faces = geometry.faces;

			for ( i = 0; i < faces.length; i ++ ) {

				const face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		}

		fromGeometry( geometry ) {

			const faces = geometry.faces;
			const vertices = geometry.vertices;
			const faceVertexUvs = geometry.faceVertexUvs;

			const hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			const hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			const morphTargets = geometry.morphTargets;
			const morphTargetsLength = morphTargets.length;

			let morphTargetsPosition;

			if ( morphTargetsLength > 0 ) {

				morphTargetsPosition = [];

				for ( let i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = {
						name: morphTargets[ i ].name,
					 	data: []
					};

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			const morphNormals = geometry.morphNormals;
			const morphNormalsLength = morphNormals.length;

			let morphTargetsNormal;

			if ( morphNormalsLength > 0 ) {

				morphTargetsNormal = [];

				for ( let i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = {
						name: morphNormals[ i ].name,
					 	data: []
					};

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			const skinIndices = geometry.skinIndices;
			const skinWeights = geometry.skinWeights;

			const hasSkinIndices = skinIndices.length === vertices.length;
			const hasSkinWeights = skinWeights.length === vertices.length;

			//

			if ( vertices.length > 0 && faces.length === 0 ) {

				console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

			}

			for ( let i = 0; i < faces.length; i ++ ) {

				const face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				const vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					const normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				const vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					const color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					const vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					const vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				// morphs

				for ( let j = 0; j < morphTargetsLength; j ++ ) {

					const morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( let j = 0; j < morphNormalsLength; j ++ ) {

					const morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		}

	}

	class Euler {

		constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

			Object.defineProperty( this, 'isEuler', { value: true } );

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get order() {

			return this._order;

		}

		set order( value ) {

			this._order = value;
			this._onChangeCallback();

		}

		set( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._order );

		}

		copy( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m, order, update ) {

			const clamp = MathUtils.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements;
			const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			switch ( order ) {

				case 'XYZ':

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

					break;

				case 'YXZ':

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.9999999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

					break;

				case 'ZXY':

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.9999999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

					break;

				case 'ZYX':

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

					break;

				case 'YZX':

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

					break;

				case 'XZY':

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

					break;

				default:

					console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this._onChangeCallback();

			return this;

		}

		setFromQuaternion( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		}

		setFromVector3( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		}

		reorder( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion$1.setFromEuler( this );

			return this.setFromQuaternion( _quaternion$1, newOrder );

		}

		equals( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		}

		fromArray( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		}

		toVector3( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

	}

	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	const _matrix = /*@__PURE__*/ new Matrix4();
	const _quaternion$1 = /*@__PURE__*/ new Quaternion();

	class Layers {

		constructor() {

			this.mask = 1 | 0;

		}

		set( channel ) {

			this.mask = 1 << channel | 0;

		}

		enable( channel ) {

			this.mask |= 1 << channel | 0;

		}

		enableAll() {

			this.mask = 0xffffffff | 0;

		}

		toggle( channel ) {

			this.mask ^= 1 << channel | 0;

		}

		disable( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		}

		disableAll() {

			this.mask = 0;

		}

		test( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	}

	let _object3DId = 0;

	const _v1$2 = new Vector3();
	const _q1 = new Quaternion();
	const _m1$1 = new Matrix4();
	const _target = new Vector3();

	const _position = new Vector3();
	const _scale = new Vector3();
	const _quaternion$2 = new Quaternion();

	const _xAxis = new Vector3( 1, 0, 0 );
	const _yAxis = new Vector3( 0, 1, 0 );
	const _zAxis = new Vector3( 0, 0, 1 );

	const _addedEvent = { type: 'added' };
	const _removedEvent = { type: 'removed' };

	function Object3D() {

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix4: function ( matrix ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function ( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		},

		rotateOnWorldAxis: function ( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		},

		rotateX: function ( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		},

		rotateY: function ( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		},

		rotateZ: function ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		},

		translateOnAxis: function ( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$2.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$2.multiplyScalar( distance ) );

			return this;

		},

		translateX: function ( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		},

		translateY: function ( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		},

		translateZ: function ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		},

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function ( vector ) {

			return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

		},

		lookAt: function ( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			const parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				_m1$1.lookAt( _position, _target, this.up );

			} else {

				_m1$1.lookAt( _target, _position, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$1 );

			if ( parent ) {

				_m1$1.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$1 );
				this.quaternion.premultiply( _q1.invert() );

			}

		},

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
				return this;

			}

			if ( object && object.isObject3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

			} else {

				console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			const index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

			}

			return this;

		},

		clear: function () {

			for ( let i = 0; i < this.children.length; i ++ ) {

				const object = this.children[ i ];

				object.parent = null;

				object.dispatchEvent( _removedEvent );

			}

			this.children.length = 0;

			return this;


		},

		attach: function ( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			this.updateWorldMatrix( true, false );

			_m1$1.copy( this.matrixWorld ).invert();

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$1.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$1 );

			object.updateWorldMatrix( false, false );

			this.add( object );

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const child = this.children[ i ];
				const object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			return target.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
				target = new Quaternion();

			}

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position, target, _scale );

			return target;

		},

		getWorldScale: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position, _quaternion$2, target );

			return target;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		},

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			const parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			const parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				const children = this.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateWorldMatrix( false, true );

				}

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			const output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			const object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isInstancedMesh ) {

				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();

			}

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				const parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					const shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( let i = 0, l = shapes.length; i < l; i ++ ) {

							const shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.isSkinnedMesh ) {

				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if ( this.skeleton !== undefined ) {

					serialize( meta.skeletons, this.skeleton );

					object.skeleton = this.skeleton.uuid;

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					const uuids = [];

					for ( let i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( let i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			//

			if ( this.animations.length > 0 ) {

				object.animations = [];

				for ( let i = 0; i < this.animations.length; i ++ ) {

					const animation = this.animations[ i ];

					object.animations.push( serialize( meta.animations, animation ) );

				}

			}

			if ( isRootObject ) {

				const geometries = extractFromCache( meta.geometries );
				const materials = extractFromCache( meta.materials );
				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const shapes = extractFromCache( meta.shapes );
				const skeletons = extractFromCache( meta.skeletons );
				const animations = extractFromCache( meta.animations );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;
				if ( skeletons.length > 0 ) output.skeletons = skeletons;
				if ( animations.length > 0 ) output.animations = animations;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				const values = [];
				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive = true ) {

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.rotation.order = source.rotation.order;
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( let i = 0; i < source.children.length; i ++ ) {

					const child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		let max = array[ 0 ];

		for ( let i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	let _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	const _m1$2 = new Matrix4();
	const _obj = new Object3D();
	const _offset = new Vector3();
	const _box$2 = new Box3();
	const _boxMorphTargets = new Box3();
	const _vector$4 = new Vector3();

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		setAttribute: function ( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		},

		deleteAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		hasAttribute: function ( name ) {

			return this.attributes[ name ] !== undefined;

		},

		addGroup: function ( start, count, materialIndex = 0 ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix4: function ( matrix ) {

			const position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			const normal = this.attributes.normal;

			if ( normal !== undefined ) {

				const normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			const tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function ( angle ) {

			// rotate geometry around world x-axis

			_m1$2.makeRotationX( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		rotateY: function ( angle ) {

			// rotate geometry around world y-axis

			_m1$2.makeRotationY( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		rotateZ: function ( angle ) {

			// rotate geometry around world z-axis

			_m1$2.makeRotationZ( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		translate: function ( x, y, z ) {

			// translate geometry

			_m1$2.makeTranslation( x, y, z );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		scale: function ( x, y, z ) {

			// scale geometry

			_m1$2.makeScale( x, y, z );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		lookAt: function ( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		},

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			const geometry = object.geometry;

			if ( object.isPoints || object.isLine ) {

				const positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				const colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

				this.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					const lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

					this.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object.isMesh ) {

				if ( geometry && geometry.isGeometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		setFromPoints: function ( points ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		updateFromObject: function ( object ) {

			let geometry = object.geometry;

			if ( object.isMesh ) {

				let direct = geometry.__directGeometry;

				if ( geometry.elementsNeedUpdate === true ) {

					direct = undefined;
					geometry.elementsNeedUpdate = false;

				}

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			if ( geometry.verticesNeedUpdate === true ) {

				const attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				const attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				const attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

				const attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				const attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			const positions = new Float32Array( geometry.vertices.length * 3 );
			this.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				const normals = new Float32Array( geometry.normals.length * 3 );
				this.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				const colors = new Float32Array( geometry.colors.length * 3 );
				this.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				const uvs = new Float32Array( geometry.uvs.length * 2 );
				this.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				const uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( const name in geometry.morphTargets ) {

				const array = [];
				const morphTargets = geometry.morphTargets[ name ];

				for ( let i = 0, l = morphTargets.length; i < l; i ++ ) {

					const morphTarget = morphTargets[ i ];

					const attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
					attribute.name = morphTarget.name;

					array.push( attribute.copyVector3sArray( morphTarget.data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				const skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				const skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingBox.set(
					new Vector3( - Infinity, - Infinity, - Infinity ),
					new Vector3( + Infinity, + Infinity, + Infinity )
				);

				return;

			}

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_box$2.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$4.addVectors( this.boundingBox.min, _box$2.min );
							this.boundingBox.expandByPoint( _vector$4 );

							_vector$4.addVectors( this.boundingBox.max, _box$2.max );
							this.boundingBox.expandByPoint( _vector$4 );

						} else {

							this.boundingBox.expandByPoint( _box$2.min );
							this.boundingBox.expandByPoint( _box$2.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingSphere.set( new Vector3(), Infinity );

				return;

			}

			if ( position ) {

				// first, find the center of the bounding sphere

				const center = this.boundingSphere.center;

				_box$2.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
							_box$2.expandByPoint( _vector$4 );

							_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
							_box$2.expandByPoint( _vector$4 );

						} else {

							_box$2.expandByPoint( _boxMorphTargets.min );
							_box$2.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box$2.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				let maxRadiusSq = 0;

				for ( let i = 0, il = position.count; i < il; i ++ ) {

					_vector$4.fromBufferAttribute( position, i );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						const morphTargetsRelative = this.morphTargetsRelative;

						for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

							_vector$4.fromBufferAttribute( morphAttribute, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$4.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		},

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			const index = this.index;
			const positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute !== undefined ) {

				let normalAttribute = this.getAttribute( 'normal' );

				if ( normalAttribute === undefined ) {

					normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
					this.setAttribute( 'normal', normalAttribute );

				} else {

					// reset existing normals to zero

					for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

						normalAttribute.setXYZ( i, 0, 0, 0 );

					}

				}

				const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
				const cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					for ( let i = 0, il = index.count; i < il; i += 3 ) {

						const vA = index.getX( i + 0 );
						const vB = index.getX( i + 1 );
						const vC = index.getX( i + 2 );

						pA.fromBufferAttribute( positionAttribute, vA );
						pB.fromBufferAttribute( positionAttribute, vB );
						pC.fromBufferAttribute( positionAttribute, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						nA.fromBufferAttribute( normalAttribute, vA );
						nB.fromBufferAttribute( normalAttribute, vB );
						nC.fromBufferAttribute( normalAttribute, vC );

						nA.add( cb );
						nB.add( cb );
						nC.add( cb );

						normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
						normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
						normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

						pA.fromBufferAttribute( positionAttribute, i + 0 );
						pB.fromBufferAttribute( positionAttribute, i + 1 );
						pC.fromBufferAttribute( positionAttribute, i + 2 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

					}

				}

				this.normalizeNormals();

				normalAttribute.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				const attribute1 = attributes[ key ];
				const attributeArray1 = attribute1.array;

				const attribute2 = geometry.attributes[ key ];
				const attributeArray2 = attribute2.array;

				const attributeOffset = attribute2.itemSize * offset;
				const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

				for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			const normals = this.attributes.normal;

			for ( let i = 0, il = normals.count; i < il; i ++ ) {

				_vector$4.fromBufferAttribute( normals, i );

				_vector$4.normalize();

				normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

			}

		},

		toNonIndexed: function () {

			function convertBufferAttribute( attribute, indices ) {

				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;

				const array2 = new array.constructor( indices.length * itemSize );

				let index = 0, index2 = 0;

				for ( let i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( let j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize, normalized );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			const geometry2 = new BufferGeometry();

			const indices = this.index.array;
			const attributes = this.attributes;

			// attributes

			for ( const name in attributes ) {

				const attribute = attributes[ name ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			const morphAttributes = this.morphAttributes;

			for ( const name in morphAttributes ) {

				const morphArray = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

					const attribute = morphAttribute[ i ];

					const newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			const groups = this.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		},

		toJSON: function () {

			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				const parameters = this.parameters;

				for ( const key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			const index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				const attributeData = attribute.toJSON( data.data );

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				data.data.attributes[ key ] = attributeData;

			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for ( const key in this.morphAttributes ) {

				const attributeArray = this.morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];

					const attributeData = attribute.toJSON( data.data );

					if ( attribute.name !== '' ) attributeData.name = attribute.name;

					array.push( attributeData );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			const groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			const boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 const parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 const values = [];

			 for ( const key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// used for storing cloned, shared data

			const data = {};

			// name

			this.name = source.name;

			// index

			const index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone( data ) );

			}

			// attributes

			const attributes = source.attributes;

			for ( const name in attributes ) {

				const attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone( data ) );

			}

			// morph attributes

			const morphAttributes = source.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone( data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			const groups = source.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			const boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			const boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	class BoxBufferGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

			super();

			this.type = 'BoxBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			const scope = this;

			// segments

			widthSegments = Math.floor( widthSegments );
			heightSegments = Math.floor( heightSegments );
			depthSegments = Math.floor( depthSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let numberOfVertices = 0;
			let groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;

				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;

				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;

				let vertexCounter = 0;
				let groupCount = 0;

				const vector = new Vector3();

				// generate vertices, normals and uvs

				for ( let iy = 0; iy < gridY1; iy ++ ) {

					const y = iy * segmentHeight - heightHalf;

					for ( let ix = 0; ix < gridX1; ix ++ ) {

						const x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( let iy = 0; iy < gridY; iy ++ ) {

					for ( let ix = 0; ix < gridX; ix ++ ) {

						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

	}

	class PlaneBufferGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

			super();
			this.type = 'PlaneBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			const width_half = width / 2;
			const height_half = height / 2;

			const gridX = Math.floor( widthSegments );
			const gridY = Math.floor( heightSegments );

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			const segment_width = width / gridX;
			const segment_height = height / gridY;

			//

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segment_height - height_half;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * ( iy + 1 );
					const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = ( ix + 1 ) + gridX1 * iy;

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	let materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function ( /* shaderobject, renderer */ ) {},

		customProgramCacheKey: function () {

			return this.onBeforeCompile.toString();

		},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( const key in values ) {

				const newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				const currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			const isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
			if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

			if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

				data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap
				data.refractionRatio = this.refractionRatio;

				if ( this.combine !== undefined ) data.combine = this.combine;
				if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors ) data.vertexColors = true;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;

			// rotation (SpriteMaterial)
			if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.morphNormals === true ) data.morphNormals = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.visible === false ) data.visible = false;

			if ( this.toneMapped === false ) data.toneMapped = false;

			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if ( srcPlanes !== null ) {

				const n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( let i = 0; i !== n; ++ i ) {

					dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	Object.defineProperty( Material.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		const dst = {};

		for ( const u in src ) {

			dst[ u ] = {};

			for ( const p in src[ u ] ) {

				const property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture ) ) {

					dst[ u ][ p ] = property.clone();

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		const merged = {};

		for ( let u = 0; u < uniforms.length; u ++ ) {

			const tmp = cloneUniforms( uniforms[ u ] );

			for ( const p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		const data = Material.prototype.toJSON.call( this, meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	};

	const _vector$5 = /*@__PURE__*/ new Vector3();
	const _segCenter = /*@__PURE__*/ new Vector3();
	const _segDir = /*@__PURE__*/ new Vector3();
	const _diff = /*@__PURE__*/ new Vector3();

	const _edge1 = /*@__PURE__*/ new Vector3();
	const _edge2 = /*@__PURE__*/ new Vector3();
	const _normal = /*@__PURE__*/ new Vector3();

	class Ray {

		constructor( origin, direction ) {

			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );

		}

		set( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		}

		at( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .at() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		}

		lookAt( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		}

		recast( t ) {

			this.origin.copy( this.at( t, _vector$5 ) );

			return this;

		}

		closestPointToPoint( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			target.subVectors( point, this.origin );

			const directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		}

		distanceToPoint( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		}

		distanceSqToPoint( point ) {

			const directionDistance = _vector$5.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			_vector$5.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return _vector$5.distanceToSquared( point );

		}

		distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			_segDir.copy( v1 ).sub( v0 ).normalize();
			_diff.copy( this.origin ).sub( _segCenter );

			const segExtent = v0.distanceTo( v1 ) * 0.5;
			const a01 = - this.direction.dot( _segDir );
			const b0 = _diff.dot( this.direction );
			const b1 = - _diff.dot( _segDir );
			const c = _diff.lengthSq();
			const det = Math.abs( 1 - a01 * a01 );
			let s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

			}

			return sqrDist;

		}

		intersectSphere( sphere, target ) {

			_vector$5.subVectors( sphere.center, this.origin );
			const tca = _vector$5.dot( this.direction );
			const d2 = _vector$5.dot( _vector$5 ) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			const thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, target );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, target );

		}

		intersectsSphere( sphere ) {

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		distanceToPlane( plane ) {

			const denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		}

		intersectPlane( plane, target ) {

			const t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		}

		intersectsPlane( plane ) {

			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			const denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		}

		intersectBox( box, target ) {

			let tmin, tmax, tymin, tymax, tzmin, tzmax;

			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			const origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		}

		intersectsBox( box ) {

			return this.intersectBox( box, _vector$5 ) !== null;

		}

		intersectTriangle( a, b, c, backfaceCulling, target ) {

			// Compute the offset origin, edges, and normal.

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			_edge1.subVectors( b, a );
			_edge2.subVectors( c, a );
			_normal.crossVectors( _edge1, _edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot( _normal );
			let sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			_diff.subVectors( this.origin, a );
			const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			const QdN = - sign * _diff.dot( _normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, target );

		}

		applyMatrix4( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		}

		equals( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	}

	const _v0$1 = /*@__PURE__*/ new Vector3();
	const _v1$3 = /*@__PURE__*/ new Vector3();
	const _v2$1 = /*@__PURE__*/ new Vector3();
	const _v3 = /*@__PURE__*/ new Vector3();

	const _vab = /*@__PURE__*/ new Vector3();
	const _vac = /*@__PURE__*/ new Vector3();
	const _vbc = /*@__PURE__*/ new Vector3();
	const _vap = /*@__PURE__*/ new Vector3();
	const _vbp = /*@__PURE__*/ new Vector3();
	const _vcp = /*@__PURE__*/ new Vector3();

	class Triangle {

		constructor( a, b, c ) {

			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();

		}

		static getNormal( a, b, c, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getNormal() target is now required' );
				target = new Vector3();

			}

			target.subVectors( c, b );
			_v0$1.subVectors( a, b );
			target.cross( _v0$1 );

			const targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		}

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		static getBarycoord( point, a, b, c, target ) {

			_v0$1.subVectors( c, a );
			_v1$3.subVectors( b, a );
			_v2$1.subVectors( point, a );

			const dot00 = _v0$1.dot( _v0$1 );
			const dot01 = _v0$1.dot( _v1$3 );
			const dot02 = _v0$1.dot( _v2$1 );
			const dot11 = _v1$3.dot( _v1$3 );
			const dot12 = _v1$3.dot( _v2$1 );

			const denom = ( dot00 * dot11 - dot01 * dot01 );

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
				target = new Vector3();

			}

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set( - 2, - 1, - 1 );

			}

			const invDenom = 1 / denom;
			const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		}

		static containsPoint( point, a, b, c ) {

			this.getBarycoord( point, a, b, c, _v3 );

			return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

		}

		static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

			this.getBarycoord( point, p1, p2, p3, _v3 );

			target.set( 0, 0 );
			target.addScaledVector( uv1, _v3.x );
			target.addScaledVector( uv2, _v3.y );
			target.addScaledVector( uv3, _v3.z );

			return target;

		}

		static isFrontFacing( a, b, c, direction ) {

			_v0$1.subVectors( c, b );
			_v1$3.subVectors( a, b );

			// strictly front facing
			return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

		}

		set( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		}

		setFromPointsAndIndices( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		}

		getArea() {

			_v0$1.subVectors( this.c, this.b );
			_v1$3.subVectors( this.a, this.b );

			return _v0$1.cross( _v1$3 ).length() * 0.5;

		}

		getMidpoint( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		}

		getNormal( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		}

		getPlane( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Plane();

			}

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		}

		getBarycoord( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		}

		getUV( point, uv1, uv2, uv3, target ) {

			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

		}

		containsPoint( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		}

		isFrontFacing( direction ) {

			return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

		}

		intersectsBox( box ) {

			return box.intersectsTriangle( this );

		}

		closestPointToPoint( p, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			const a = this.a, b = this.b, c = this.c;
			let v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors( b, a );
			_vac.subVectors( c, a );
			_vap.subVectors( p, a );
			const d1 = _vab.dot( _vap );
			const d2 = _vac.dot( _vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			_vbp.subVectors( p, b );
			const d3 = _vab.dot( _vbp );
			const d4 = _vac.dot( _vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			const vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( _vab, v );

			}

			_vcp.subVectors( p, c );
			const d5 = _vab.dot( _vcp );
			const d6 = _vac.dot( _vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			const vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( _vac, w );

			}

			const va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				_vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

			}

			// face region
			const denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;

			return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

		}

		equals( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	}

	class Face3 {

		constructor( a, b, c, normal, color, materialIndex = 0 ) {

			this.a = a;
			this.b = b;
			this.c = c;

			this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];

			this.color = ( color && color.isColor ) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];

			this.materialIndex = materialIndex;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( let i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( let i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	}

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	}

	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	};

	const _inverseMatrix = new Matrix4();
	const _ray = new Ray();
	const _sphere$1 = new Sphere();

	const _vA = new Vector3();
	const _vB = new Vector3();
	const _vC = new Vector3();

	const _tempA = new Vector3();
	const _tempB = new Vector3();
	const _tempC = new Vector3();

	const _morphA = new Vector3();
	const _morphB = new Vector3();
	const _morphC = new Vector3();

	const _uvA = new Vector2();
	const _uvB = new Vector2();
	const _uvC = new Vector2();

	const _intersectionPoint = new Vector3();
	const _intersectionPointWorld = new Vector3();

	function Mesh( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		updateMorphTargets: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		},

		raycast: function ( raycaster, intersects ) {

			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$1.copy( geometry.boundingSphere );
			_sphere$1.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

			//

			_inverseMatrix.copy( matrixWorld ).invert();
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			let intersection;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const position = geometry.attributes.position;
				const morphPosition = geometry.morphAttributes.position;
				const morphTargetsRelative = geometry.morphTargetsRelative;
				const uv = geometry.attributes.uv;
				const uv2 = geometry.attributes.uv2;
				const groups = geometry.groups;
				const drawRange = geometry.drawRange;

				if ( index !== null ) {

					// indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( let i = 0, il = groups.length; i < il; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							const start = Math.max( group.start, drawRange.start );
							const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( let j = start, jl = end; j < jl; j += 3 ) {

								const a = index.getX( j );
								const b = index.getX( j + 1 );
								const c = index.getX( j + 2 );

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						const start = Math.max( 0, drawRange.start );
						const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

						for ( let i = start, il = end; i < il; i += 3 ) {

							const a = index.getX( i );
							const b = index.getX( i + 1 );
							const c = index.getX( i + 2 );

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				} else if ( position !== undefined ) {

					// non-indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( let i = 0, il = groups.length; i < il; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							const start = Math.max( group.start, drawRange.start );
							const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( let j = start, jl = end; j < jl; j += 3 ) {

								const a = j;
								const b = j + 1;
								const c = j + 2;

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						const start = Math.max( 0, drawRange.start );
						const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

						for ( let i = start, il = end; i < il; i += 3 ) {

							const a = i;
							const b = i + 1;
							const c = i + 2;

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				const isMultiMaterial = Array.isArray( material );

				const vertices = geometry.vertices;
				const faces = geometry.faces;
				let uvs;

				const faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

				for ( let f = 0, fl = faces.length; f < fl; f ++ ) {

					const face = faces[ f ];
					const faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					const fvA = vertices[ face.a ];
					const fvB = vertices[ face.b ];
					const fvC = vertices[ face.c ];

					intersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );

					if ( intersection ) {

						if ( uvs && uvs[ f ] ) {

							const uvs_f = uvs[ f ];
							_uvA.copy( uvs_f[ 0 ] );
							_uvB.copy( uvs_f[ 1 ] );
							_uvC.copy( uvs_f[ 2 ] );

							intersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );

						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );

					}

				}

			}

		}

	} );

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		let intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

		}

		if ( intersect === null ) return null;

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

		_vA.fromBufferAttribute( position, a );
		_vB.fromBufferAttribute( position, b );
		_vC.fromBufferAttribute( position, c );

		const morphInfluences = object.morphTargetInfluences;

		if ( material.morphTargets && morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );
			_morphB.set( 0, 0, 0 );
			_morphC.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, a );
				_tempB.fromBufferAttribute( morphAttribute, b );
				_tempC.fromBufferAttribute( morphAttribute, c );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );
					_morphB.addScaledVector( _tempB, influence );
					_morphC.addScaledVector( _tempC, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( _vA ), influence );
					_morphB.addScaledVector( _tempB.sub( _vB ), influence );
					_morphC.addScaledVector( _tempC.sub( _vC ), influence );

				}

			}

			_vA.add( _morphA );
			_vB.add( _morphB );
			_vC.add( _morphC );

		}

		if ( object.isSkinnedMesh ) {

			object.boneTransform( a, _vA );
			object.boneTransform( b, _vB );
			object.boneTransform( c, _vC );

		}

		const intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

		if ( intersection ) {

			if ( uv ) {

				_uvA.fromBufferAttribute( uv, a );
				_uvB.fromBufferAttribute( uv, b );
				_uvC.fromBufferAttribute( uv, c );

				intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			if ( uv2 ) {

				_uvA.fromBufferAttribute( uv2, a );
				_uvB.fromBufferAttribute( uv2, b );
				_uvC.fromBufferAttribute( uv2, c );

				intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			const face = new Face3( a, b, c );
			Triangle.getNormal( _vA, _vB, _vC, face.normal );

			intersection.face = face;

		}

		return intersection;

	}

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";

	var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmissionmap_fragment: transmissionmap_fragment,
		transmissionmap_pars_fragment: transmissionmap_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },
			uv2Transform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} },

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	const ShaderLib = {

		basic: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		sprite: {

			uniforms: mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: mergeUniforms( [
				UniformsLib.envmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
				clearcoatNormalMap: { value: null },
				sheen: { value: new Color( 0x000000 ) },
				transmission: { value: 0 },
				transmissionMap: { value: null },
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

		const clearColor = new Color( 0x000000 );
		let clearAlpha = 0;

		let planeMesh;
		let boxMesh;

		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render( renderList, scene, camera, forceClear ) {

			let background = scene.isScene === true ? scene.background : null;

			if ( background && background.isTexture ) {

				background = cubemaps.get( background );

			}

			// Ignore background in AR
			// TODO: Reconsider this.

			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();

			if ( session && session.environmentBlendMode === 'additive' ) {

				background = null;

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value;

						}

					} );

					objects.update( boxMesh );

				}

				if ( background.isWebGLCubeRenderTarget ) {

					// TODO Deprecate

					background = background.texture;

				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new ShaderMaterial( {
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}


				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha = 1 ) {

				clearColor.set( color );
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

		const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

		const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;

		const bindingStates = {};

		const defaultState = createBindingState( null );
		let currentState = defaultState;

		function setup( object, material, program, geometry, index ) {

			let updateBuffers = false;

			if ( vaoAvailable ) {

				const state = getBindingState( geometry, program, material );

				if ( currentState !== state ) {

					currentState = state;
					bindVertexArrayObject( currentState.object );

				}

				updateBuffers = needsUpdate( geometry, index );

				if ( updateBuffers ) saveCache( geometry, index );

			} else {

				const wireframe = ( material.wireframe === true );

				if ( currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe ) {

					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;

					updateBuffers = true;

				}

			}

			if ( object.isInstancedMesh === true ) {

				updateBuffers = true;

			}

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( object, material, program, geometry );

				if ( index !== null ) {

					gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

				}

			}

		}

		function createVertexArrayObject() {

			if ( capabilities.isWebGL2 ) return gl.createVertexArray();

			return extension.createVertexArrayOES();

		}

		function bindVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

			return extension.bindVertexArrayOES( vao );

		}

		function deleteVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

			return extension.deleteVertexArrayOES( vao );

		}

		function getBindingState( geometry, program, material ) {

			const wireframe = ( material.wireframe === true );

			let programMap = bindingStates[ geometry.id ];

			if ( programMap === undefined ) {

				programMap = {};
				bindingStates[ geometry.id ] = programMap;

			}

			let stateMap = programMap[ program.id ];

			if ( stateMap === undefined ) {

				stateMap = {};
				programMap[ program.id ] = stateMap;

			}

			let state = stateMap[ wireframe ];

			if ( state === undefined ) {

				state = createBindingState( createVertexArrayObject() );
				stateMap[ wireframe ] = state;

			}

			return state;

		}

		function createBindingState( vao ) {

			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for ( let i = 0; i < maxVertexAttributes; i ++ ) {

				newAttributes[ i ] = 0;
				enabledAttributes[ i ] = 0;
				attributeDivisors[ i ] = 0;

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			};

		}

		function needsUpdate( geometry, index ) {

			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;

			let attributesNum = 0;

			for ( const key in geometryAttributes ) {

				const cachedAttribute = cachedAttributes[ key ];
				const geometryAttribute = geometryAttributes[ key ];

				if ( cachedAttribute === undefined ) return true;

				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

				if ( cachedAttribute.data !== geometryAttribute.data ) return true;

				attributesNum ++;

			}

			if ( currentState.attributesNum !== attributesNum ) return true;

			if ( currentState.index !== index ) return true;

			return false;

		}

		function saveCache( geometry, index ) {

			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				const data = {};
				data.attribute = attribute;

				if ( attribute.data ) {

					data.data = attribute.data;

				}

				cache[ key ] = data;

				attributesNum ++;

			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;

			currentState.index = index;

		}

		function initAttributes() {

			const newAttributes = currentState.newAttributes;

			for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

			if ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT ) ) {

				gl.vertexAttribIPointer( index, size, type, stride, offset );

			} else {

				gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

			}

		}

		function setupVertexAttributes( object, material, program, geometry ) {

			if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

			}

			initAttributes();

			const geometryAttributes = geometry.attributes;

			const programAttributes = program.getAttributes();

			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					const geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;

						const attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count;

								}

							} else {

								enableAttribute( programAttribute );

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
							vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								enableAttribute( programAttribute );

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
							vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

						}

					} else if ( name === 'instanceMatrix' ) {

						const attribute = attributes.get( object.instanceMatrix );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;

						enableAttributeAndDivisor( programAttribute + 0, 1 );
						enableAttributeAndDivisor( programAttribute + 1, 1 );
						enableAttributeAndDivisor( programAttribute + 2, 1 );
						enableAttributeAndDivisor( programAttribute + 3, 1 );

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
						gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
						gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
						gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

					} else if ( name === 'instanceColor' ) {

						const attribute = attributes.get( object.instanceColor );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;

						enableAttributeAndDivisor( programAttribute, 1 );

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

					} else if ( materialDefaultAttributeValues !== undefined ) {

						const value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		function dispose() {

			reset();

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				for ( const programId in programMap ) {

					const stateMap = programMap[ programId ];

					for ( const wireframe in stateMap ) {

						deleteVertexArrayObject( stateMap[ wireframe ].object );

						delete stateMap[ wireframe ];

					}

					delete programMap[ programId ];

				}

				delete bindingStates[ geometryId ];

			}

		}

		function releaseStatesOfGeometry( geometry ) {

			if ( bindingStates[ geometry.id ] === undefined ) return;

			const programMap = bindingStates[ geometry.id ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometry.id ];

		}

		function releaseStatesOfProgram( program ) {

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				if ( programMap[ program.id ] === undefined ) continue;

				const stateMap = programMap[ program.id ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ program.id ];

			}

		}

		function reset() {

			resetDefaultState();

			if ( currentState === defaultState ) return;

			currentState = defaultState;
			bindVertexArrayObject( currentState.object );

		}

		// for backward-compatilibity

		function resetDefaultState() {

			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		};

	}

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawArraysInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawArraysInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLCapabilities( gl, extensions, parameters ) {

		let maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		/* eslint-disable no-undef */
		const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
			( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
		/* eslint-enable no-undef */

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
		const floatVertexTextures = vertexTextures && floatFragmentTextures;

		const maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;

		return {

			isWebGL2: isWebGL2,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	function WebGLClipping( properties ) {

		const scope = this;

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;

		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( material, camera, useCache ) {

			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;

			const materialProperties = properties.get( material );

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;

				let dstArray = materialProperties.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, useCache );

				for ( let i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			return this;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		},

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	function PerspectiveCamera( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			const vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return MathUtils.RAD2DEG * 2 * Math.atan(
				Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			const near = this.near;
			let top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = - 0.5 * width;
			const view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			const skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		},

		toJSON: function ( meta ) {

			const data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	const fov = 90, aspect = 1;

	function CubeCamera( near, far, renderTarget ) {

		Object3D.call( this );

		this.type = 'CubeCamera';

		if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			return;

		}

		this.renderTarget = renderTarget;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		this.update = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			const currentXrEnabled = renderer.xr.enabled;
			const currentRenderTarget = renderer.getRenderTarget();

			renderer.xr.enabled = false;

			const generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

			renderer.xr.enabled = currentXrEnabled;

		};

	}

	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;

	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		format = format !== undefined ? format : RGBFormat;

		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

		// Why CubeTexture._needsFlipEnvMap is necessary:
		//
		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
		// when using WebGLCubeRenderTarget.texture as a cube texture.

		this._needsFlipEnvMap = true;

	}

	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;

	CubeTexture.prototype.isCubeTexture = true;

	Object.defineProperty( CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function ( value ) {

			this.image = value;

		}

	} );

	function WebGLCubeRenderTarget( size, options, dummy ) {

		if ( Number.isInteger( options ) ) {

			console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

			options = dummy;

		}

		WebGLRenderTarget.call( this, size, size, options );

		options = options || {};

		this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture._needsFlipEnvMap = false;

	}

	WebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.format = RGBAFormat; // see #18859
		this.texture.encoding = texture.encoding;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,

			fragmentShader: /* glsl */`

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
		};

		const geometry = new BoxBufferGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	};

	WebGLCubeRenderTarget.prototype.clear = function ( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	};

	function WebGLCubeMaps( renderer ) {

		let cubemaps = new WeakMap();

		function mapTextureMapping( texture, mapping ) {

			if ( mapping === EquirectangularReflectionMapping ) {

				texture.mapping = CubeReflectionMapping;

			} else if ( mapping === EquirectangularRefractionMapping ) {

				texture.mapping = CubeRefractionMapping;

			}

			return texture;

		}

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					if ( cubemaps.has( texture ) ) {

						const cubemap = cubemaps.get( texture ).texture;
						return mapTextureMapping( cubemap, texture.mapping );

					} else {

						const image = texture.image;

						if ( image && image.height > 0 ) {

							const currentRenderList = renderer.getRenderList();
							const currentRenderTarget = renderer.getRenderTarget();

							const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
							renderTarget.fromEquirectangularTexture( renderer, texture );
							cubemaps.set( texture, renderTarget );

							renderer.setRenderTarget( currentRenderTarget );
							renderer.setRenderList( currentRenderList );

							texture.addEventListener( 'dispose', onTextureDispose );

							return mapTextureMapping( renderTarget.texture, texture.mapping );

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

			return texture;

		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemap = cubemaps.get( texture );

			if ( cubemap !== undefined ) {

				cubemaps.delete( texture );
				cubemap.dispose();

			}

		}

		function dispose() {

			cubemaps = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function WebGLExtensions( gl ) {

		const extensions = {};

		return {

			has: function ( name ) {

				if ( extensions[ name ] !== undefined ) {

					return extensions[ name ] !== null;

				}

				let extension;

				switch ( name ) {

					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;

					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;

					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;

					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;

					default:
						extension = gl.getExtension( name );

				}

				extensions[ name ] = extension;

				return extension !== null;

			},

			get: function ( name ) {

				if ( ! this.has( name ) ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				return extensions[ name ];

			}

		};

	}

	function WebGLGeometries( gl, attributes, info, bindingStates ) {

		const geometries = new WeakMap();
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			const geometry = event.target;
			const buffergeometry = geometries.get( geometry );

			if ( buffergeometry.index !== null ) {

				attributes.remove( buffergeometry.index );

			}

			for ( const name in buffergeometry.attributes ) {

				attributes.remove( buffergeometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			geometries.delete( geometry );

			const attribute = wireframeAttributes.get( buffergeometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( buffergeometry );

			}

			bindingStates.releaseStatesOfGeometry( buffergeometry );

			if ( geometry.isInstancedBufferGeometry === true ) {

				delete geometry._maxInstanceCount;

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			let buffergeometry = geometries.get( geometry );

			if ( buffergeometry ) return buffergeometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries.set( geometry, buffergeometry );

			info.memory.geometries ++;

			return buffergeometry;

		}

		function update( geometry ) {

			const geometryAttributes = geometry.attributes;

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for ( const name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			const morphAttributes = geometry.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = morphAttributes[ name ];

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], gl.ARRAY_BUFFER );

				}

			}

		}

		function updateWireframeAttribute( geometry ) {

			const indices = [];

			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if ( geometryIndex !== null ) {

				const array = geometryIndex.array;
				version = geometryIndex.version;

				for ( let i = 0, l = array.length; i < l; i += 3 ) {

					const a = array[ i + 0 ];
					const b = array[ i + 1 ];
					const c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				const array = geometryPosition.array;
				version = geometryPosition.version;

				for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					const a = i + 0;
					const b = i + 1;
					const c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			const attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) attributes.remove( previousAttribute );

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			const currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				const geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		let type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawElementsInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawElementsInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLInfo( gl ) {

		const memory = {
			geometries: 0,
			textures: 0
		};

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			render.calls ++;

			switch ( mode ) {

				case gl.TRIANGLES:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case gl.LINES:
					render.lines += instanceCount * ( count / 2 );
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * ( count - 1 );
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	function numericalSort( a, b ) {

		return a[ 0 ] - b[ 0 ];

	}

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		const influencesList = {};
		const morphInfluences = new Float32Array( 8 );

		const workInfluences = [];

		for ( let i = 0; i < 8; i ++ ) {

			workInfluences[ i ] = [ i, 0 ];

		}

		function update( object, geometry, material, program ) {

			const objectInfluences = object.morphTargetInfluences;

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;

			let influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( let i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			// Collect influences

			for ( let i = 0; i < length; i ++ ) {

				const influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			for ( let i = 0; i < 8; i ++ ) {

				if ( i < length && influences[ i ][ 1 ] ) {

					workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
					workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

				} else {

					workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
					workInfluences[ i ][ 1 ] = 0;

				}

			}

			workInfluences.sort( numericalSort );

			const morphTargets = material.morphTargets && geometry.morphAttributes.position;
			const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			let morphInfluencesSum = 0;

			for ( let i = 0; i < 8; i ++ ) {

				const influence = workInfluences[ i ];
				const index = influence[ 0 ];
				const value = influence[ 1 ];

				if ( index !== Number.MAX_SAFE_INTEGER && value ) {

					if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

						geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

					}

					if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

						geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

					}

					morphInfluences[ i ] = value;
					morphInfluencesSum += value;

				} else {

					if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

						geometry.deleteAttribute( 'morphTarget' + i );

					}

					if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

						geometry.deleteAttribute( 'morphNormal' + i );

					}

					morphInfluences[ i ] = 0;

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	function WebGLObjects( gl, geometries, attributes, info ) {

		let updateMap = new WeakMap();

		function update( object ) {

			const frame = info.render.frame;

			const geometry = object.geometry;
			const buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				if ( geometry.isGeometry ) {

					buffergeometry.updateFromObject( object );

				}

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			if ( object.isInstancedMesh ) {

				if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

					object.addEventListener( 'dispose', onInstancedMeshDispose );

				}

				attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

				if ( object.instanceColor !== null ) {

					attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

				}

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		function onInstancedMeshDispose( event ) {

			const instancedMesh = event.target;

			instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

			attributes.remove( instancedMesh.instanceMatrix );

			if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	function DataTexture2DArray( data = null, width = 1, height = 1, depth = 1 ) {

		Texture.call( this, null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

		this.needsUpdate = true;

	}

	DataTexture2DArray.prototype = Object.create( Texture.prototype );
	DataTexture2DArray.prototype.constructor = DataTexture2DArray;
	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	function DataTexture3D( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		Texture.call( this, null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

		this.needsUpdate = true;


	}

	DataTexture3D.prototype = Object.create( Texture.prototype );
	DataTexture3D.prototype.constructor = DataTexture3D;
	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	const emptyTexture = new Texture();
	const emptyTexture2dArray = new DataTexture2DArray();
	const emptyTexture3d = new DataTexture3D();
	const emptyCubeTexture = new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array( 16 );
	const mat3array = new Float32Array( 9 );
	const mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		const firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( let i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( let i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		let r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( let i = 0; i !== n; ++ i ) {

			r[ i ] = textures.allocateTextureUnit();

		}

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValueM2( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTexture2D( v || emptyTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyTexture2dArray, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || emptyTexture3d, unit );

	}

	function setValueT6( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValueV1i( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	function setValueV2i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// uint

	function setValueV1ui( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}

	// Array of scalars
	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)
	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}


	// Array of vectors (flat or from THREE classes)

	function setValueV2fArray( gl, v ) {

		const data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		const data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2Array( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		const data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		const data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of textures (2D / Cube)

	function setValueT1Array( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		const cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

		const seq = this.seq;

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /(\w+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		const path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			const match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex;

			let id = match[ 1 ];
			const idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				const map = container.map;
				let next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program ) {

		this.seq = [];
		this.map = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( let i = 0; i < n; ++ i ) {

			const info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

		const u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		const v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, textures ) {

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		const r = [];

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	function WebGLShader( gl, type, string ) {

		const shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	let programIdCount = 0;

	function addLineNumbers( string ) {

		const lines = string.split( '\n' );

		for ( let i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			case LogLuvEncoding:
				return [ 'LogLuv', '( value )' ];
			default:
				console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
				return [ 'Linear', '( value )' ];

		}

	}

	function getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
		const log = gl.getShaderInfoLog( shader ).trim();

		if ( status && log === '' ) return '';

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const source = gl.getShaderSource( shader );

		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		const components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		const components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		let toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
				toneMappingName = 'Linear';

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( parameters ) {

		const chunks = [
			( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		const chunks = [];

		for ( const name in defines ) {

			const value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		const attributes = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( let i = 0; i < n; i ++ ) {

			const info = gl.getActiveAttrib( program, i );
			const name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	function includeReplacer( match, include ) {

		const string = ShaderChunk[ include ];

		if ( string === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops( string ) {

		return string
			.replace( unrollLoopPattern, loopReplacer )
			.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

	}

	function deprecatedLoopReplacer( match, start, end, snippet ) {

		console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
		return loopReplacer( match, start, end, snippet );

	}

	function loopReplacer( match, start, end, snippet ) {

		let string = '';

		for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	//

	function generatePrecision( parameters ) {

		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if ( parameters.precision === 'highp' ) {

			precisionstring += '\n#define HIGH_PRECISION';

		} else if ( parameters.precision === 'mediump' ) {

			precisionstring += '\n#define MEDIUM_PRECISION';

		} else if ( parameters.precision === 'lowp' ) {

			precisionstring += '\n#define LOW_PRECISION';

		}

		return precisionstring;

	}

	function generateShadowMapTypeDefine( parameters ) {

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		} else if ( parameters.shadowMapType === VSMShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

		}

		return shadowMapTypeDefine;

	}

	function generateEnvMapTypeDefine( parameters ) {

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

			}

		}

		return envMapTypeDefine;

	}

	function generateEnvMapModeDefine( parameters ) {

		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeRefractionMapping:
				case CubeUVRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

		}

		return envMapModeDefine;

	}

	function generateEnvMapBlendingDefine( parameters ) {

		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if ( parameters.envMap ) {

			switch ( parameters.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		return envMapBlendingDefine;

	}

	function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

		const gl = renderer.getContext();

		const defines = parameters.defines;

		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;

		const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
		const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
		const envMapModeDefine = generateEnvMapModeDefine( parameters );
		const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


		const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

		const customDefines = generateDefines( defines );

		const program = gl.createProgram();

		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if ( parameters.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
				parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
				getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

				parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n';

			prefixVertex = [
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#define varying in',
				( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
				( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programLog = gl.getProgramInfoLog( program ).trim();
			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
				const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		let cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram( this );

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

		const programs = [];

		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const floatVertexTextures = capabilities.floatVertexTextures;
		const maxVertexUniforms = capabilities.maxVertexUniforms;
		const vertexTextures = capabilities.vertexTextures;

		let precision = capabilities.precision;

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		const parameterNames = [
			'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
			'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
			'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
			'roughnessMap', 'metalnessMap', 'gradientMap',
			'alphaMap', 'combine', 'vertexColors', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
			'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
			'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals',
			'maxMorphTargets', 'maxMorphNormals', 'premultipliedAlpha',
			'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
			'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
			'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
			'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
			'sheen', 'transmissionMap'
		];

		function getMaxBones( object ) {

			const skeleton = object.skeleton;
			const bones = skeleton.bones;

			if ( floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				const nVertexUniforms = maxVertexUniforms;
				const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				const maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map ) {

			let encoding;

			if ( map && map.isTexture ) {

				encoding = map.encoding;

			} else if ( map && map.isWebGLRenderTarget ) {

				console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
				encoding = map.texture.encoding;

			} else {

				encoding = LinearEncoding;

			}

			return encoding;

		}

		function getParameters( material, lights, shadows, scene, object ) {

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;

			const envMap = cubemaps.get( material.envMap || environment );

			const shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			let vertexShader, fragmentShader;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];

				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;

			} else {

				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;

			}

			const currentRenderTarget = renderer.getRenderTarget();

			const parameters = {

				isWebGL2: isWebGL2,

				shaderID: shaderID,
				shaderName: material.type,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

				supportsVertexTextures: vertexTextures,
				outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map ),
				matcap: !! material.matcap,
				matcapEncoding: getTextureEncodingFromMap( material.matcap ),
				envMap: !! envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( envMap ),
				envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !! material.clearcoatMap,
				clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
				clearcoatNormalMap: !! material.clearcoatNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				sheen: !! material.sheen,

				transmissionMap: !! material.transmissionMap,

				combine: material.combine,

				vertexTangents: ( material.normalMap && material.vertexTangents ),
				vertexColors: material.vertexColors,
				vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap,
				uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmissionMap ) && !! material.displacementMap,

				fog: !! fog,
				useFog: material.fog,
				fogExp2: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

				rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

				customProgramCacheKey: material.customProgramCacheKey()

			};

			return parameters;

		}

		function getProgramCacheKey( parameters ) {

			const array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.fragmentShader );
				array.push( parameters.vertexShader );

			}

			if ( parameters.defines !== undefined ) {

				for ( const name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			if ( parameters.isRawShaderMaterial === false ) {

				for ( let i = 0; i < parameterNames.length; i ++ ) {

					array.push( parameters[ parameterNames[ i ] ] );

				}

				array.push( renderer.outputEncoding );
				array.push( renderer.gammaFactor );

			}

			array.push( parameters.customProgramCacheKey );

			return array.join();

		}

		function getUniforms( material ) {

			const shaderID = shaderIDs[ material.type ];
			let uniforms;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];
				uniforms = UniformsUtils.clone( shader.uniforms );

			} else {

				uniforms = material.uniforms;

			}

			return uniforms;

		}

		function acquireProgram( parameters, cacheKey ) {

			let program;

			// Check if code has been already compiled
			for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

				const preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
				programs.push( program );

			}

			return program;

		}

		function releaseProgram( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				const i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};

	}

	function WebGLProperties() {

		let properties = new WeakMap();

		function get( object ) {

			let map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList( properties ) {

		const renderItems = [];
		let renderItemsIndex = 0;

		const opaque = [];
		const transparent = [];

		const defaultProgram = { id: - 1 };

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			let renderItem = renderItems[ renderItemsIndex ];
			const materialProperties = properties.get( material );

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).push( renderItem );

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).unshift( renderItem );

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				const renderItem = renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;

			}

		}

		return {

			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists( properties ) {

		let lists = new WeakMap();

		function get( scene, camera ) {

			const cameras = lists.get( scene );
			let list;

			if ( cameras === undefined ) {

				list = new WebGLRenderList( properties );
				lists.set( scene, new WeakMap() );
				lists.get( scene ).set( camera, list );

			} else {

				list = cameras.get( camera );
				if ( list === undefined ) {

					list = new WebGLRenderList( properties );
					cameras.set( camera, list );

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function UniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function ShadowUniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}



	let nextVersion = 0;

	function shadowCastingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

	}

	function WebGLLights( extensions, capabilities ) {

		const cache = new UniformsCache();

		const shadowCache = ShadowUniformsCache();

		const state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup( lights ) {

			let r = 0, g = 0, b = 0;

			for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;

			lights.sort( shadowCastingLightsFirst );

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;

				const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isLightProbe ) {

					for ( let j = 0; j < 9; j ++ ) {

						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

					}

				} else if ( light.isDirectionalLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.directionalShadow[ directionalLength ] = shadowUniforms;
						state.directionalShadowMap[ directionalLength ] = shadowMap;
						state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

						numDirectionalShadows ++;

					}

					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.spotShadow[ spotLength ] = shadowUniforms;
						state.spotShadowMap[ spotLength ] = shadowMap;
						state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

						numSpotShadows ++;

					}

					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;

						state.pointShadow[ pointLength ] = shadowUniforms;
						state.pointShadowMap[ pointLength ] = shadowMap;
						state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

						numPointShadows ++;

					}

					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = cache.get( light );

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			if ( rectAreaLength > 0 ) {

				if ( capabilities.isWebGL2 ) {

					// WebGL 2

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else {

					// WebGL 1

					if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

					} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

					} else {

						console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

					}

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			const hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;

				state.version = nextVersion ++;

			}

		}

		function setupView( lights, camera ) {

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			const viewMatrix = camera.matrixWorldInverse;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				if ( light.isDirectionalLight ) {

					const uniforms = state.directional[ directionalLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = state.spot[ spotLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = state.rectArea[ rectAreaLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = state.point[ pointLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = state.hemi[ hemiLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					hemiLength ++;

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};

	}

	function WebGLRenderState( extensions, capabilities ) {

		const lights = new WebGLLights( extensions, capabilities );

		const lightsArray = [];
		const shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights() {

			lights.setup( lightsArray );

		}

		function setupLightsView( camera ) {

			lights.setupView( lightsArray, camera );

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates( extensions, capabilities ) {

		let renderStates = new WeakMap();

		function get( scene, renderCallDepth = 0 ) {

			let renderState;

			if ( renderStates.has( scene ) === false ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.set( scene, [] );
				renderStates.get( scene ).push( renderState );

			} else {

				if ( renderCallDepth >= renderStates.get( scene ).length ) {

					renderState = new WebGLRenderState( extensions, capabilities );
					renderStates.get( scene ).push( renderState );

				} else {

					renderState = renderStates.get( scene )[ renderCallDepth ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.setValues( parameters );

	}

	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	/**
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;

		this.setValues( parameters );

	}

	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	};

	var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterials = [],
			_distanceMaterials = [],

			_materialCache = {};

		const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		const shadowMaterialVertical = new ShaderMaterial( {

			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},

			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vsm_vert,

			fragmentShader: vsm_frag

		} );

		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
				3
			)
		);

		const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

		const scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			const currentRenderTarget = _renderer.getRenderTarget();
			const activeCubeFace = _renderer.getActiveCubeFace();
			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			for ( let i = 0, il = lights.length; i < il; i ++ ) {

				const light = lights[ i ];
				const shadow = light.shadow;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

				_shadowMapSize.copy( shadow.mapSize );

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply( shadowFrameExtents );

				_viewportSize.copy( shadow.mapSize );

				if ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {

					if ( _shadowMapSize.x > maxTextureSize ) {

						_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;

					}

					if ( _shadowMapSize.y > maxTextureSize ) {

						_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;

					}

				}

				if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

					const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

					shadow.camera.updateProjectionMatrix();

				}

				if ( shadow.map === null ) {

					const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.camera.updateProjectionMatrix();

				}

				_renderer.setRenderTarget( shadow.map );
				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for ( let vp = 0; vp < viewportCount; vp ++ ) {

					const viewport = shadow.getViewport( vp );

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					_state.viewport( _viewport );

					shadow.updateMatrices( light, vp );

					_frustum = shadow.getFrustum();

					renderObject( scene, camera, shadow.camera, light, this.type );

				}

				// do blur pass for VSM

				if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

					VSMPass( shadow, camera );

				}

				shadow.needsUpdate = false;

			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

		};

		function VSMPass( shadow, camera ) {

			const geometry = _objects.update( fullScreenMesh );

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.mapPass );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

		}

		function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

			const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

			let material = _depthMaterials[ index ];

			if ( material === undefined ) {

				material = new MeshDepthMaterial( {

					depthPacking: RGBADepthPacking,

					morphTargets: useMorphing,
					skinning: useSkinning

				} );

				_depthMaterials[ index ] = material;

			}

			return material;

		}

		function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

			const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

			let material = _distanceMaterials[ index ];

			if ( material === undefined ) {

				material = new MeshDistanceMaterial( {

					morphTargets: useMorphing,
					skinning: useSkinning

				} );

				_distanceMaterials[ index ] = material;

			}

			return material;

		}

		function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

			let result = null;

			let getMaterialVariant = getDepthMaterialVariant;
			let customMaterial = object.customDepthMaterial;

			if ( light.isPointLight === true ) {

				getMaterialVariant = getDistanceMaterialVariant;
				customMaterial = object.customDistanceMaterial;

			}

			if ( customMaterial === undefined ) {

				let useMorphing = false;

				if ( material.morphTargets === true ) {

					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

				}

				let useSkinning = false;

				if ( object.isSkinnedMesh === true ) {

					if ( material.skinning === true ) {

						useSkinning = true;

					} else {

						console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

					}

				}

				const useInstancing = object.isInstancedMesh === true;

				result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid;

				let materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				let cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if ( type === VSMShadowMap ) {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

			} else {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

			}

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

				result.referencePosition.setFromMatrixPosition( light.matrixWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, light, type ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					const geometry = _objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

							const group = groups[ k ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, light, type );

			}

		}

	}

	function WebGLState( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {

			let locked = false;

			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			let locked = false;

			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( gl.NEVER );
									break;

								case AlwaysDepth:

									gl.depthFunc( gl.ALWAYS );
									break;

								case LessDepth:

									gl.depthFunc( gl.LESS );
									break;

								case LessEqualDepth:

									gl.depthFunc( gl.LEQUAL );
									break;

								case EqualDepth:

									gl.depthFunc( gl.EQUAL );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( gl.GEQUAL );
									break;

								case GreaterDepth:

									gl.depthFunc( gl.GREATER );
									break;

								case NotEqualDepth:

									gl.depthFunc( gl.NOTEQUAL );
									break;

								default:

									gl.depthFunc( gl.LEQUAL );

							}

						} else {

							gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			let locked = false;

			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( gl.STENCIL_TEST );

						} else {

							disable( gl.STENCIL_TEST );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef !== stencilRef ||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail !== stencilFail ||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();

		let enabledCapabilities = {};

		let currentProgram = null;

		let currentBlendingEnabled = null;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;

		let currentFlipSided = null;
		let currentCullFace = null;

		let currentLineWidth = null;

		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;

		const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter( gl.VERSION );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};

		const currentScissor = new Vector4();
		const currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( let i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

			return texture;

		}

		const emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		setBlending( NoBlending );

		//

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		const equationToGL = {
			[ AddEquation ]: gl.FUNC_ADD,
			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
		};

		if ( isWebGL2 ) {

			equationToGL[ MinEquation ] = gl.MIN;
			equationToGL[ MaxEquation ] = gl.MAX;

		} else {

			const extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				equationToGL[ MinEquation ] = extension.MIN_EXT;
				equationToGL[ MaxEquation ] = extension.MAX_EXT;

			}

		}

		const factorToGL = {
			[ ZeroFactor ]: gl.ZERO,
			[ OneFactor ]: gl.ONE,
			[ SrcColorFactor ]: gl.SRC_COLOR,
			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
			[ DstColorFactor ]: gl.DST_COLOR,
			[ DstAlphaFactor ]: gl.DST_ALPHA,
			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled ) {

					disable( gl.BLEND );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( ! currentBlendingEnabled ) {

				enable( gl.BLEND );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( gl.FUNC_ADD );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.ONE, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
								break;

							case MultiplyBlending:
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = null;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			let flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			let boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function unbindTexture() {

			const boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlendingEnabled = null;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;

			currentFlipSided = null;
			currentCullFace = null;

			currentLineWidth = null;

			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;

		const _videoTextures = new WeakMap();
		let _canvas;

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				new OffscreenCanvas( width, height ) :
				document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			let scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

					const width = floor( scale * image.width );
					const height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					const context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target, texture, width, height ) {

			_gl.generateMipmap( target );

			const textureProperties = properties.get( texture );

			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

		}

		function getInternalFormat( internalFormatName, glFormat, glType ) {

			if ( isWebGL2 === false ) return glFormat;

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

				console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

			}

			let internalFormat = glFormat;

			if ( glFormat === _gl.RED ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

			}

			if ( glFormat === _gl.RGB ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RGB32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGB16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGB8;

			}

			if ( glFormat === _gl.RGBA ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGBA8;

			}

			if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
				internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

				extensions.get( 'EXT_color_buffer_float' );

			}

			return internalFormat;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				_videoTextures.delete( texture );

			}

			info.memory.textures --;

		}

		function onRenderTargetDispose( event ) {

			const renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			info.memory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				for ( let i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
				if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
				if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
				if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

			}

			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );

		}

		//

		let textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			const textureUnit = textureUnits;

			if ( textureUnit >= maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		//

		function setTexture2D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				const image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		}

		function setTexture2DArray( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture );

		}

		function setTexture3D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadCubeTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

		}

		const wrappingToGL = {
			[ RepeatWrapping ]: _gl.REPEAT,
			[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
			[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
		};

		const filterToGL = {
			[ NearestFilter ]: _gl.NEAREST,
			[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
			[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

			[ LinearFilter ]: _gl.LINEAR,
			[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
			[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
		};

		function setTextureParameters( textureType, texture, supportsMips ) {

			if ( supportsMips ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

				if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			let textureType = _gl.TEXTURE_2D;

			if ( texture.isDataTexture2DArray ) textureType = _gl.TEXTURE_2D_ARRAY;
			if ( texture.isDataTexture3D ) textureType = _gl.TEXTURE_3D;

			initTexture( textureProperties, texture );

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( textureType, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
			const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

			const supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format );

			let glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( textureType, texture, supportsMips );

			let mipmap;
			const mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = _gl.DEPTH_COMPONENT;

				if ( isWebGL2 ) {

					if ( texture.type === FloatType ) {

						glInternalFormat = _gl.DEPTH_COMPONENT32F;

					} else if ( texture.type === UnsignedIntType ) {

						glInternalFormat = _gl.DEPTH_COMPONENT24;

					} else if ( texture.type === UnsignedInt248Type ) {

						glInternalFormat = _gl.DEPTH24_STENCIL8;

					} else {

						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D

					}

				} else {

					if ( texture.type === FloatType ) {

						console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

					}

				}

				// validation checks for WebGL 1

				if ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				if ( texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				//

				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				}

			} else if ( texture.isCompressedTexture ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else if ( texture.isDataTexture2DArray ) {

				state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else if ( texture.isDataTexture3D ) {

				state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( textureType, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		function uploadCubeTexture( textureProperties, texture, slot ) {

			if ( texture.image.length !== 6 ) return;

			initTexture( textureProperties, texture );

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

			const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			const cubeImage = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

			}

			const image = cubeImage[ 0 ],
				supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

			let mipmaps;

			if ( isCompressed ) {

				for ( let i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( glFormat !== null ) {

								state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				mipmaps = texture.mipmaps;

				for ( let i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];
							const mipmapImage = mipmap.image[ i ].image;

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length;

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			const glFormat = utils.convert( renderTarget.texture.format );
			const glType = utils.convert( renderTarget.texture.type );
			const glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				let glInternalFormat = _gl.DEPTH_COMPONENT16;

				if ( isMultisample ) {

					const depthTexture = renderTarget.depthTexture;

					if ( depthTexture && depthTexture.isDepthTexture ) {

						if ( depthTexture.type === FloatType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT32F;

						} else if ( depthTexture.type === UnsignedIntType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT24;

						}

					}

					const samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					const samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				const glFormat = utils.convert( renderTarget.texture.format );
				const glType = utils.convert( renderTarget.texture.type );
				const glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );

				if ( isMultisample ) {

					const samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( let i = 0; i < 6; i ++ ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

					}

				} else {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

				}

			}

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( renderTarget.texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
			const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
			const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

			// Handles WebGL2 RGBFormat fallback - #18858

			if ( isWebGL2 && renderTarget.texture.format === RGBFormat && ( renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType ) ) {

				renderTarget.texture.format = RGBAFormat;

				console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

			}

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultisample ) {

					if ( isWebGL2 ) {

						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );

						const glFormat = utils.convert( renderTarget.texture.format );
						const glType = utils.convert( renderTarget.texture.type );
						const glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
						const samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );
						_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

						if ( renderTarget.depthBuffer ) {

							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

						}

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );


					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

					}

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips );

				for ( let i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

				}

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

					generateMipmap( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

					generateMipmap( _gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			const texture = renderTarget.texture;
			const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				if ( isWebGL2 ) {

					const renderTargetProperties = properties.get( renderTarget );

					_gl.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

					const width = renderTarget.width;
					const height = renderTarget.height;
					let mask = _gl.COLOR_BUFFER_BIT;

					if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;
					if ( renderTarget.stencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
				Math.min( maxSamples, renderTarget.samples ) : 0;

		}

		function updateVideoTexture( texture ) {

			const frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures.get( texture ) !== frame ) {

				_videoTextures.set( texture, frame );
				texture.update();

			}

		}

		// backwards compatibility

		let warnedTexture2D = false;
		let warnedTextureCube = false;

		function safeSetTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( warnedTexture2D === false ) {

					console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
					warnedTexture2D = true;

				}

				texture = texture.texture;

			}

			setTexture2D( texture, slot );

		}

		function safeSetTextureCube( texture, slot ) {

			if ( texture && texture.isWebGLCubeRenderTarget ) {

				if ( warnedTextureCube === false ) {

					console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
					warnedTextureCube = true;

				}

				texture = texture.texture;

			}


			setTextureCube( texture, slot );

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;

	}

	function WebGLUtils( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function convert( p ) {

			let extension;

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;

			if ( p === HalfFloatType ) {

				if ( isWebGL2 ) return gl.HALF_FLOAT;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) {

					return extension.HALF_FLOAT_OES;

				} else {

					return null;

				}

			}

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBFormat ) return gl.RGB;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;
			if ( p === RedFormat ) return gl.RED;

			// WebGL2 formats.

			if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
			if ( p === RGFormat ) return gl.RG;
			if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
			if ( p === RGBIntegerFormat ) return gl.RGB_INTEGER;
			if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				} else {

					return null;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL;

				} else {

					return null;

				}

			}

			if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
					if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

				}

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
				p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
				p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
				p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
				p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
				p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					// TODO Complete?

					return p;

				} else {

					return null;

				}

			}

			if ( p === RGBA_BPTC_Format ) {

				extension = extensions.get( 'EXT_texture_compression_bptc' );

				if ( extension !== null ) {

					// TODO Complete?

					return p;

				} else {

					return null;

				}

			}

			if ( p === UnsignedInt248Type ) {

				if ( isWebGL2 ) return gl.UNSIGNED_INT_24_8;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) {

					return extension.UNSIGNED_INT_24_8_WEBGL;

				} else {

					return null;

				}

			}

		}

		return { convert: convert };

	}

	function ArrayCamera( array = [] ) {

		PerspectiveCamera.call( this );

		this.cameras = array;

	}

	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

		constructor: ArrayCamera,

		isArrayCamera: true

	} );

	function Group() {

		Object3D.call( this );

		this.type = 'Group';

	}

	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Group,

		isGroup: true

	} );

	function WebXRController() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	Object.assign( WebXRController.prototype, {

		constructor: WebXRController,

		getHandSpace: function () {

			if ( this._hand === null ) {

				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;

				this._hand.joints = [];
				this._hand.inputState = { pinching: false };

				if ( window.XRHand ) {

					for ( let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i ++ ) {

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new Group();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						this._hand.joints.push( joint );
						// ??
						this._hand.add( joint );

					}

				}

			}

			return this._hand;

		},

		getTargetRaySpace: function () {

			if ( this._targetRay === null ) {

				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;

			}

			return this._targetRay;

		},

		getGripSpace: function () {

			if ( this._grip === null ) {

				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;

			}

			return this._grip;

		},

		dispatchEvent: function ( event ) {

			if ( this._targetRay !== null ) {

				this._targetRay.dispatchEvent( event );

			}

			if ( this._grip !== null ) {

				this._grip.dispatchEvent( event );

			}

			if ( this._hand !== null ) {

				this._hand.dispatchEvent( event );

			}

			return this;

		},

		disconnect: function ( inputSource ) {

			this.dispatchEvent( { type: 'disconnected', data: inputSource } );

			if ( this._targetRay !== null ) {

				this._targetRay.visible = false;

			}

			if ( this._grip !== null ) {

				this._grip.visible = false;

			}

			if ( this._hand !== null ) {

				this._hand.visible = false;

			}

			return this;

		},

		update: function ( inputSource, frame, referenceSpace ) {

			let inputPose = null;
			let gripPose = null;
			let handPose = null;

			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

				if ( hand && inputSource.hand ) {

					handPose = true;

					for ( let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i ++ ) {

						if ( inputSource.hand[ i ] ) {

							// Update the joints groups with the XRJoint poses
							const jointPose = frame.getJointPose( inputSource.hand[ i ], referenceSpace );
							const joint = hand.joints[ i ];

							if ( jointPose !== null ) {

								joint.matrix.fromArray( jointPose.transform.matrix );
								joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
								joint.jointRadius = jointPose.radius;

							}

							joint.visible = jointPose !== null;

							// Custom events

							// Check pinch
							const indexTip = hand.joints[ window.XRHand.INDEX_PHALANX_TIP ];
							const thumbTip = hand.joints[ window.XRHand.THUMB_PHALANX_TIP ];
							const distance = indexTip.position.distanceTo( thumbTip.position );

							const distanceToPinch = 0.02;
							const threshold = 0.005;

							if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

								hand.inputState.pinching = false;
								this.dispatchEvent( {
									type: 'pinchend',
									handedness: inputSource.handedness,
									target: this
								} );

							} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

								hand.inputState.pinching = true;
								this.dispatchEvent( {
									type: 'pinchstart',
									handedness: inputSource.handedness,
									target: this
								} );

							}

						}

					}

				} else {

					if ( targetRay !== null ) {

						inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

						if ( inputPose !== null ) {

							targetRay.matrix.fromArray( inputPose.transform.matrix );
							targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

						}

					}

					if ( grip !== null && inputSource.gripSpace ) {

						gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

						if ( gripPose !== null ) {

							grip.matrix.fromArray( gripPose.transform.matrix );
							grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						}

					}

				}

			}

			if ( targetRay !== null ) {

				targetRay.visible = ( inputPose !== null );

			}

			if ( grip !== null ) {

				grip.visible = ( gripPose !== null );

			}

			if ( hand !== null ) {

				hand.visible = ( handPose !== null );

			}

			return this;

		}

	} );

	function WebXRManager( renderer, gl ) {

		const scope = this;

		let session = null;

		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';

		let pose = null;

		const controllers = [];
		const inputSourcesMap = new Map();

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraVR = new ArrayCamera();
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controller = inputSourcesMap.get( event.inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			inputSourcesMap.forEach( function ( controller, inputSource ) {

				controller.disconnect( inputSource );

			} );

			inputSourcesMap.clear();

			//

			renderer.setFramebuffer( null );
			renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
			animation.stop();

			scope.isPresenting = false;

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		function onRequestReferenceSpace( value ) {

			referenceSpace = value;

			animation.setContext( session );
			animation.start();

			scope.isPresenting = true;

			scope.dispatchEvent( { type: 'sessionstart' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return referenceSpace;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = function ( value ) {

			session = value;

			if ( session !== null ) {

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );

				const attributes = gl.getContextAttributes();

				if ( attributes.xrCompatible !== true ) {

					gl.makeXRCompatible();

				}

				const layerInit = {
					antialias: attributes.antialias,
					alpha: attributes.alpha,
					depth: attributes.depth,
					stencil: attributes.stencil,
					framebufferScaleFactor: framebufferScaleFactor
				};

				// eslint-disable-next-line no-undef
				const baseLayer = new XRWebGLLayer( session, gl, layerInit );

				session.updateRenderState( { baseLayer: baseLayer } );

				session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

				//

				session.addEventListener( 'inputsourceschange', updateInputSources );

			}

		};

		function updateInputSources( event ) {

			const inputSources = session.inputSources;

			// Assign inputSources to available controllers

			for ( let i = 0; i < controllers.length; i ++ ) {

				inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

			}

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
					inputSourcesMap.delete( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'connected', data: inputSource } );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + ( ipd - xOffset );
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.getCamera = function ( camera ) {

			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				} );

				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;

			}

			const parent = camera.parent;
			const cameras = cameraVR.cameras;

			updateCamera( cameraVR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			// update camera and its children

			camera.matrixWorld.copy( cameraVR.matrixWorld );

			const children = camera.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( true );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

			return cameraVR;

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( referenceSpace );

			if ( pose !== null ) {

				const views = pose.views;
				const baseLayer = session.renderState.baseLayer;

				renderer.setFramebuffer( baseLayer.framebuffer );

				let cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if ( views.length !== cameraVR.cameras.length ) {

					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];
					const viewport = baseLayer.getViewport( view );

					const camera = cameras[ i ];
					camera.matrix.fromArray( view.transform.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

					if ( cameraVRNeedsUpdate === true ) {

						cameraVR.cameras.push( camera );

					}

				}

			}

			//

			const inputSources = session.inputSources;

			for ( let i = 0; i < controllers.length; i ++ ) {

				const controller = controllers[ i ];
				const inputSource = inputSources[ i ];

				controller.update( inputSource, frame, referenceSpace );

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

	Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

	function WebGLMaterials( properties ) {

		function refreshFogUniforms( uniforms, fog ) {

			uniforms.fogColor.value.copy( fog.color );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshMaterialUniforms( uniforms, material, pixelRatio, height ) {

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsLambert( uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsToon( uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsPhong( uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( uniforms, material );

				} else {

					refreshUniformsStandard( uniforms, material );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsMatcap( uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDepth( uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDistance( uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsNormal( uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( uniforms, material, pixelRatio, height );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( uniforms, material );

			} else if ( material.isShadowMaterial ) {

				uniforms.color.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			} else if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				uniforms.envMap.value = envMap;

				uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				const maxMipLevel = properties.get( envMap ).__maxMipLevel;

				if ( maxMipLevel !== undefined ) {

					uniforms.maxMipLevel.value = maxMipLevel;

				}

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			} else if ( material.clearcoatMap ) {

				uvScaleMap = material.clearcoatMap;

			} else if ( material.clearcoatNormalMap ) {

				uvScaleMap = material.clearcoatNormalMap;

			} else if ( material.clearcoatRoughnessMap ) {

				uvScaleMap = material.clearcoatRoughnessMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map

			let uv2ScaleMap;

			if ( material.aoMap ) {

				uv2ScaleMap = material.aoMap;

			} else if ( material.lightMap ) {

				uv2ScaleMap = material.lightMap;

			}

			if ( uv2ScaleMap !== undefined ) {

				// backwards compatibility
				if ( uv2ScaleMap.isWebGLRenderTarget ) {

					uv2ScaleMap = uv2ScaleMap.texture;

				}

				if ( uv2ScaleMap.matrixAutoUpdate === true ) {

					uv2ScaleMap.updateMatrix();

				}

				uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value.copy( material.specular );
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			refreshUniformsStandard( uniforms, material );

			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

			uniforms.transmission.value = material.transmission;

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};

	}

	function createCanvasElement() {

		const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		canvas.style.display = 'block';
		return canvas;

	}

	function WebGLRenderer( parameters ) {

		parameters = parameters || {};

		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		let currentRenderList = null;
		let currentRenderState = null;

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its state isolated from the parent render call.

		const renderStateStack = [];

		// public properties

		this.domElement = _canvas;

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		};

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.outputEncoding = LinearEncoding;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		const _this = this;

		let _isContextLost = false;

		// internal state cache

		let _framebuffer = null;

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentFramebuffer = null;
		let _currentMaterialId = - 1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;

		//

		let _width = _canvas.width;
		let _height = _canvas.height;

		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4( 0, 0, _width, _height );
		const _scissor = new Vector4( 0, 0, _width, _height );
		let _scissorTest = false;

		// frustum

		const _frustum = new Frustum();

		// clipping

		let _clippingEnabled = false;
		let _localClippingEnabled = false;

		// camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		let _gl = _context;

		function getContext( contextNames, contextAttributes ) {

			for ( let i = 0; i < contextNames.length; i ++ ) {

				const contextName = contextNames[ i ];
				const context = _canvas.getContext( contextName, contextAttributes );
				if ( context !== null ) return context;

			}

			return null;

		}

		try {

			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			if ( _gl === null ) {

				const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

				if ( _this.isWebGL1Renderer === true ) {

					contextNames.shift();

				}

				_gl = getContext( contextNames, contextAttributes );

				if ( _gl === null ) {

					if ( getContext( contextNames ) ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping;

		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

		let utils, bindingStates;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			if ( capabilities.isWebGL2 === false ) {

				extensions.get( 'WEBGL_depth_texture' );
				extensions.get( 'OES_texture_float' );
				extensions.get( 'OES_texture_half_float' );
				extensions.get( 'OES_texture_half_float_linear' );
				extensions.get( 'OES_standard_derivatives' );
				extensions.get( 'OES_element_index_uint' );
				extensions.get( 'OES_vertex_array_object' );
				extensions.get( 'ANGLE_instanced_arrays' );

			}

			extensions.get( 'OES_texture_float_linear' );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, capabilities );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			cubemaps = new WebGLCubeMaps( _this );
			attributes = new WebGLAttributes( _gl, capabilities );
			bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl );
			clipping = new WebGLClipping( properties );
			programCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
			materials = new WebGLMaterials( properties );
			renderLists = new WebGLRenderLists( properties );
			renderStates = new WebGLRenderStates( extensions, capabilities );
			background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// xr

		const xr = new WebXRManager( _this, _gl );

		this.xr = xr;

		// shadow map

		const shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( xr.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = Math.floor( width * _pixelRatio );
			_canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = Math.floor( width * pixelRatio );
			_canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

				target = new Vector4();

			}

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		this.getClearColor = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' );

				target = new Color();

			}

			return target.copy( background.getClearColor() );

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			let bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			objects.dispose();
			bindingStates.dispose();

			xr.dispose();

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			const material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			const programInfo = properties.get( material ).program;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program );

			} );

		}

		this.renderBufferImmediate = function ( object, program ) {

			bindingStates.initAttributes();

			const buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			const programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				bindingStates.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				bindingStates.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				bindingStates.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				bindingStates.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			bindingStates.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			const program = setProgram( camera, scene, material, object );

			state.setMaterial( material, frontFaceCW );

			//

			let index = geometry.index;
			const position = geometry.attributes.position;

			//

			if ( index === null ) {

				if ( position === undefined || position.count === 0 ) return;

			} else if ( index.count === 0 ) {

				return;

			}

			//

			let rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			if ( material.morphTargets || material.morphNormals ) {

				morphtargets.update( object, geometry, material, program );

			}

			bindingStates.setup( object, material, program, geometry, index );

			let attribute;
			let renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			//

			const dataCount = ( index !== null ) ? index.count : position.count;

			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;

			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;

			const drawStart = Math.max( rangeStart, groupStart );
			const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.TRIANGLES );

				}

			} else if ( object.isLine ) {

				let lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			} else if ( object.isSprite ) {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( object.isInstancedMesh ) {

				renderer.renderInstances( drawStart, drawCount, object.count );

			} else if ( geometry.isInstancedBufferGeometry ) {

				const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

				renderer.renderInstances( drawStart, drawCount, instanceCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene );
			currentRenderState.init();

			scene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights();

			const compiled = new WeakMap();

			scene.traverse( function ( object ) {

				const material = object.material;

				if ( material ) {

					if ( Array.isArray( material ) ) {

						for ( let i = 0; i < material.length; i ++ ) {

							const material2 = material[ i ];

							if ( compiled.has( material2 ) === false ) {

								initMaterial( material2, scene, object );
								compiled.set( material2 );

							}

						}

					} else if ( compiled.has( material ) === false ) {

						initMaterial( material, scene, object );
						compiled.set( material );

					}

				}

			} );

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( xr.isPresenting ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof window !== 'undefined' ) animation.setContext( window );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		};

		// Rendering

		this.render = function ( scene, camera ) {

			let renderTarget, forceClear;

			if ( arguments[ 2 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
				renderTarget = arguments[ 2 ];

			}

			if ( arguments[ 3 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
				forceClear = arguments[ 3 ];

			}

			if ( camera !== undefined && camera.isCamera !== true ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost === true ) return;

			// reset caching for this frame

			bindingStates.resetDefaultState();
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( xr.enabled === true && xr.isPresenting === true ) {

				camera = xr.getCamera( camera );

			}

			//
			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

			currentRenderState = renderStates.get( scene, renderStateStack.length );
			currentRenderState.init();

			renderStateStack.push( currentRenderState );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			//

			if ( _clippingEnabled === true ) clipping.beginShadows();

			const shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights();
			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) clipping.endShadows();

			//

			if ( this.info.autoReset === true ) this.info.reset();

			if ( renderTarget !== undefined ) {

				this.setRenderTarget( renderTarget );

			}

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			const opaqueObjects = currentRenderList.opaque;
			const transparentObjects = currentRenderList.transparent;

			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

			//

			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

			//

			if ( _currentRenderTarget !== null ) {

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			// _gl.finish();

			renderStateStack.pop();
			if ( renderStateStack.length > 0 ) {

				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

			} else {

				currentRenderState = null;

			}

			currentRenderList = null;

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						// update skeleton only once in a frame

						if ( object.skeleton.frame !== info.render.frame ) {

							object.skeleton.update();
							object.skeleton.frame = info.render.frame;

						}

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( Array.isArray( material ) ) {

							const groups = geometry.groups;

							for ( let i = 0, l = groups.length; i < l; i ++ ) {

								const group = groups[ i ];
								const groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

				const renderItem = renderList[ i ];

				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;

				if ( camera.isArrayCamera ) {

					const cameras = camera.cameras;

					for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

						const camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							state.viewport( _currentViewport.copy( camera2.viewport ) );

							currentRenderState.setupLightsView( camera2 );

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				const program = setProgram( camera, scene, material, object );

				state.setMaterial( material );

				bindingStates.reset();

				renderObjectImmediate( object, program );

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function initMaterial( material, scene, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get( material );

			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;

			const lightsStateVersion = lights.state.version;

			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
			const programCacheKey = programCache.getProgramCacheKey( parameters );

			let program = materialProperties.program;
			let programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.cacheKey !== programCacheKey ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {

				programChange = false;

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list, envMap still needs the update here to avoid a frame-late effect

				const environment = material.isMeshStandardMaterial ? scene.environment : null;
				materialProperties.envMap = cubemaps.get( material.envMap || environment );

				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				parameters.uniforms = programCache.getUniforms( material );

				material.onBeforeCompile( parameters, _this );

				program = programCache.acquireProgram( parameters, programCacheKey );

				materialProperties.program = program;
				materialProperties.uniforms = parameters.uniforms;
				materialProperties.outputEncoding = parameters.outputEncoding;

			}

			const uniforms = materialProperties.uniforms;

			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {

				materialProperties.numClippingPlanes = clipping.numPlanes;
				materialProperties.numIntersection = clipping.numIntersection;
				uniforms.clippingPlanes = clipping.uniform;

			}

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			const progUniforms = materialProperties.program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, scene, material, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			const envMap = cubemaps.get( material.envMap || environment );

			const materialProperties = properties.get( material );
			const lights = currentRenderState.state.lights;

			if ( _clippingEnabled === true ) {

				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState( material, camera, useCache );

				}

			}

			if ( material.version === materialProperties.__version ) {

				if ( material.fog && materialProperties.fog !== fog ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.environment !== environment ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
					materialProperties.numIntersection !== clipping.numIntersection ) ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.outputEncoding !== encoding ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.envMap !== envMap ) {

					initMaterial( material, scene, object );

				}

			} else {

				initMaterial( material, scene, object );
				materialProperties.__version = material.version;

			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;

			const program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					const uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.isShadowMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				const skeleton = object.skeleton;

				if ( skeleton ) {

					const bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === null ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							let size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = MathUtils.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					materials.refreshFogUniforms( m_uniforms, fog );

				}

				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height );

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				( material.isShaderMaterial && material.lights === true );

		}

		//
		this.setFramebuffer = function ( value ) {

			if ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( _gl.FRAMEBUFFER, value );

			_framebuffer = value;

		};

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		this.getRenderList = function () {

			return currentRenderList;

		};

		this.setRenderList = function ( renderList ) {

			currentRenderList = renderList;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			let framebuffer = _framebuffer;
			let isCube = false;

			if ( renderTarget ) {

				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					framebuffer = __webglFramebuffer[ activeCubeFace ];
					isCube = true;

				} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				const textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				let restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					restore = true;

				}

				try {

					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

					}

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

			const levelScale = Math.pow( 2, - level );
			const width = Math.floor( texture.image.width * levelScale );
			const height = Math.floor( texture.image.height * levelScale );
			const glFormat = utils.convert( texture.format );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( _gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0 );

			state.unbindTexture();

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

				} else {

					_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );

				}

			}

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );

			state.unbindTexture();

		};

		this.initTexture = function ( texture ) {

			textures.setTexture2D( texture, 0 );

			state.unbindTexture();

		};

		this.resetState = function () {

			state.reset();
			bindingStates.reset();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	class FogExp2 {

		constructor( color, density ) {

			Object.defineProperty( this, 'isFogExp2', { value: true } );

			this.name = '';

			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;

		}

		clone() {

			return new FogExp2( this.color, this.density );

		}

		toJSON( /* meta */ ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		}

	}

	class Scene extends Object3D {

		constructor() {

			super();

			Object.defineProperty( this, 'isScene', { value: true } );

			this.type = 'Scene';

			this.background = null;
			this.environment = null;
			this.fog = null;

			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.environment !== null ) this.environment = source.environment.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();

			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		}

	}

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	function LineBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.morphTargets = false;

		this.setValues( parameters );

	}

	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.morphTargets = source.morphTargets;

		return this;

	};

	const _start = new Vector3();
	const _end = new Vector3();
	const _inverseMatrix$1 = new Matrix4();
	const _ray$1 = new Ray();
	const _sphere$2 = new Sphere();

	function Line( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		computeLineDistances: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					const positionAttribute = geometry.attributes.position;
					const lineDistances = [ 0 ];

					for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

						_start.fromBufferAttribute( positionAttribute, i - 1 );
						_end.fromBufferAttribute( positionAttribute, i );

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += _start.distanceTo( _end );

					}

					geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				const vertices = geometry.vertices;
				const lineDistances = geometry.lineDistances;

				lineDistances[ 0 ] = 0;

				for ( let i = 1, l = vertices.length; i < l; i ++ ) {

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

				}

			}

			return this;

		},

		raycast: function ( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$2.copy( geometry.boundingSphere );
			_sphere$2.applyMatrix4( matrixWorld );
			_sphere$2.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;

			//

			_inverseMatrix$1.copy( matrixWorld ).invert();
			_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if ( index !== null ) {

					const indices = index.array;

					for ( let i = 0, l = indices.length - 1; i < l; i += step ) {

						const a = indices[ i ];
						const b = indices[ i + 1 ];

						vStart.fromBufferAttribute( positionAttribute, a );
						vEnd.fromBufferAttribute( positionAttribute, b );

						const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localThresholdSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					for ( let i = 0, l = positionAttribute.count - 1; i < l; i += step ) {

						vStart.fromBufferAttribute( positionAttribute, i );
						vEnd.fromBufferAttribute( positionAttribute, i + 1 );

						const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localThresholdSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry.isGeometry ) {

				const vertices = geometry.vertices;
				const nbVertices = vertices.length;

				for ( let i = 0; i < nbVertices - 1; i += step ) {

					const distSq = _ray$1.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		},

		updateMorphTargets: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

	} );

	const _start$1 = new Vector3();
	const _end$1 = new Vector3();

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					const positionAttribute = geometry.attributes.position;
					const lineDistances = [];

					for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

						_start$1.fromBufferAttribute( positionAttribute, i );
						_end$1.fromBufferAttribute( positionAttribute, i + 1 );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

					}

					geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				const vertices = geometry.vertices;
				const lineDistances = geometry.lineDistances;

				for ( let i = 0, l = vertices.length; i < l; i += 2 ) {

					_start$1.copy( vertices[ i ] );
					_end$1.copy( vertices[ i + 1 ] );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

				}

			}

			return this;

		}

	} );

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */

	function PointsMaterial( parameters ) {

		Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.setValues( parameters );

	}

	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;

	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;

	};

	const _inverseMatrix$2 = new Matrix4();
	const _ray$2 = new Ray();
	const _sphere$3 = new Sphere();
	const _position$1 = new Vector3();

	function Points( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		raycast: function ( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$3.copy( geometry.boundingSphere );
			_sphere$3.applyMatrix4( matrixWorld );
			_sphere$3.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

			//

			_inverseMatrix$2.copy( matrixWorld ).invert();
			_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if ( index !== null ) {

					const indices = index.array;

					for ( let i = 0, il = indices.length; i < il; i ++ ) {

						const a = indices[ i ];

						_position$1.fromBufferAttribute( positionAttribute, a );

						testPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				} else {

					for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

						_position$1.fromBufferAttribute( positionAttribute, i );

						testPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				}

			} else {

				const vertices = geometry.vertices;

				for ( let i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		},

		updateMorphTargets: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

	} );

	function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

		const rayPointDistanceSq = _ray$2.distanceSqToPoint( point );

		if ( rayPointDistanceSq < localThresholdSq ) {

			const intersectPoint = new Vector3();

			_ray$2.closestPointToPoint( point, intersectPoint );
			intersectPoint.applyMatrix4( matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				distanceToRay: Math.sqrt( rayPointDistanceSq ),
				point: intersectPoint,
				index: index,
				face: null,
				object: object

			} );

		}

	}

	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;

	class SphereBufferGeometry extends BufferGeometry {

		constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

			super();
			this.type = 'SphereBufferGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			widthSegments = Math.max( 3, Math.floor( widthSegments ) );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) );

			const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

			let index = 0;
			const grid = [];

			const vertex = new Vector3();
			const normal = new Vector3();

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// generate vertices, normals and uvs

			for ( let iy = 0; iy <= heightSegments; iy ++ ) {

				const verticesRow = [];

				const v = iy / heightSegments;

				// special case for the poles

				let uOffset = 0;

				if ( iy == 0 && thetaStart == 0 ) {

					uOffset = 0.5 / widthSegments;

				} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

					uOffset = - 0.5 / widthSegments;

				}

				for ( let ix = 0; ix <= widthSegments; ix ++ ) {

					const u = ix / widthSegments;

					// vertex

					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.copy( vertex ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u + uOffset, 1 - v );

					verticesRow.push( index ++ );

				}

				grid.push( verticesRow );

			}

			// indices

			for ( let iy = 0; iy < heightSegments; iy ++ ) {

				for ( let ix = 0; ix < widthSegments; ix ++ ) {

					const a = grid[ iy ][ ix + 1 ];
					const b = grid[ iy ][ ix ];
					const c = grid[ iy + 1 ][ ix ];
					const d = grid[ iy + 1 ][ ix + 1 ];

					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	class RingBufferGeometry extends BufferGeometry {

		constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'RingBufferGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			thetaSegments = Math.max( 3, thetaSegments );
			phiSegments = Math.max( 1, phiSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// some helper variables

			let radius = innerRadius;
			const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			const vertex = new Vector3();
			const uv = new Vector2();

			// generate vertices, normals and uvs

			for ( let j = 0; j <= phiSegments; j ++ ) {

				for ( let i = 0; i <= thetaSegments; i ++ ) {

					// values are generate from the inside of the ring to the outside

					const segment = thetaStart + i / thetaSegments * thetaLength;

					// vertex

					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, 0, 1 );

					// uv

					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;

					uvs.push( uv.x, uv.y );

				}

				// increase the radius for next row of vertices

				radius += radiusStep;

			}

			// indices

			for ( let j = 0; j < phiSegments; j ++ ) {

				const thetaSegmentLevel = j * ( thetaSegments + 1 );

				for ( let i = 0; i < thetaSegments; i ++ ) {

					const segment = i + thetaSegmentLevel;

					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	class CylinderBufferGeometry extends BufferGeometry {

		constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();
			this.type = 'CylinderBufferGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			const scope = this;

			radialSegments = Math.floor( radialSegments );
			heightSegments = Math.floor( heightSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function generateTorso() {

				const normal = new Vector3();
				const vertex = new Vector3();

				let groupCount = 0;

				// this will be used to calculate the normal
				const slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( let y = 0; y <= heightSegments; y ++ ) {

					const indexRow = [];

					const v = y / heightSegments;

					// calculate the radius of the current row

					const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( let x = 0; x <= radialSegments; x ++ ) {

						const u = x / radialSegments;

						const theta = u * thetaLength + thetaStart;

						const sinTheta = Math.sin( theta );
						const cosTheta = Math.cos( theta );

						// vertex

						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );

						// normal

						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );

						// uv

						uvs.push( u, 1 - v );

						// save index of vertex in respective row

						indexRow.push( index ++ );

					}

					// now save vertices of the row in our index array

					indexArray.push( indexRow );

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					for ( let y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices

						const a = indexArray[ y ][ x ];
						const b = indexArray[ y + 1 ][ x ];
						const c = indexArray[ y + 1 ][ x + 1 ];
						const d = indexArray[ y ][ x + 1 ];

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// update group counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

			function generateCap( top ) {

				// save the index of the first center vertex
				const centerIndexStart = index;

				const uv = new Vector2();
				const vertex = new Vector3();

				let groupCount = 0;

				const radius = ( top === true ) ? radiusTop : radiusBottom;
				const sign = ( top === true ) ? 1 : - 1;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( let x = 1; x <= radialSegments; x ++ ) {

					// vertex

					vertices.push( 0, halfHeight * sign, 0 );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uvs.push( 0.5, 0.5 );

					// increase index

					index ++;

				}

				// save the index of the last center vertex
				const centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;

					const cosTheta = Math.cos( theta );
					const sinTheta = Math.sin( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );

					// increase index

					index ++;

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if ( top === true ) {

						// face top

						indices.push( i, i + 1, c );

					} else {

						// face bottom

						indices.push( i + 1, i, c );

					}

					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

		}

	}

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.MultiplyOperation,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	const Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	function LoadingManager( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

	const DefaultLoadingManager = new LoadingManager();

	function Loader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	Object.assign( Loader.prototype, {

		load: function ( /* url, onLoad, onProgress, onError */ ) {},

		loadAsync: function ( url, onProgress ) {

			const scope = this;

			return new Promise( function ( resolve, reject ) {

				scope.load( url, resolve, onProgress, reject );

			} );

		},

		parse: function ( /* data */ ) {},

		setCrossOrigin: function ( crossOrigin ) {

			this.crossOrigin = crossOrigin;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setPath: function ( path ) {

			this.path = path;
			return this;

		},

		setResourcePath: function ( resourcePath ) {

			this.resourcePath = resourcePath;
			return this;

		},

		setRequestHeader: function ( requestHeader ) {

			this.requestHeader = requestHeader;
			return this;

		}

	} );

	function ImageLoader( manager ) {

		Loader.call( this, manager );

	}

	ImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: ImageLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			function onImageLoad() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		}

	} );

	function TextureLoader( manager ) {

		Loader.call( this, manager );

	}

	TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			const texture = new Texture();

			const loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		}

	} );

	const loading = {};

	function FileLoader( manager ) {

		Loader.call( this, manager );

	}

	FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: FileLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			const dataUriRegexResult = url.match( dataUriRegex );
			let request;

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				const mimeType = dataUriRegexResult[ 1 ];
				const isBase64 = !! dataUriRegexResult[ 2 ];

				let data = dataUriRegexResult[ 3 ];
				data = decodeURIComponent( data );

				if ( isBase64 ) data = atob( data );

				try {

					let response;
					const responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							const view = new Uint8Array( data.length );

							for ( let i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							const parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					const response = this.response;

					const callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 || this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						// Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.
						Cache.add( url, response );

						for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

							const callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

							const callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					const callbacks = loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					const callbacks = loading[ url ];

					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				request.addEventListener( 'abort', function ( event ) {

					const callbacks = loading[ url ];

					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( const header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		}

	} );

	function Light( color, intensity = 1 ) {

		Object3D.call( this );

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Light,

		isLight: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		},

		toJSON: function ( meta ) {

			const data = Object3D.prototype.toJSON.call( this, meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	} );

	function HemisphereLight( skyColor, groundColor, intensity ) {

		Light.call( this, skyColor, intensity );

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: HemisphereLight,

		isHemisphereLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	} );

	function LightShadow( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	Object.assign( LightShadow.prototype, {

		_projScreenMatrix: new Matrix4(),

		_lightPositionWorld: new Vector3(),

		_lookTarget: new Vector3(),

		getViewportCount: function () {

			return this._viewportCount;

		},

		getFrustum: function () {

			return this._frustum;

		},

		updateMatrices: function ( light ) {

			const shadowCamera = this.camera,
				shadowMatrix = this.matrix,
				projScreenMatrix = this._projScreenMatrix,
				lookTarget = this._lookTarget,
				lightPositionWorld = this._lightPositionWorld;

			lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( lightPositionWorld );

			lookTarget.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( lookTarget );
			shadowCamera.updateMatrixWorld();

			projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( projScreenMatrix );

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

		},

		getViewport: function ( viewportIndex ) {

			return this._viewports[ viewportIndex ];

		},

		getFrameExtents: function () {

			return this._frameExtents;

		},

		copy: function ( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			const object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	} );

	function OrthographicCamera( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		},

		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			const dx = ( this.right - this.left ) / ( 2 * this.zoom );
			const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			const cx = ( this.right + this.left ) / 2;
			const cy = ( this.top + this.bottom ) / 2;

			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		},

		toJSON: function ( meta ) {

			const data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	} );

	function DirectionalLightShadow() {

		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: DirectionalLightShadow,

		isDirectionalLightShadow: true,

		updateMatrices: function ( light ) {

			LightShadow.prototype.updateMatrices.call( this, light );

		}

	} );

	function DirectionalLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: DirectionalLight,

		isDirectionalLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	function AmbientLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'AmbientLight';

	}

	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: AmbientLight,

		isAmbientLight: true

	} );

	const _eyeRight = new Matrix4();
	const _eyeLeft = new Matrix4();

	function StereoCamera() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	Object.assign( StereoCamera.prototype, {

		update: function ( camera ) {

			const cache = this._cache;

			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
				cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
				cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if ( needsUpdate ) {

				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				const projectionMatrix = camera.projectionMatrix.clone();
				const eyeSepHalf = cache.eyeSep / 2;
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				const ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
				let xmin, xmax;

				// translate xOffset

				_eyeLeft.elements[ 12 ] = - eyeSepHalf;
				_eyeRight.elements[ 12 ] = eyeSepHalf;

				// for left eye

				xmin = - ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( projectionMatrix );

				// for right eye

				xmin = - ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

		}

	} );

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.instanceCount = source.instanceCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			const data = BufferGeometry.prototype.toJSON.call( this );

			data.instanceCount = this.instanceCount;

			data.isInstancedBufferGeometry = true;

			return data;

		}

	} );

	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

		if ( typeof ( normalized ) === 'number' ) {

			meshPerAttribute = normalized;

			normalized = false;

			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		}

		BufferAttribute.call( this, array, itemSize, normalized );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		},

		toJSON: function ()	{

			const data = BufferAttribute.prototype.toJSON.call( this );

			data.meshPerAttribute = this.meshPerAttribute;

			data.isInstancedBufferAttribute = true;

			return data;

		}

	} );

	function InterleavedBuffer( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

		this.uuid = MathUtils.generateUUID();

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback: function () {},

		setUsage: function ( value ) {

			this.usage = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( let i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		},

		clone: function ( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = MathUtils.generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

			}

			const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

			const ib = new InterleavedBuffer( array, this.stride );
			ib.setUsage( this.usage );

			return ib;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		toJSON: function ( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			// generate UUID for array buffer if necessary

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = MathUtils.generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

			}

			//

			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};

		}

	} );

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		},

		clone: function ( data ) {

			const ib = InterleavedBuffer.prototype.clone.call( this, data );

			ib.meshPerAttribute = this.meshPerAttribute;

			return ib;

		},

		toJSON: function ( data ) {

			const json = InterleavedBuffer.prototype.toJSON.call( this, data );

			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;

			return json;

		}

	} );

	const _vector$6 = new Vector3();

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		},

		needsUpdate: {

			set: function ( value ) {

				this.data.needsUpdate = value;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		applyMatrix4: function ( m ) {

			for ( let i = 0, l = this.data.count; i < l; i ++ ) {

				_vector$6.x = this.getX( i );
				_vector$6.y = this.getY( i );
				_vector$6.z = this.getZ( i );

				_vector$6.applyMatrix4( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		},

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		},

		clone: function ( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

			} else {

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

				}

				return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

			}

		},

		toJSON: function ( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				// deinterleave data and save it as an ordinary buffer attribute for now

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};

			} else {

				// save as true interlaved attribtue

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};

			}

		}

	} );

	function Raycaster( origin, direction, near, far ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.layers.test( raycaster.layers ) ) {

			object.raycast( raycaster, intersects );

		}

		if ( recursive === true ) {

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( camera && camera.isPerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
				this.camera = camera;

			} else if ( camera && camera.isOrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				this.camera = camera;

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

			}

		},

		intersectObject: function ( object, recursive, optionalTarget ) {

			const intersects = optionalTarget || [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive, optionalTarget ) {

			const intersects = optionalTarget || [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( let i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {

		constructor( radius = 1, phi = 0, theta = 0 ) {

			this.radius = radius;
			this.phi = phi; // polar angle
			this.theta = theta; // azimuthal angle

			return this;

		}

		set( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		}

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe() {

			const EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		}

		setFromVector3( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		}

		setFromCartesianCoords( x, y, z ) {

			this.radius = Math.sqrt( x * x + y * y + z * z );

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

			}

			return this;

		}

	}

	const _vector$7 = /*@__PURE__*/ new Vector2();

	class Box2 {

		constructor( min, max ) {

			Object.defineProperty( this, 'isBox2', { value: true } );

			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		}

		getCenter( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getCenter() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getSize() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getParameter() target is now required' );
				target = new Vector2();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		}

		intersectsBox( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		}

		clampPoint( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
				target = new Vector2();

			}

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			const clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	const _startP = /*@__PURE__*/ new Vector3();
	const _startEnd = /*@__PURE__*/ new Vector3();

	class Line3 {

		constructor( start, end ) {

			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();

		}

		set( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		}

		getCenter( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		}

		delta( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .delta() target is now required' );
				target = new Vector3();

			}

			return target.subVectors( this.end, this.start );

		}

		distanceSq() {

			return this.start.distanceToSquared( this.end );

		}

		distance() {

			return this.start.distanceTo( this.end );

		}

		at( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .at() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		}

		closestPointToPointParameter( point, clampToLine ) {

			_startP.subVectors( point, this.start );
			_startEnd.subVectors( this.end, this.start );

			const startEnd2 = _startEnd.dot( _startEnd );
			const startEnd_startP = _startEnd.dot( _startP );

			let t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = MathUtils.clamp( t, 0, 1 );

			}

			return t;

		}

		closestPointToPoint( point, clampToLine, target ) {

			const t = this.closestPointToPointParameter( point, clampToLine );

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		}

		applyMatrix4( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		}

		equals( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	}

	MathUtils.generateUUID = function () { return null; };

	Object3D.DefaultUp.set( 0, 0, 1 );

	Object3D.prototype.addStatic = function ( obj ) {

		obj.matrixAutoUpdate = false;
		obj.updateMatrix();

		this.add( obj );

	};

	// attributes to construct unit square

	const indexAttribute = new Uint16BufferAttribute( [ 0, 2, 1, 0, 3, 2 ], 1 );

	const positionAttribute = new Float32BufferAttribute( [
		0, 0, 0,
		0, 1, 0,
		1, 1, 0,
		1, 0, 0
	], 3 );


	const CommonAttributes = {
		index: indexAttribute,
		position: positionAttribute
	};

	function onUploadDropBuffer() {

		// call back from BufferAttribute to drop JS buffers after data has been transfered to GPU
		this.array = null;

	}

	function GlyphStringGeometryCache ( material ) {

		this.material = material;
		this.cache = {};

	}

	const __v0 = new Vector3();
	const __v1 = new Vector3();
	const __v2 = new Vector3();
	const __v3 = new Vector3();
	const __v4 = new Vector3();

	const __triangle1 = new Triangle();
	const __triangle2 = new Triangle();

	GlyphStringGeometryCache.prototype.getGeometry = function ( text ) {

		var entry = this.cache[ text ];

		if ( entry === undefined ) {

			entry = new GlyphStringGeometry( text, this.material.getAtlas() );
			this.cache[ text ] = entry;
			entry.isCached = true;

		}

		return entry;

	};

	function GlyphStringGeometry ( text, glyphAtlas ) {

		InstancedBufferGeometry.call( this );

		this.type = 'GlyphStringGeometry';
		this.width = 0;

		this.setIndex( CommonAttributes.index );
		this.setAttribute( 'position', CommonAttributes.position );

		const l = text.length;

		this.glyphAtlas = glyphAtlas;

		this.setAttribute( 'instanceUvs', new InstancedBufferAttribute( new Float32Array( l * 2 ), 2, false, 1 ) );
		this.setAttribute( 'instanceOffsets', new InstancedBufferAttribute( new Float32Array( l ), 1, false, 1 ) );
		this.setAttribute( 'instanceWidths', new InstancedBufferAttribute( new Float32Array( l ), 1, false, 1 ) );

		this.setString( text );

		this.computeBoundingSphere();

	}

	GlyphStringGeometry.prototype = Object.create( InstancedBufferGeometry.prototype );


	GlyphStringGeometry.prototype.setString = function ( text ) {

		const instanceUvs = this.getAttribute( 'instanceUvs' );
		const instanceOffsets = this.getAttribute( 'instanceOffsets' );
		const instanceWidths = this.getAttribute( 'instanceWidths' );

		const l = text.length, glyphAtlas = this.glyphAtlas;

		var i, offset = 0;

		for ( i = 0; i < l; i++ ) {

			if ( text.charCodeAt( i ) === 0 ) continue; // skip null characters
			const glyphData = glyphAtlas.getGlyph( text[ i ] );

			instanceUvs.setXY( i, glyphData.column, glyphData.row );
			instanceWidths.setX( i, glyphData.width );
			instanceOffsets.setX( i, offset );

			offset += glyphData.width;

		}

		instanceUvs.needsUpdate = true;
		instanceOffsets.needsUpdate = true;
		instanceWidths.needsUpdate = true;

		this.width = offset;
		this.name = text;
		this.instanceCount = l;

	};

	GlyphStringGeometry.prototype.dispose = function () {

		if ( this.isCached ) return;

		// delete shared attributes to prevent internal render state
		// being lost on dispose() call.

		this.deleteAttribute( 'position' );
		this.setIndex( null );

		InstancedBufferGeometry.prototype.dispose.call( this );

	};

	function GlyphString ( text, glyphMaterial, ctx ) {

		var geometry;

		if ( this.isMutableGlyphString ) {

			geometry = new GlyphStringGeometry( text, glyphMaterial.getAtlas() );

		} else {

			const glyphStringCache = ctx.glyphStringCache;

			let cache = glyphStringCache.get( glyphMaterial );

			if ( cache === undefined ) {

				// create material cache
				cache = new GlyphStringGeometryCache( glyphMaterial );
				glyphStringCache.set( glyphMaterial, cache );

			}

			geometry = cache.getGeometry( text );

		}

		Mesh.call( this, geometry, glyphMaterial );

		this.name = text;

		if ( ! this.isMutableGlyphString ) {

			geometry.getAttribute( 'instanceUvs' ).onUpload( onUploadDropBuffer );
			geometry.getAttribute( 'instanceOffsets' ).onUpload( onUploadDropBuffer );
			geometry.getAttribute( 'instanceWidths' ).onUpload( onUploadDropBuffer );

		}

	}

	GlyphString.prototype = Object.create( Mesh.prototype );

	GlyphString.prototype.isGlyphString = true;

	GlyphString.prototype.getWidth = function () {

		return this.geometry.width * this.material.scaleFactor;

	};

	GlyphString.prototype.getHeight = function () {

		return this.material.scaleFactor;

	};

	GlyphString.prototype.intersects = function ( position, camera, scale ) {

		if ( ! this.visible ) return false;

		const width = this.getWidth() / scale.x;
		const height = this.getHeight() / scale.y;
		const rotation = this.material.rotation;

		// mouse position in NDC
		__v0.set( position.x, position.y, 0 );

		// label bottom left in NDC
		__v1.setFromMatrixPosition( this.modelViewMatrix );
		__v1.applyMatrix4( camera.projectionMatrix );

		this.depth = __v1.z;

		__v1.z = 0;

		if ( isNaN( __v1.x ) ) return;

		// remaining vertices of label
		__v2.set( width, 0, 0 ).applyAxisAngle( Object3D.DefaultUp, rotation );
		__v3.set( width, height, 0 ).applyAxisAngle( Object3D.DefaultUp, rotation );
		__v4.set( 0, height, 0 ).applyAxisAngle( Object3D.DefaultUp, rotation );

		// adjust for aspect ratio
		__v2.y *= scale.x / scale.y;
		__v3.y *= scale.x / scale.y;
		__v4.y *= scale.x / scale.y;

		__v2.add( __v1 );
		__v3.add( __v1 );
		__v4.add( __v1 );

		__triangle1.set( __v1, __v2, __v3 );
		__triangle2.set( __v1, __v3, __v4 );

		return (
			( __triangle1.containsPoint( __v0 ) ) ||
			( __triangle2.containsPoint( __v0 ) )
		);

	};

	function MutableGlyphString ( text, material ) {

		GlyphString.call( this, text, material );

	}

	MutableGlyphString.prototype = Object.create( GlyphString.prototype );

	MutableGlyphString.prototype.isMutableGlyphString = true;

	MutableGlyphString.prototype.replaceString = function ( newstring ) {

		if ( newstring.length !== this.name.length ) {

			console.warn( 'new string has invalid length', newstring, this.name.length, newstring.length );
			return;

		}

		this.geometry.setString( newstring );

	};

	// preallocated tmp objects
	const __xAxis = new Vector3( 1, 0, 0 );

	function AHI ( hudObject ) {

		const stdWidth  = hudObject.stdWidth;
		const stdMargin = hudObject.stdMargin;

		const cfg = hudObject.ctx.cfg;
		const materials = hudObject.ctx.materials;

		const c1 = cfg.themeColor( 'hud.ahi.sky' );
		const c2 = cfg.themeColor( 'hud.ahi.earth' );

		Group.call( this );

		this.name = 'CV.AHI';

		this.lastPitch = 0;

		// artificial horizon instrument
		const globe = new Group();

		const ring = hudObject.getCommonRing();
		const ahiWidth = stdWidth * 0.75;

		const sphere = new SphereBufferGeometry( ahiWidth, 31, 31 );
		const bar    = new BufferGeometry();
		const marks  = new BufferGeometry();

		const sv = sphere.getAttribute( 'position' ).count;

		hudObject.dropBuffers( sphere );

		const sphereColors = new Float32BufferAttribute( new Float32Array( sv * 3 ), 3 );

		var i;

		for ( i = 0; i < sv; i++ ) {

			( ( i < sv / 2 ) ? c1 : c2 ).toArray( sphereColors.array, i * 3 );

		}

		sphere.setAttribute( 'color', sphereColors );

		var vertices = [];

		// view orientation line

		vertices.push( 4 - stdWidth, 0, ahiWidth );
		vertices.push( stdWidth - 4, 0, ahiWidth );

		const positions = new Float32BufferAttribute( vertices.length, 3 );

		bar.setAttribute( 'position', positions.copyArray( vertices ) );

		const markWidth = stdWidth / 10;

		// pitch interval marks
		const m1 = new Vector3(  markWidth, 0, ahiWidth + 1 );
		const m2 = new Vector3( -markWidth, 0, ahiWidth + 1 );

		vertices = [];

		for ( i = 0; i < 12; i++ ) {

			const mn1 = m1.clone();
			const mn2 = m2.clone();

			if ( i % 3 === 0 ) {

				mn1.x *= 2;
				mn2.x *= 2;

			}

			mn1.applyAxisAngle( __xAxis, i * Math.PI / 6 );
			mn2.applyAxisAngle( __xAxis, i * Math.PI / 6 );

			vertices.push( mn1 );
			vertices.push( mn2 );

		}

		const markPositions = new Float32BufferAttribute( vertices.length * 3, 3 );

		marks.setAttribute( 'position', markPositions.copyVector3sArray( vertices ) );

		const mRing   = new Mesh( ring, materials.getBezelMaterial() );
		const mSphere = new Mesh( sphere, new MeshPhongMaterial( { vertexColors: true, specular: 0x666666, shininess: 20 } ) );
		const mBar    = new LineSegments( bar,   new LineBasicMaterial( { color: cfg.themeValue( 'hud.ahi.bar' ) } ) );
		const mMarks  = new LineSegments( marks, new LineBasicMaterial( { color: cfg.themeValue( 'hud.ahi.marks' ) } ) );

		mSphere.rotateOnAxis( new Vector3( 0, 1, 0 ), Math.PI / 2 );
		mMarks.rotateOnAxis( new Vector3( 1, 0, 0 ), Math.PI / 2 );
		mRing.rotateOnAxis( new Vector3( 0, 0, 1 ), Math.PI / 8 );

		globe.addStatic( mSphere );
		globe.addStatic( mMarks );

		this.addStatic( mRing );
		this.addStatic( mBar );

		this.add( globe );

		const offset = stdWidth + stdMargin;

		this.translateX( -3 * offset );
		this.translateY( offset );

		this.globe = globe;

		const material = materials.getGlyphMaterial( hudObject.atlasSpec, 0 );
		const label = new MutableGlyphString( '-90\u00B0', material );

		label.translateX( - label.getWidth() / 2 );
		label.translateY( stdWidth + 5 );

		this.addStatic( label );

		this.label = label;

		return this;

	}

	AHI.prototype = Object.create( Group.prototype );

	AHI.prototype.set = function () {

		const __direction = new Vector3();

		return function set ( vCamera ) {

			vCamera.getWorldDirection( __direction );

			const pitch = Math.PI / 2 - __direction.angleTo( Object3D.DefaultUp );

			if ( pitch === this.lastPitch ) return;

			this.globe.rotateOnAxis( __xAxis, pitch - this.lastPitch );
			this.lastPitch = pitch;

			this.label.replaceString( String( Math.round( MathUtils.radToDeg( pitch ) ) + '\u00B0' ).padStart( 4, ' ' ) );

		};

	}();

	function AHIControl( hudObject, viewer ) {

		const container = viewer.container;
		const controls = viewer.getControls();

		const hr = hudObject.createHitRegion( hudObject.stdWidth * 2, hudObject.stdWidth * 2, handleEnter );
		const ballSize = hudObject.stdWidth - 10;
		var dragging = false;
		var centerY;
		var lastAngle;

		hr.style.right = hudObject.stdMargin * 3 + hudObject.stdWidth * 2 + 'px';
		hr.style.bottom = hudObject.stdMargin + 'px';

		container.appendChild( hr );

		function handleEnter ( event ) {

			if ( ! viewer.HUD ) return;

			const target = event.currentTarget;

			target.addEventListener( 'mouseleave', handleLeave );
			target.addEventListener( 'mousemove',  handleMouseMove );
			target.addEventListener( 'mousedown',  handleMouseDown );
			target.addEventListener( 'mouseup',    handleMouseUp );
			target.addEventListener( 'dblclick',   handleDblClick );

			// update center position (accounts for resizes)
			const bc = container.getBoundingClientRect();
			centerY = bc.top + hr.offsetTop + hudObject.stdWidth;

			hr.style.cursor = 'pointer';

		}

		function handleLeave ( event ) {

			const target = event.currentTarget;

			if ( dragging ) controls.end();

			target.removeEventListener( 'mouseleave', handleLeave );
			target.removeEventListener( 'mousemove',  handleMouseMove );
			target.removeEventListener( 'mousedown',  handleMouseDown );
			target.removeEventListener( 'mouseup',    handleMouseUp );
			target.removeEventListener( 'dblclick',   handleDblClick );

			hr.style.cursor = 'default';
			dragging = false;

		}

		function handleMouseDown ( event ) {

			event.stopPropagation();

			dragging = true;
			lastAngle = Math.atan( ( event.clientY - centerY ) / ballSize );

		}

		function handleMouseUp ( event ) {

			event.stopPropagation();
			controls.end();

			dragging = false;

		}

		function handleDblClick ( event ) {

			event.stopPropagation();

			if ( viewer.polarAngle < 0.0001 ) {

				viewer.polarAngle = Math.PI / 2;

			} else {

				viewer.polarAngle = 0;

			}

		}

		function handleMouseMove ( event ) {

			event.stopPropagation();
			event.preventDefault();

			if ( ! dragging ) return;

			const angle = Math.atan( ( event.clientY - centerY ) / ballSize );

			controls.rotateUp( lastAngle - angle );

			lastAngle = angle;

		}

		this.dispose = function () {

			container.removeChild( hr );

		};

	}

	function AngleScale ( hudObject, caption ) {

		const stdWidth  = hudObject.stdWidth;
		const stdMargin = hudObject.stdMargin;
		const materials = hudObject.ctx.materials;

		const pNormal = new Vector3( 1, 0, 0 );

		const geometry = new RingBufferGeometry( 1, 40, 36, 1, Math.PI, Math.PI );

		const hues = materials.colourCache.getColors( 'inclination' );
		const colors = [];

		const vertices = geometry.getAttribute( 'position' );
		const vertexCount = vertices.count;
		const ringColors = new Float32BufferAttribute( vertexCount * 3, 3 );

		const v3 = new Vector3();

		var i;

		for ( i = 0; i < vertexCount; i++ ) {

			v3.fromBufferAttribute( vertices, i ).normalize();

			const hueIndex = Math.floor( 127 * 2 * Math.asin( Math.abs( v3.dot( pNormal ) ) ) / Math.PI );

			colors.push( hues[ hueIndex ] );

		}

		geometry.setAttribute( 'color', ringColors.copyColorsArray( colors ) );

		hudObject.dropBuffers( geometry );

		Mesh.call( this, geometry, new MeshBasicMaterial( { color: 0xffffff, vertexColors: true } ) );

		this.translateY( 3 * ( stdWidth + stdMargin ) + stdMargin + 30 );
		this.translateX( - 40 - 5 );

		this.name = 'CV.AngleScale';

		const material = materials.getGlyphMaterial( hudObject.atlasSpec, 0 );
		const label = new GlyphString( caption, material, hudObject.ctx );

		label.translateX( - label.getWidth() / 2 );
		label.translateY( 5 );

		this.addStatic( label );

		this.visible = false;

		return this;

	}

	AngleScale.prototype = Object.create( Mesh.prototype );

	function Compass ( hudObject ) {

		const stdWidth  = hudObject.stdWidth;
		const stdMargin = hudObject.stdMargin;
		const cfg = hudObject.ctx.cfg;
		const materials = hudObject.ctx.materials;

		Group.call( this );

		this.name = 'CV.Compass';

		const cg1 = hudObject.getCommonRing();

		const c1 = new Mesh( cg1, materials.getBezelMaterial() );

		const cg2 = new RingBufferGeometry( stdWidth * 0.9, stdWidth, 4, 1, -Math.PI / 32 + Math.PI / 2, Math.PI / 16 );
		cg2.translate( 0, 0, 5 );

		hudObject.dropBuffers( cg2 );

		const c2 = new Mesh( cg2, new MeshBasicMaterial( { color: cfg.themeValue( 'hud.compass.top1' ) } ) );

		const rMesh = _makeRose();

		const rotaryGroup = new Group();

		rotaryGroup.addStatic( c1 );
		rotaryGroup.addStatic( c2 );
		rotaryGroup.addStatic( rMesh );

		this.add( rotaryGroup );
		this.rotaryGroup = rotaryGroup;

		const offset = stdWidth + stdMargin;

		this.translateX( -offset );
		this.translateY(  offset );

		this.lastRotation = 0;

		const material = materials.getGlyphMaterial( hudObject.atlasSpec, 0 );
		const label = new MutableGlyphString( '000\u00B0', material );

		label.translateX( - label.getWidth() / 2 );
		label.translateY( stdWidth + 5 );

		this.addStatic( label );

		this.label = label;

		return this;

		function _makeRose() {

			const geometry = new BufferGeometry();
			const material = new MeshLambertMaterial( { vertexColors: true, flatShading: true } );

			const mesh = new Mesh( geometry, material );

			const vertices = [];
			const colours = [];

			_makeRose2( cfg.themeColor( 'hud.compass.bottom1' ),cfg.themeColor( 'hud.compass.bottom2' ), Math.PI / 4 );
			_makeRose2( cfg.themeColor( 'hud.compass.top1' ), cfg.themeColor( 'hud.compass.top2' ), 0 );

			const positions = new Float32BufferAttribute( vertices.length, 3 );
			const colors = new Float32BufferAttribute( vertices.length * 3, 3 );

			geometry.setAttribute( 'position', positions.copyArray( vertices ) );
			geometry.setAttribute( 'color', colors.copyColorsArray( colours ) );

			geometry.computeVertexNormals();

			return mesh;

			function _makeRose2( color1, color2, offset ) {

				const radius = stdWidth * 0.9;
				const innerR = radius * 0.2;

				var i;
				const xlv = Math.PI / 4;
				const xc = Math.PI / 2;

				for ( i = 0; i < 4; i++ ) {

					const a = i * Math.PI / 2 + offset;

					vertices.push( Math.sin( a )* radius, Math.cos( a ) * radius, 0 );
					vertices.push( 0, 0, 2 );
					vertices.push( Math.sin( a + xlv ) * innerR, Math.cos( a + xlv ) * innerR, 0 );

					colours.push( color1, color1, color1 );

					vertices.push( Math.sin( a + xlv ) * innerR, Math.cos( a + xlv ) * innerR, 0 );
					vertices.push( 0, 0, 2 );
					vertices.push( Math.sin( a + xc )* radius, Math.cos( a + xc ) * radius, 0 );

					colours.push( color2, color2, color2 );

				}

			}

		}

	}

	Compass.prototype = Object.create( Group.prototype );

	Compass.prototype.set = function () {

		const __direction = new Vector3();
		const __negativeZAxis = new Vector3( 0, 0, -1 );
		const __e = new Euler();

		return function set ( vCamera ) {

			var a;

			vCamera.getWorldDirection( __direction );

			if ( Math.abs( __direction.z ) < 0.999 ) {

				a = Math.atan2( - __direction.x, __direction.y );

			} else {

				__e.setFromQuaternion( vCamera.quaternion );
				a = __e.z;

			}

			if ( a === this.lastRotation ) return;

			if ( a < 0 ) a = Math.PI * 2 + a;

			var degrees = Math.round( MathUtils.radToDeg( a ) );

			if ( degrees === 360 ) degrees = 0;

			const res = degrees.toString().padStart( 3, '0' ) + '\u00B0'; // unicode degree symbol

			this.label.replaceString( res );

			this.rotaryGroup.rotateOnAxis( __negativeZAxis, a - this.lastRotation );

			this.lastRotation = a;
		};

	}();

	function CompassControl( hudObject, viewer ) {

		const container = viewer.container;
		const controls = viewer.getControls();

		const point = new Vector2();
		const center = new Vector2();

		var dragging = false;
		var startAngle = 0;

		const hr = hudObject.createHitRegion( hudObject.stdWidth * 2, hudObject.stdWidth * 2, handleEnter );

		hr.style.right = hudObject.stdMargin + 'px';
		hr.style.bottom = hudObject.stdMargin + 'px';

		container.appendChild( hr );

		function handleEnter ( event ) {

			if ( ! viewer.HUD ) return;

			const target = event.currentTarget;

			target.addEventListener( 'mouseleave', handleLeave );
			target.addEventListener( 'mousemove',  handleMouseMove );
			target.addEventListener( 'mousedown',  handleMouseDown );
			target.addEventListener( 'mouseup',    handleMouseUp );
			target.addEventListener( 'dblclick',   handleDblClick );

			// update center position (accounts for resizes)
			const bc = container.getBoundingClientRect();
			center.set( bc.left + hr.offsetLeft + hudObject.stdWidth, bc.top + hr.offsetTop + hudObject.stdWidth );
			hr.style.cursor = 'pointer';

		}

		function handleLeave ( event ) {

			const target = event.currentTarget;

			if ( dragging ) controls.end();

			target.removeEventListener( 'mouseleave', handleLeave );
			target.removeEventListener( 'mousemove',  handleMouseMove );
			target.removeEventListener( 'mousedown',  handleMouseDown );
			target.removeEventListener( 'mouseup',    handleMouseUp );
			target.removeEventListener( 'dblclick',   handleDblClick );

			hr.style.cursor = 'default';
			dragging = false;

		}

		function handleMouseDown ( event ) {

			event.stopPropagation();

			dragging = true;
			point.set( event.clientX, event.clientY ).sub( center );
			startAngle = point.angle();

		}

		function handleMouseUp ( event ) {

			event.stopPropagation();

			controls.end();

			dragging = false;

		}

		function handleDblClick ( event ) {

			event.stopPropagation();

			// select cardinal point from quadrant of control clicked on

			if ( point.x > point.y ) {

				if ( point.x < -point.y ) {

					viewer.azimuthAngle = 0;

				} else {

					viewer.azimuthAngle = Math.PI / 2;

				}

			} else {

				if ( point.x > -point.y ) {

					viewer.azimuthAngle = Math.PI;

				} else {

					viewer.azimuthAngle = 3 * Math.PI / 2;

				}

			}

		}

		function handleMouseMove ( event ) {

			event.stopPropagation();
			event.preventDefault();

			if ( ! dragging ) return;

			point.set( event.clientX, event.clientY ).sub( center );

			const angle = point.angle();

			controls.rotateLeft( startAngle - angle );

			startAngle = angle;

		}

		this.dispose = function () {

			container.removeChild( hr );

		};

	}

	function Scale( hudObject, container, geometry, material ) {

		const materials = hudObject.ctx.materials;
		const width  = container.clientWidth;
		const height = container.clientHeight;

		const stdWidth  = hudObject.stdWidth;
		const stdMargin = hudObject.stdMargin;

		const barOffset = 3 * ( stdWidth + stdMargin );

		const barHeight = ( height - barOffset ) / 2;
		const barWidth  = stdWidth / 2;

		this.ctx = hudObject.ctx;
		this.barHeight = barHeight;
		this.barWidth = barWidth;
		this.barOffset = barOffset;

		this.offsetX = -barWidth / 2 - 5;
		this.offsetY = barHeight / 2;

		Group.call( this );

		// position on left side of container
		this.translateX(  width / 2  - barWidth / 2  - stdMargin );
		this.translateY( -height / 2 + barHeight / 2 + barOffset );

		this.scaleBar = new Mesh( geometry, material );
		this.scaleBar.name = 'scale bar';

		this.textMaterial = materials.getGlyphMaterial( hudObject.atlasSpec, 0 );

		this.add( this.scaleBar );

		this.min = null;
		this.max = null;
		this.caption = null;

	}

	Scale.prototype = Object.create( Group.prototype );

	Scale.prototype.setRange = function ( min, max, caption ) {

		const offsetX = this.offsetX;
		const offsetY = this.offsetY;

		const material = this.textMaterial;

		if ( min !== this.min || max !== this.max ) {

			var i;

			for ( i = this.children.length; i--; ) {

				const obj = this.children[ i ];

				if ( obj.isRange ) this.remove( obj );

			}

			const topLabel = new GlyphString( Math.round( max ) + '\u202fm', material, this.ctx );
			const bottomLabel = new GlyphString( Math.round( min ) + '\u202fm', material, this.ctx );

			topLabel.translateX( offsetX - topLabel.getWidth() );
			bottomLabel.translateX( offsetX - bottomLabel.getWidth() );

			topLabel.translateY( offsetY - topLabel.getHeight() );
			bottomLabel.translateY( -offsetY );

			topLabel.isRange = true;
			bottomLabel.isRange = true;

			this.addStatic( topLabel );
			this.addStatic( bottomLabel );

			this.min = min;
			this.max = max;

		}

		this.setCaption( caption );

		return this;

	};

	Scale.prototype.setCaption = function ( text ) {

		var caption = this.caption;

		if ( caption !== null ) {

			// already have correct caption
			if ( caption.name === text ) return this;

			this.remove( caption );

		}

		caption = new GlyphString( text, this.textMaterial, this.ctx );
		caption.translateX( this.barWidth / 2 - caption.getWidth() );
		caption.translateY( this.offsetY + this.barWidth / 2 );

		this.addStatic( caption );
		this.caption = caption;

		return this;

	};

	Scale.prototype.dispose = function () {

		this.traverse( function _dispose ( obj ) {

			const geometry = obj.geometry;

			if ( geometry !== undefined ) geometry.dispose();

		} );

	};

	function CursorScale ( hudObject, container ) {

		const cfg = hudObject.ctx.cfg;
		const materials = hudObject.ctx.materials;
		const geometry = new PlaneBufferGeometry();

		Scale.call( this, hudObject, container, geometry, new MeshBasicMaterial( { color: 0x676767 } ) );

		this.name = 'CV.CursorScale';

		const barWidth = this.barWidth;
		const barHeight = this.barHeight;

		geometry.scale( barWidth, barHeight, 1 );

		// make cursor line

		const cursorGeometry = new BufferGeometry();

		const vertices = [
			barWidth / 2, -barHeight / 2, 10,
			-barWidth / 2, -barHeight / 2, 10
		];

		const positions = new Float32BufferAttribute( vertices, 3 );

		cursorGeometry.setAttribute( 'position', positions );

		const cursor = new Line( cursorGeometry, new LineBasicMaterial( { color: cfg.themeColor( 'hud.cursor' ) } ) );

		const atlasSpec = {
			color: cfg.themeColorCSS( 'hud.cursor' ),
			background: '#444444',
			font: 'bold helvetica,sans-serif'
		};

		const material = materials.getGlyphMaterial( atlasSpec, 0 );

		const cursorLabel = new MutableGlyphString( '      ', material );

		cursorLabel.translateY( - barHeight / 2 - cursorLabel.getHeight() / 2 );

		this.addStatic( cursor );
		cursor.addStatic( cursorLabel );

		this.cursor = cursor;
		this.cursorLabel = cursorLabel;

		return this;

	}

	CursorScale.prototype = Object.create( Scale.prototype );

	CursorScale.prototype.setCursor = function ( scaledValue, displayValue ) {

		const cursor = this.cursor;
		const cursorLabel = this.cursorLabel;

		cursor.position.setY( this.barHeight * scaledValue );
		cursor.updateMatrix();

		cursorLabel.replaceString( String( displayValue + '\u202fm' ).padStart( 6, ' ') );
		cursorLabel.position.setX( this.offsetX - cursorLabel.getWidth() );

		cursorLabel.updateMatrix();

		return this;

	};

	function CursorControl( hudObject, viewer, cursorScale ) {

		const container = viewer.container;

		const hr = hudObject.createHitRegion( cursorScale.barWidth, cursorScale.barHeight, handleEnter );

		var dragging = false;
		var barTop;

		hr.style.right = hudObject.stdMargin + 'px';
		hr.style.bottom = cursorScale.barOffset + 'px';

		container.appendChild( hr );

		this.hr = hr;

		function handleEnter ( event ) {

			if ( ! viewer.HUD ) return;
			if ( viewer.shadingMode !== SHADING_CURSOR && viewer.shadingMode !== SHADING_DEPTH_CURSOR ) return;

			const target = event.currentTarget;

			target.addEventListener( 'mouseleave', handleLeave );
			target.addEventListener( 'mousemove',  handleMouseMove );
			target.addEventListener( 'mousedown',  handleMouseDown );
			target.addEventListener( 'mouseup',    handleMouseUp );

			// update center position (accounts for resizes)
			const bc = container.getBoundingClientRect();

			barTop = bc.top + hr.offsetTop;

			hr.style.cursor = 'pointer';

		}

		function setCursor( clientY ) {

			const heightFraction = ( cursorScale.barHeight - clientY + barTop ) / cursorScale.barHeight;
			const range = viewer.maxHeight - viewer.minHeight;

			// handle direction of scale and range

			if ( viewer.shadingMode === SHADING_DEPTH_CURSOR ) {

				viewer.cursorHeight = range - range * heightFraction;

			} else {

				viewer.cursorHeight = range * heightFraction - range / 2;

			}

		}

		function handleLeave ( event ) {

			const target = event.currentTarget;

			target.removeEventListener( 'mouseleave', handleLeave );
			target.removeEventListener( 'mousemove',  handleMouseMove );
			target.removeEventListener( 'mousedown',  handleMouseDown );
			target.removeEventListener( 'mouseup',    handleMouseUp );

			hr.style.cursor = 'default';
			dragging = false;

		}

		function handleMouseDown ( event ) {

			event.stopPropagation();

			setCursor( event.clientY );
			dragging = true;

		}

		function handleMouseUp ( event ) {

			event.stopPropagation();

			dragging = false;

		}

		function handleMouseMove ( event ) {

			event.stopPropagation();
			event.preventDefault();

			if ( ! dragging ) return;

			setCursor( event.clientY );

		}

	}

	CursorControl.prototype.dispose = function () {

		const hr = this.hr;
		hr.parentNode.removeChild( hr );

	};

	function LinearScale ( hudObject, container ) {

		const materials = hudObject.ctx.materials;
		const geometry = new PlaneBufferGeometry();
		const material = materials.getScaleMaterial();

		Scale.call( this, hudObject, container, geometry, material );

		this.name = 'CV.LinearScale';

		geometry.rotateZ( - Math.PI / 2 ); // rotate to use default UV values
		geometry.scale( this.barWidth, this.barHeight, 1 );

		return this;

	}

	LinearScale.prototype = Object.create( Scale.prototype );

	function ProgressDial ( hudObject, addText, ring, viewer ) {

		const cfg = hudObject.ctx.cfg;
		const materials = hudObject.ctx.materials;
		const stdWidth  = hudObject.stdWidth;
		const stdMargin = hudObject.stdMargin;

		const offset = stdWidth + stdMargin;

		const gap = ring === 0 ? 0 : 1;
		const segments = 50;
		const geometry = new RingBufferGeometry( stdWidth * ( 0.9 - ring * 0.1 ), stdWidth * ( 1 - ring * 0.1 ) - gap, segments );

		const colors = new Float32BufferAttribute( ( segments + 1) * 6, 3 );

		geometry.setAttribute( 'color', colors );

		hudObject.dropBuffers( geometry );

		this.backgroundColor = cfg.themeColor( 'hud.progressBackground' );
		this.setColor = cfg.themeColor( 'hud.progress' );
		this.viewer = viewer;

		Mesh.call( this, geometry, materials.getPlainMaterial() );

		this.name = 'CV.ProgressDial';

		this.translateX( -offset * 5 );
		this.translateY(  offset );

		this.rotateOnAxis( Object3D.DefaultUp, Math.PI / 2 );

		this.visible = false;
		this.isVisible = true;

		this.colorRange( 0 );

		if ( addText ) {

			var glyphMaterial = materials.getGlyphMaterial( hudObject.atlasSpec, 0 );

			const pcent = new MutableGlyphString( '----', glyphMaterial );

			pcent.translateY( pcent.getWidth() / 2 );
			pcent.translateX( -10 );

			this.add( pcent );
			this.pcent = pcent;

		} else {

			this.pcent = null;

		}

		return this;

	}

	ProgressDial.prototype = Object.create( Mesh.prototype );

	ProgressDial.prototype.colorRange = function ( range ) {

		const colors = this.geometry.getAttribute( 'color' );
		const segmentMax = 50 - Math.round( range / 2 );
		const cc = colors.count;
		const c1 = this.setColor;
		const c2 = this.backgroundColor;

		var i;

		for ( i = cc / 2; i >= 0; i-- ) {

			const c =  i > segmentMax ? c1 : c2;

			c.toArray( colors.array, i * 3 );
			c.toArray( colors.array, ( i + 51 ) * 3 );

		}

		colors.needsUpdate = true;

	};

	ProgressDial.prototype.set = function ( progress ) {

		if ( progress === this.progress ) return;

		this.progress = progress;

		const l = Math.floor( Math.min( 100, Math.round( progress ) ) / 2 ) * 2;
		const pcent = this.pcent;

		this.colorRange( l );

		if ( pcent !== null ) {

			var pcentValue = Math.round( progress ) + '%';

			pcent.replaceString( pcentValue.padStart( 4, ' ' ) );
			pcent.translateY( pcent.getWidth() / 2 - pcent.position.y );

		}

		this.viewer.renderView();

	};

	ProgressDial.prototype.start = function () {

		this.colorRange( 0 );

		this.progress = 0;
		this.visible = true;

		if ( this.pcent !== null ) this.pcent.replaceString( '  0%' );

		this.viewer.renderView();

	};

	ProgressDial.prototype.end = function () {

		const self = this;

		setTimeout( function endProgress () { self.visible = false; self.viewer.renderView(); }, 500 );

	};

	ProgressDial.prototype.setVisibility = function ( visibility ) {

		this.isVisible = visibility;
		this.visible = ( this.visible && visibility );

	};

	ProgressDial.prototype.watch = function ( obj ) {

		obj.addEventListener( 'progress', this.handleProgess.bind( this ) );

	};

	ProgressDial.prototype.handleProgess = function ( event ) {

		switch ( event.name ) {

		case 'start':

			this.start();
			break;

		case 'set':

			this.set( event.progress );
			break;

		case 'end':

			this.end();
			break;

		}

	};

	function BarGeometry ( ctx, length, height, divisions ) {

		BufferGeometry.call( this );

		const cfg = ctx.cfg;

		const c1 = cfg.themeColor( 'hud.scale.bar1' );
		const c2 = cfg.themeColor( 'hud.scale.bar2' );

		const vertices = [];
		const colors = [];

		_makeBar( divisions * 10, 0 );
		_makeBar( divisions, height + 1 );

		const colorBuffer = new Float32BufferAttribute( colors.length * 3, 3 );

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'color', colorBuffer.copyColorsArray( colors ) );

		function _makeBar( divisions, offset ) {

			const dWidth = length / divisions;

			var i;

			for ( i = 0; i < divisions; i++ ) {

				const x1 = i * dWidth;
				const x2 = x1 + dWidth;
				const y1 = offset;
				const y2 = y1 + height;

				vertices.push(
					x1, y1, 0,
					x2, y2, 0,
					x1, y2, 0,
					x2, y2, 0,
					x1, y1, 0,
					x2, y1, 0
				);

				const c = ( i % 2 ) ? c1 : c2;
				colors.push( c, c, c, c, c, c );

			}

		}

	}

	BarGeometry.prototype = Object.create( BufferGeometry.prototype );

	function ScaleBar ( hudObject, container, hScale, rightMargin ) {

		const leftMargin = 10;
		const materials = hudObject.ctx.materials;

		Group.call( this );

		this.name = 'CV.ScaleBar';

		this.hScale        = hScale;
		this.scaleBars     = [];
		this.currentLength = 0;
		this.wScale = container.clientHeight / container.clientWidth;
		this.hudObject = hudObject;

		this.position.set( -container.clientWidth / 2 + 45, -container.clientHeight / 2 + leftMargin, 0 );
		this.scaleMax = container.clientWidth - ( 40 + leftMargin + rightMargin );

		const material = materials.getGlyphMaterial( hudObject.atlasSpec, 0 );
		const label = new MutableGlyphString( '--------', material );

		label.translateX( 0 );
		label.translateY( 10 );

		this.add( label );

		this.label = label;

		return this;

	}

	ScaleBar.prototype = Object.create( Group.prototype );

	ScaleBar.prototype.setScale = function ( scale ) {

		const scaleBars = this.scaleBars;
		const self = this;
		const ctx = this.hudObject.ctx;

		const maxVisible = this.scaleMax / ( scale * this.hScale );

		var exponent = Math.ceil( Math.log( maxVisible ) / Math.LN10 ) - 1;

		const rMax   = Math.pow( 10, exponent );
		const maxInc = maxVisible / rMax;

		var legendText;
		var length = 0;

		if ( maxInc < 2 ) {

			length = 10;
			exponent = exponent - 1;

		} else if ( maxInc < 5 ) {

			length = 2;

		} else {

			length = 5;

		}

		if ( exponent >= 3 ) {

			legendText = length * Math.pow( 10, exponent - 3) + '\u202fkm';

		} else {

			legendText = length * Math.pow( 10, exponent ) + '\u202fm';

		}

		scale = scale * Math.pow( 10, exponent );

		if ( this.currentLength !== length ) {

			if ( ! scaleBars[ length ] ) {

				const bar = _makeScaleBar( length );

				scaleBars[ length ] = bar;
				this.add( bar.mesh );

			}

			if ( this.currentLength > 0 ) {

				scaleBars[ this.currentLength ].mesh.visible = false;

			}

			scaleBars[ length ].mesh.visible = this.visible;
			this.currentLength = length;

		}

		scaleBars[ length ].mesh.scale.x = scale;

		const label = this.label;

		label.replaceString( legendText.padStart( 8, ' ' ) );

		const w = label.getWidth();

		label.translateX( scale * scaleBars[ length ].topRight - label.position.x - w );

		return this;

		function _makeScaleBar ( length ) {

			const bar = new BarGeometry( ctx, length * self.hScale, 4, length );

			bar.computeBoundingBox();

			return {
				mesh: new Mesh( bar, ctx.materials.getPlainMaterial() ),
				topRight: bar.boundingBox.max.x
			};

		}

	};

	function onUploadDropBuffer$1() {

		// call back from BufferAttribute to drop JS buffers after data has been transfered to GPU
		this.array = null;

	}

	function HudObject ( ctx ) {

		const cfg = ctx.cfg;
		this.stdWidth = cfg.themeValue( 'hud.widgetSize' );

		this.atlasSpec = {
			color: cfg.themeColorCSS( 'hud.text' ),
			font: cfg.themeValue( 'hud.font' )
		};

		this.commonRing = null;
		this.ctx = ctx;

	}

	Object.assign( HudObject.prototype, {

		stdMargin: 5,

		createHitRegion: function ( width, height, onEnter ) {

			const div = document.createElement( 'div' );

			div.style.width = width + 'px';
			div.style.height = height + 'px';
			div.style.position = 'absolute';

			div.setAttribute( 'draggable', 'false' );
			div.addEventListener( 'dragstart', function ( e ) {e.preventDefault(); } );

			div.addEventListener( 'mouseenter', onEnter );

			return div;

		},

		dropBuffers: function ( geometry ) {

			geometry.getAttribute( 'position' ).onUpload( onUploadDropBuffer$1 );
			geometry.getAttribute( 'normal' ).onUpload( onUploadDropBuffer$1 );
			geometry.getAttribute( 'uv' ).onUpload( onUploadDropBuffer$1 );

			if ( geometry.index !== null ) geometry.index.onUpload( onUploadDropBuffer$1 );

		},

		getCommonRing: function () {

			var commonRing = this.commonRing;

			if ( commonRing === null ) {

				commonRing = new CylinderBufferGeometry( this.stdWidth * 0.90, this.stdWidth, 3, 32, 1, true );
				commonRing.rotateX( Math.PI / 2 );

				this.dropBuffers( commonRing );
				this.commonRing = commonRing;
			}

			return commonRing;

		},

	} );

	// THREE objects

	function HUD ( viewer, renderer ) {

		const self = this;
		const cfg = viewer.ctx.cfg;

		const container = viewer.container;

		const hHeight = container.clientHeight / 2;
		const hWidth  = container.clientWidth / 2;

		var hScale = 0;

		var linearScale = null;
		var cursorScale = null;
		var scaleBar    = null;
		var cursorControl = null;

		var ahi;
		var compass;
		var angleScale;

		// viewer state

		var controls;
		var isVisible = true;
		var caveLoaded = false;

		// create GL scene and camera for overlay
		const camera = new OrthographicCamera( -hWidth, hWidth, hHeight, -hHeight, 1, 1000 );
		camera.position.z = 600;

		const scene = new Scene();
		scene.name = 'HUD';

		// group to simplyfy resize handling
		const attitudeGroup = new Group();
		attitudeGroup.position.set( hWidth, -hHeight, 0 );

		scene.addStatic( attitudeGroup );

		var hudObject = new HudObject( viewer.ctx );

		const aLight = new AmbientLight( 0x888888 );
		const dLight = new DirectionalLight( 0xFFFFFF );
		dLight.position.set( -1, 1, 1 );

		scene.addStatic( aLight );
		scene.addStatic( dLight );

		const progressDials = [
			new ProgressDial( hudObject, true, 0, viewer ),
			new ProgressDial( hudObject, false, 1, viewer )
		];

		const progressDial = progressDials [ 0 ];

		newAttitudeGroup();

		attitudeGroup.addStatic( progressDials[ 0 ] );
		attitudeGroup.addStatic( progressDials[ 1 ] );

		viewer.addEventListener( 'newCave', caveChanged );
		viewer.addEventListener( 'change', viewChanged );
		viewer.addEventListener( 'resized', resize );

		cfg.addEventListener( 'change', cfgChanged );
		cfg.addEventListener( 'colors', cfgColorChanged );

		controls = viewer.getControls();

		const compassControl = new CompassControl( hudObject, viewer );
		const ahiControl = new AHIControl( hudObject, viewer );

		function i18n ( text ) {

			const tr = cfg.i18n( 'hud.' + text );

			return ( tr === undefined ) ? text : tr;

		}

		this.setVisibility = function ( visible ) {

			compass.visible = visible;
			ahi.visible = visible;
			progressDial.setVisibility( visible );

			if ( scaleBar ) scaleBar.visible = visible;

			isVisible = visible;

			// reset correct disposition of colour keys etc.
			if ( linearScale ) {

				if ( visible ) {

					viewChanged ( { type: 'change', name: 'shadingMode' } );

				} else {

					linearScale.visible = false;
					cursorScale.visible = false;
					angleScale.visible = false;

				}

			}

			viewer.renderView();

		};

		this.getVisibility = function () {

			return isVisible;

		};

		this.getProgressDial = function ( ring ) {

			return progressDials[ ring ];

		};

		this.setScale = function ( scale ) {

			hScale = scale;

		};

		function resize () {

			const container = viewer.container;

			const hWidth  = container.clientWidth / 2;
			const hHeight = container.clientHeight / 2;

			// adjust cameras to new aspect ratio etc.
			camera.left   = -hWidth;
			camera.right  =  hWidth;
			camera.top    =  hHeight;
			camera.bottom = -hHeight;

			camera.updateProjectionMatrix();

			attitudeGroup.position.set( hWidth, -hHeight, 0 );
			attitudeGroup.updateMatrix();

			newScales();

		}

		this.renderHUD = function () {

			// update HUD components

			const currentCamera = controls.cameraManager.activeCamera;

			compass.set( currentCamera );
			ahi.set( currentCamera );

			updateScaleBar( currentCamera );

			// render on screen
			renderer.clearDepth();
			renderer.render( scene, camera );

		};

		function cfgColorChanged ( /* event */ ) {

			// refresh common config helper
			hudObject = new HudObject( viewer.ctx );

			newAttitudeGroup();
			caveChanged();
		}

		function cfgChanged ( /* event */ ) {

			// only change controls when a cave has been loaded already
			// prevents flicker when racing with i18n resource loading
			if ( caveLoaded ) caveChanged();

		}

		function caveChanged ( /* event */ ) {

			caveLoaded = true;

			newScales();

			viewChanged ( { type: 'change', name: 'shadingMode' } );

		}

		function newAttitudeGroup() {

			if ( ahi ) attitudeGroup.remove( ahi );
			if ( compass ) attitudeGroup.remove( compass );
			if ( angleScale ) attitudeGroup.remove( angleScale );

			ahi = new AHI( hudObject );
			compass = new Compass( hudObject );
			angleScale = new AngleScale( hudObject, i18n( 'inclination' ) );

			attitudeGroup.addStatic( ahi );
			attitudeGroup.addStatic( compass );
			attitudeGroup.addStatic( angleScale );

		}

		function newScales () {

			const container = viewer.container;
			const hasLegs = viewer.minHeight !== Infinity && viewer.maxHeight !== -Infinity;

			if ( linearScale ) {

				linearScale.dispose();
				scene.remove( linearScale );

			}

			if ( hasLegs ) {

				linearScale = new LinearScale( hudObject, container );
				scene.addStatic( linearScale );

			}

			if ( cursorScale ) {

				cursorScale.dispose();
				scene.remove( cursorScale );

			}

			if ( hasLegs ) {

				cursorScale = new CursorScale( hudObject, container );

				if ( cursorControl ) cursorControl.dispose();

				cursorControl = new CursorControl( hudObject, viewer, cursorScale );

				scene.addStatic( cursorScale );

			}

			if ( scaleBar ) {

				scene.remove( scaleBar );
				scaleBar = null;

			}

			updateScaleBar( controls.object );

			self.setVisibility( isVisible );

		}

		function viewChanged ( event ) {

			if ( event.name !== 'shadingMode' || ! isVisible || ! caveLoaded ) return;

			// hide all - and only make required elements visible

			var useAngleScale = false;
			var useLinearScale = false;
			var useCursorScale = false;

			switch ( viewer.shadingMode ) {

			case SHADING_HEIGHT:

				useLinearScale = true;

				linearScale.setRange( viewer.minHeight, viewer.maxHeight, i18n( 'height' ) );

				break;

			case SHADING_DEPTH:

				useLinearScale = true;

				linearScale.setRange( viewer.maxHeight - viewer.minHeight, 0, i18n( 'depth' ) );

				break;

			case SHADING_DISTANCE:

				useLinearScale = true;

				linearScale.setRange( 0, viewer.maxDistance, i18n( 'distance' ) );

				break;

			case SHADING_CURSOR:

				useCursorScale = true;

				cursorScale.setRange( viewer.minHeight, viewer.maxHeight, i18n( 'height' ) );

				cursorChanged();

				break;

			case SHADING_DEPTH_CURSOR:

				useCursorScale = true;

				cursorScale.setRange( viewer.maxHeight - viewer.minHeight, 0, i18n( 'depth' ) );

				cursorChanged();

				break;

			case SHADING_LENGTH:

				useLinearScale = true;

				linearScale.setRange( viewer.minLegLength, viewer.maxLegLength, i18n( 'leg_length' ) );

				break;

			case SHADING_INCLINATION:

				useAngleScale = true;

				break;

			}

			angleScale.visible = useAngleScale;
			linearScale.visible= useLinearScale;
			cursorScale.visible = useCursorScale;

			if ( useCursorScale ) {

				viewer.addEventListener( 'cursorChange', cursorChanged );

			} else {

				viewer.removeEventListener( 'cursorChange', cursorChanged );

			}

			viewer.renderView();

		}

		function cursorChanged ( /* event */ ) {

			const cursorHeight = viewer.cursorHeight;
			const range = viewer.maxHeight - viewer.minHeight;

			var scaledHeight = 0;
			var realHeight = 0;

			if ( viewer.shadingMode === SHADING_CURSOR ) {

				scaledHeight = ( viewer.cursorHeight + range / 2 ) / range;
				realHeight = cursorHeight + range / 2 + viewer.minHeight;

			} else {

				scaledHeight = 1 - cursorHeight / range;
				realHeight = cursorHeight;

			}

			scaledHeight = Math.max( Math.min( scaledHeight, 1 ), 0 );

			cursorScale.setCursor( scaledHeight, Math.round( realHeight ) );

		}

		function updateScaleBar ( camera ) {

			if ( camera instanceof OrthographicCamera ) {

				if ( scaleBar === null ) {

					scaleBar = new ScaleBar( hudObject, viewer.container, hScale, ( hudObject.stdWidth + hudObject.stdMargin ) * 4 );
					scene.addStatic( scaleBar );

				}

				scaleBar.visible = isVisible;
				scaleBar.setScale( camera.zoom );

			} else {

				if ( scaleBar !== null && scaleBar.visible ) scaleBar.visible = false;

			}

		}

		this.dispose = function () {

			ahiControl.dispose();
			compassControl.dispose();
			if ( cursorControl ) cursorControl.dispose();

		};

	}

	var anaglyphVertexShader = "varying vec2 vUv;\nvoid main() {\n\tvUv = vec2( uv.x, uv.y );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var anaglyphFragmentShader = "uniform sampler2D mapLeft;\nuniform sampler2D mapRight;\nvarying vec2 vUv;\nuniform mat3 colorMatrixLeft;\nuniform mat3 colorMatrixRight;\nfloat lin( float c ) {\n\treturn c <= 0.04045 ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec4 lin( vec4 c ) {\n\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );\n}\nfloat dev( float c ) {\n\treturn c <= 0.0031308 ? c * 12.92 : pow( c, 0.41666 ) * 1.055 - 0.055;\n}\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 colorL = lin( texture2D( mapLeft, uv ) );\n\tvec4 colorR = lin( texture2D( mapRight, uv ) );\n\tvec3 color = clamp(\n\t\t\tcolorMatrixLeft * colorL.rgb +\n\t\t\tcolorMatrixRight * colorR.rgb, 0., 1.\n\t);\n\tgl_FragColor = vec4(\n\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),\n\t\t\tmax( colorL.a, colorR.a )\n\t);\n}";

	var cursorVertexShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying float height;\nvarying float fogDepth;\nvoid main() {\n#ifdef SURFACE\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n#else\n\tvColor = color;\n#endif\n\theight = position.z;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tfogDepth = -mvPosition.z;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var cursorFragmentShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform float cursor;\nuniform float cursorWidth;\nuniform vec3 baseColor;\nuniform vec3 cursorColor;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nvarying float height;\nvarying vec3 vColor;\nvarying float fogDepth;\nvoid main() {\n\tfloat delta = abs( height - cursor );\n\tfloat ss = smoothstep( 0.0, cursorWidth, cursorWidth - delta );\n\tif ( delta < cursorWidth * 0.05 ) {\n\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t} else {\n\t\tgl_FragColor = vec4( mix( baseColor, cursorColor, ss ), 1.0 ) * vec4( vColor, 1.0 );\n\t}\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}";

	var depthMapVertexShader = "uniform float minZ;\nuniform float scaleZ;\nvarying float vHeight;\nvoid main() {\n\tvHeight = ( position.z - minZ ) * scaleZ;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var depthMapFragmentShader = "const float PackUpscale = 256. / 255.;const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packFloatToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\n\treturn r * PackUpscale;\n}\nvarying float vHeight;\nvoid main() {\n\tgl_FragColor = packFloatToRGBA( vHeight );\n}";

	var depthVertexShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nfloat unpackRGBAToFloat( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nuniform vec3 modelMin;\nuniform float scaleX;\nuniform float scaleY;\nuniform float rangeZ;\nuniform float depthScale;\nuniform sampler2D depthMap;\nuniform float datumShift;\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying float vDepth;\nvarying float fogDepth;\nvoid main() {\n#ifdef SURFACE\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n#else\n\tvColor = color;\n#endif\n\tvec2 terrainCoords = vec2( ( position.x - modelMin.x ) * scaleX, ( position.y - modelMin.y ) * scaleY );\n\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, terrainCoords ) );\n\tterrainHeight = terrainHeight * rangeZ + modelMin.z + datumShift;\n\tvDepth = ( terrainHeight - position.z ) * depthScale;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tfogDepth = -mvPosition.z;\n\tgl_Position = projectionMatrix * mvPosition;\n}";

	var depthFragmentShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform sampler2D cmap;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nvarying float vDepth;\nvarying vec3 vColor;\nvarying float fogDepth;\nvoid main() {\n\tgl_FragColor = texture2D( cmap, vec2( vDepth, 1.0 ) ) * vec4( vColor, 1.0 );\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}";

	var depthCursorVertexShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nfloat unpackRGBAToFloat( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nuniform vec3 modelMin;\nuniform float scaleX;\nuniform float scaleY;\nuniform float rangeZ;\nuniform sampler2D depthMap;\nuniform float datumShift;\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying float vDepth;\nvarying float fogDepth;\nvoid main() {\n#ifdef SURFACE\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n#else\n\tvColor = color;\n#endif\n\tvec2 terrainCoords = vec2( ( position.x - modelMin.x ) * scaleX, ( position.y - modelMin.y ) * scaleY );\n\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, terrainCoords ) );\n\tvDepth = terrainHeight * rangeZ + datumShift + modelMin.z - position.z;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tfogDepth = -mvPosition.z;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var depthCursorFragmentShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform float cursor;\nuniform float cursorWidth;\nuniform vec3 baseColor;\nuniform vec3 cursorColor;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nvarying float vDepth;\nvarying vec3 vColor;\nvarying float fogDepth;\nvoid main() {\n\tfloat delta = abs( vDepth - cursor );\n\tfloat ss = smoothstep( 0.0, cursorWidth, cursorWidth - delta );\n\tif ( delta < cursorWidth * 0.05 ) {\n\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t} else {\n\t\tgl_FragColor = vec4( mix( baseColor, cursorColor, ss ), 1.0 ) * vec4( vColor, 1.0 );\n\t}\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}";

	var glyphVertexShader = "\nuniform float cellScale;\nuniform vec2 scale;\nuniform mat2 rotate;\nattribute vec2 instanceUvs;\nattribute float instanceOffsets;\nattribute float instanceWidths;\nvarying vec2 vUv;\nvarying float fogDepth;\nvoid main() {\n\tvUv = instanceUvs + vec2( position.x * cellScale * instanceWidths, position.y * cellScale );\n\tvec2 newPosition = vec2( position.x * instanceWidths, position.y );\n\tnewPosition.x += instanceOffsets;\n\tnewPosition = rotate * newPosition;\n\tvec4 offset = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tnewPosition *= scale;\n\tnewPosition.xy *= offset.w;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tfogDepth = -mvPosition.z;\n\tgl_Position = vec4( newPosition, 0.0, 0.0 ) + offset;\n}";

	var glyphFragmentShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform sampler2D atlas;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nvarying float fogDepth;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( atlas, vUv );\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, 0.0 ), fogFactor );\n\t}\n}";

	var heightVertexShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform sampler2D cmap;\nuniform float minZ;\nuniform float scaleZ;\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying float zMap;\nvarying float fogDepth;\nvarying vec3 vMvPosition;\nvoid main() {\n#ifdef SURFACE\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n#else\n\tvColor = color;\n#endif\n\tzMap = ( position.z - minZ ) * scaleZ;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tvMvPosition = mvPosition.xyz;\n\tfogDepth = -mvPosition.z;\n\tgl_Position = projectionMatrix * mvPosition;\n}";

	var heightFragmentShader = "#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#define LOG2 1.442695\nuniform sampler2D cmap;\nuniform vec3 fogColor;\nuniform int fogEnabled;\nuniform float fogDensity;\nuniform float distanceTransparency;\nvarying float fogDepth;\nvarying float zMap;\nvarying vec3 vColor;\nvarying vec3 vMvPosition;\nvoid main() {\n\tgl_FragColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) ) * vec4( vColor, 1.0 );\n\tif ( distanceTransparency > 0.0 ) {\n\t\tgl_FragColor.a = 1.0 - length( vMvPosition.xyz ) / distanceTransparency;\n\t}\n\tif ( fogEnabled != 0 ) {\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}";

	var popupVertexShader = "\nuniform mat2 rotate;\nuniform vec2 scale;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvoid main() {\n\tvec2 newPosition = vec2( position.x, position.y );\n\tvColor = color;\n\tvUv = newPosition;\n\tnewPosition = rotate * newPosition;\n\tvec4 offset = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tnewPosition *= scale;\n\tnewPosition *= offset.w;\n\tgl_Position = vec4( newPosition, 0.0, 0.0 ) + offset;\n}";

	var popupFragmentShader = "uniform sampler2D popupImage;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvoid main() {\n\tgl_FragColor = texture2D( popupImage, vUv ) * vec4( vColor, 1.0 );\n}";

	var waterVertexShader = "attribute vec3 sinks;\nattribute float selection;\nvarying vec3 vPosition;\nvarying float vSelection;\nvarying vec3 vSink;\nvoid main() {\n\tvPosition = position;\n\tvSelection = selection;\n\tvSink = sinks;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var waterFragmentShader = "uniform float offset;\nvarying vec3 vPosition;\nvarying float vSelection;\nvarying vec3 vSink;\nvoid main() {\n\tgl_FragColor = vec4( 0.1, 0.1, sin( offset + distance( vPosition, vSink ) ) * 0.4 + 0.6, 0.0 );\n\tgl_FragColor = mix( gl_FragColor, vec4( 1.0, 0.0, 0.0, 1.0 ), vSelection );\n}";

	var lineVertexShader = "#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nuniform float linewidth;\nuniform vec2 resolution;\nattribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nvarying vec2 vUv;\n#ifdef CV_HEIGHT\n\tuniform sampler2D cmap;\n\tuniform float minZ;\n\tuniform float scaleZ;\n\tvarying float zMap;\n#endif\n#if defined( CV_DEPTH ) || defined( CV_DEPTH_CURSOR )\n\tconst float UnpackDownscale = 255. / 256.;\n\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\n\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\tfloat unpackRGBAToFloat( const in vec4 v ) {\n\t\treturn dot( v, UnpackFactors );\n\t}\n\tuniform vec3 modelMin;\n\tuniform float scaleX;\n\tuniform float scaleY;\n\tuniform float rangeZ;\n\tuniform float depthScale;\n\tuniform sampler2D depthMap;\n\tuniform float datumShift;\n\tvarying float height;\n#endif\n#ifdef CV_CURSOR\n\tvarying float height;\n#endif\n#ifdef USE_DASH\n\tuniform float dashScale;\n\tattribute float instanceDistanceStart;\n\tattribute float instanceDistanceEnd;\n\tvarying float vLineDistance;\n#endif\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\tfloat a = projectionMatrix[ 2 ][ 2 ];\tfloat b = projectionMatrix[ 3 ][ 2 ];\tfloat nearEstimate = - 0.5 * b / a;\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\n}\nvoid main() {\n\t#ifdef USE_COLOR\n\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\t#endif\n\t#ifdef USE_DASH\n\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t#endif\n\tfloat aspect = resolution.x / resolution.y;\n\tvUv = uv;\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\tif ( perspective ) {\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\t\t\ttrimSegment( start, end );\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\t\t\ttrimSegment( end, start );\n\t\t}\n\t}\n\tvec4 clipStart = projectionMatrix * start;\n\tvec4 clipEnd = projectionMatrix * end;\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\tvec2 dir = ndcEnd - ndcStart;\n\tdir.x *= aspect;\n\tdir = normalize( dir );\n\tvec2 offset = vec2( dir.y, - dir.x );\n\tdir.x /= aspect;\n\toffset.x /= aspect;\n\tif ( position.x < 0.0 ) offset *= - 1.0;\n\tif ( position.y < 0.0 ) {\n\t\toffset += - dir;\n\t} else if ( position.y > 1.0 ) {\n\t\toffset += dir;\n\t}\n\toffset *= linewidth;\n\toffset /= resolution.y;\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\toffset *= clip.w;\n\tclip.xy += offset;\n\t#ifdef CV_CURSOR\n\t\theight = instanceStart.z + ( instanceEnd.z - instanceStart.z) * position.y;\n\t#endif\n\t#ifdef CV_HEIGHT\n\t\tzMap = ( instanceStart.z + ( instanceEnd.z - instanceStart.z) * position.y - minZ ) * scaleZ;\n\t#endif\n\t#if defined( CV_DEPTH ) || defined( CV_DEPTH_CURSOR )\n\t\tvec3 realPosition = instanceStart + ( instanceEnd - instanceStart ) * position.y;\n\t\tvec2 terrainCoords = vec2( ( realPosition.x - modelMin.x ) * scaleX, ( realPosition.y - modelMin.y ) * scaleY );\n\t\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, terrainCoords ) );\n\t\tterrainHeight = terrainHeight * rangeZ + modelMin.z + datumShift;\n\t\theight = terrainHeight - realPosition.z;\n\t#endif\n\t#ifdef CV_DEPTH\n\t\theight *= depthScale;\n\t#endif\n\tgl_Position = clip;\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var lineFragmentShader = "uniform vec3 diffuse;\nuniform float opacity;\n#ifdef CV_HEIGHT\n\tuniform sampler2D cmap;\n\tvarying float zMap;\n#endif\n#ifdef CV_DEPTH\n\tuniform sampler2D cmap;\n\tvarying float height;\n#endif\n#if defined( CV_CURSOR ) || defined( CV_DEPTH_CURSOR )\n\tuniform float cursor;\n\tuniform float cursorWidth;\n\tuniform vec3 baseColor;\n\tuniform vec3 cursorColor;\n\tvarying float height;\n#endif\n#ifdef USE_DASH\n\tuniform float dashSize;\n\tuniform float dashOffset;\n\tuniform float gapSize;\n#endif\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vUv;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#ifdef USE_DASH\n\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard;\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard;\n\t#endif\n\tif ( abs( vUv.y ) > 1.0 ) {\n\t\tfloat a = vUv.x;\n\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\tfloat len2 = a * a + b * b;\n\t\tif ( len2 > 1.0 ) discard;\n\t}\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\t#ifdef CV_HEIGHT\n\t\tgl_FragColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) ) * vec4( vColor, 1.0 );\n\t#endif\n\t#ifdef CV_DEPTH\n\t\tgl_FragColor = texture2D( cmap, vec2( height, 1.0 ) ) * vec4( vColor, 1.0 );\n\t#endif\n\t#if defined( CV_CURSOR ) || defined( CV_DEPTH_CURSOR )\n\t\tfloat delta = abs( height - cursor );\n\t\tfloat ss = smoothstep( 0.0, cursorWidth, cursorWidth - delta );\n\t\tif ( delta < cursorWidth * 0.05 ) {\n\t\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t\t} else {\n\t\t\tgl_FragColor = vec4( mix( baseColor, cursorColor, ss ), 1.0 ) * vec4( vColor, 1.0 );\n\t\t}\n\t#endif\n\t#ifdef CV_BASIC\n\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var commonTerrainCodeColor = "if ( scale > 0.0 ) {\n\tfloat targetDistance = distance( target, vPosition );\n\tfloat f = abs( targetDistance - accuracy ) * scale;\n\tfloat c = smoothstep( 1.0, 6.0, f );\n\tdiffuseColor = mix( vec4( ringColor, 1.0 ), diffuseColor, c );\n}";

	var commonTerrainCodePars = "uniform float scale;\nuniform float accuracy;\nuniform vec2 target;\nuniform vec3 ringColor;\nvarying vec2 vPosition;";

	const Shaders = {
		anaglyphVertexShader:	anaglyphVertexShader,
		anaglyphFragmentShader:	anaglyphFragmentShader,
		cursorVertexShader:		cursorVertexShader,
		cursorFragmentShader:	cursorFragmentShader,
		depthMapVertexShader:	depthMapVertexShader,
		depthMapFragmentShader:	depthMapFragmentShader,
		depthVertexShader:		depthVertexShader,
		depthFragmentShader:	depthFragmentShader,
		depthCursorVertexShader:		depthCursorVertexShader,
		depthCursorFragmentShader:		depthCursorFragmentShader,
		glyphVertexShader:		glyphVertexShader,
		glyphFragmentShader:	glyphFragmentShader,
		heightVertexShader:		heightVertexShader,
		heightFragmentShader:	heightFragmentShader,
		popupVertexShader:		popupVertexShader,
		popupFragmentShader:	popupFragmentShader,
		waterVertexShader:		waterVertexShader,
		waterFragmentShader:	waterFragmentShader,
		lineVertexShader:		lineVertexShader,
		lineFragmentShader:		lineFragmentShader,
		commonTerrainCodeColor: commonTerrainCodeColor,
		commonTerrainCodePars: commonTerrainCodePars
	};

	// EOF

	function CursorMaterial ( ctx, type ) {

		const survey = ctx.survey;
		const cfg = ctx.cfg;
		const limits = survey.modelLimits;

		ShaderMaterial.call( this, {
			vertexShader: Shaders.cursorVertexShader,
			fragmentShader: Shaders.cursorFragmentShader,
			type: 'CV.CursorMaterial',
			uniforms: Object.assign( {
				uLight:      { value: survey.lightDirection },
				cursor:      { value: 0 },
				cursorWidth: { value: 5.0 },
				baseColor:   { value: cfg.themeColor( 'shading.cursorBase' ) },
				cursorColor: { value: cfg.themeColor( 'shading.cursor' ) },
			}, ctx.materials.commonUniforms ),
			defines: {
				USE_COLOR: true,
				SURFACE: ( type !== MATERIAL_LINE )
			}
		} );

		this.halfRange = ( limits.max.z - limits.min.z ) / 2;

		return this;

	}

	CursorMaterial.prototype = Object.create( ShaderMaterial.prototype );

	CursorMaterial.prototype.setCursor = function ( value ) {

		const newValue = Math.max( Math.min( value, this.halfRange ), -this.halfRange );

		this.uniforms.cursor.value = newValue;

		return newValue; // return value clamped to material range

	};

	CursorMaterial.prototype.getCursor = function () {

		return this.uniforms.cursor.value;

	};

	function ClusterMaterial ( count ) {

		const markerSize = 64;
		const fontSize = 40;
		const halfSize = markerSize / 2;

		const canvas = document.createElement( 'canvas' );

		if ( ! canvas ) console.error( 'creating canvas for cluster marker failed' );

		canvas.width  = markerSize;
		canvas.height = markerSize;

		const ctx = canvas.getContext( '2d' );

		if ( ! ctx ) console.error( 'cannot obtain 2D canvas' );

		// set transparent background

		ctx.fillStyle = 'rgba( 0, 0, 0, 0 )';
		ctx.fillRect( 0, 0, markerSize, markerSize );

		ctx.textAlign = 'center';
		ctx.font = 'bold ' + fontSize + 'px helvetica,sans-serif';
		ctx.fillStyle = '#ffffff';

		const gradient = ctx.createRadialGradient( halfSize, halfSize, 30, halfSize, halfSize, 0 );

		gradient.addColorStop( 0.0, 'rgba( 255, 128, 0, 64 )' );
		gradient.addColorStop( 0.3, 'rgba( 255, 200, 0, 255 )' );
		gradient.addColorStop( 1.0, 'rgba( 255, 255, 0, 255 )' );

		ctx.fillStyle = gradient;

		ctx.beginPath();
		ctx.arc( halfSize, halfSize, 30, 0, Math.PI * 2 );
		ctx.fill();

		ctx.fillStyle = 'rgba( 0, 0, 0, 255 )';

		ctx.fillText( count, halfSize, halfSize + 15 );

		const texture = new CanvasTexture( canvas );

		PointsMaterial.call( this, { map: texture, size: 32, depthTest: false, transparent: true, alphaTest: 0.8, sizeAttenuation: false } );

		texture.onUpdate = function _dropCanvas ( texture ) { texture.image = null; };

		this.name = 'ClusterMaterial';

		return this;

	}

	ClusterMaterial.prototype = Object.create( PointsMaterial.prototype );

	function CommonTerrainMaterial () {}

	CommonTerrainMaterial.prototype.setThroughMode = function ( mode ) {

		this.stencilWrite = false;
		this.blending = NormalBlending;

		switch ( mode ) {

		case TERRAIN_BLEND:

			this.blending = CustomBlending;
			this.blendSrc = OneMinusDstAlphaFactor;
			this.blendDst = DstAlphaFactor;

			break;

		case TERRAIN_STENCIL:

			this.stencilWrite = true;
			this.stencilFunc = EqualStencilFunc;

			break;

		}

	};

	const fragment_pars = [
		'uniform vec3 contourColor;',
		'uniform vec3 contourColor10;',
		'uniform float contourInterval;',
		'uniform vec3 baseColor;',
		'varying float vPositionZ;',
	].join( '\n' );

	const fragment_color = [
		'float f = fract( vPositionZ / contourInterval );',
		'if ( f > 0.5 ) f = 1.0 - f;',
		'float f10 = fract( vPositionZ / ( contourInterval * 10.0 ) );',
		'float df = fwidth( vPositionZ / contourInterval );',
		'float contourColorSelection = step( 0.90, f10 );',
		'float c = smoothstep( df * 0.5, df * 1.0, f );',
		'vec4 finalColor = vec4( mix( contourColor, contourColor10, contourColorSelection ), 1.0 );',
		'vec4 baseColorAlpha = vec4( baseColor, opacity );',
		'diffuseColor = mix( finalColor, baseColorAlpha, c );'
	].join( '\n' );

	function ContourMaterial ( ctx ) {

		const survey = ctx.survey;
		const cfg = ctx.cfg;
		const materials = ctx.materials;

		MeshLambertMaterial.call( this );

		this.transparent = true;
		this.extensions = { derivatives: true };

		this.onBeforeCompile = function ( shader ) {

			Object.assign( shader.uniforms, {
				zOffset:         { value: survey.offsets.z },
				contourInterval: { value: cfg.themeValue( 'shading.contours.interval' ) },
				contourColor:    { value: cfg.themeColor( 'shading.contours.line' ) },
				contourColor10:  { value: cfg.themeColor( 'shading.contours.line10' ) },
				baseColor:       { value: cfg.themeColor( 'shading.contours.base' ) }
			}, materials.commonDepthUniforms, materials.commonTerrainUniforms );

			var vertexShader = shader.vertexShader
				.replace( '#include <common>', '$&\nuniform float zOffset;\nuniform float datumShift;\nvarying float vPositionZ;\n' )
				.replace( 'include <begin_vertex>', '$&\nvPositionZ = position.z + zOffset + datumShift;\n' );

			var fragmentShader = shader.fragmentShader
				.replace( '#include <common>', '$&\n' + fragment_pars + '\n' )
				.replace( '#include <color_fragment>', fragment_color );

			shader.vertexShader = vertexShader;
			shader.fragmentShader = fragmentShader;

		};

		Object.defineProperty( this, 'opacity', {
			get: function () { return ctx.materials.terrainOpacity; }
		} );

		return this;

	}

	ContourMaterial.prototype = Object.create( MeshLambertMaterial.prototype );

	Object.assign( ContourMaterial.prototype, CommonTerrainMaterial.prototype );

	function DepthMaterial ( ctx, type ) {

		const survey = ctx.survey;
		const surveyLimits = survey.modelLimits;
		const terrain = survey.terrain;
		const limits = terrain.boundingBox;
		const range = limits.getSize( new Vector3() );
		const gradient = ctx.cfg.value( 'saturatedGradient', false ) ? 'gradientHi' : 'gradientLow';
		const textureCache = ctx.materials.textureCache;

		ShaderMaterial.call( this, {
			vertexShader: Shaders.depthVertexShader,
			fragmentShader: Shaders.depthFragmentShader,
			type: 'CV.DepthMaterial',
			uniforms: Object.assign( {
				// pseudo light source somewhere over viewer's left shoulder.
				uLight:     { value: survey.lightDirection },
				modelMin:   { value: limits.min },
				scaleX:     { value: 1 / range.x },
				scaleY:     { value: 1 / range.y },
				rangeZ:     { value: range.z },
				depthScale: { value: 1 / ( surveyLimits.max.z - surveyLimits.min.z ) },
				cmap:       { value: textureCache.getTexture( gradient ) },
				depthMap:   { value: terrain.depthTexture },
			}, ctx.materials.commonUniforms, ctx.materials.commonDepthUniforms ),
			defines: {
				USE_COLOR: true,
				SURFACE: ( type !== MATERIAL_LINE )
			}
		} );

		return this;

	}

	DepthMaterial.prototype = Object.create( ShaderMaterial.prototype );

	function DepthCursorMaterial ( ctx, type ) {

		const survey = ctx.survey;
		const cfg = ctx.cfg;
		const surveyLimits = survey.modelLimits;
		const terrain = survey.terrain;

		const limits = terrain.boundingBox;
		const range = limits.getSize( new Vector3() );

		// max range of depth values
		this.max = surveyLimits.max.z - surveyLimits.min.z;

		ShaderMaterial.call( this, {
			vertexShader: Shaders.depthCursorVertexShader,
			fragmentShader: Shaders.depthCursorFragmentShader,
			type: 'CV.DepthCursorMaterial',
			uniforms: Object.assign( {
				uLight:      { value: survey.lightDirection },
				modelMin:    { value: limits.min },
				scaleX:      { value: 1 / range.x },
				scaleY:      { value: 1 / range.y },
				rangeZ:      { value: range.z },
				depthMap:    { value: terrain.depthTexture },
				cursor:      { value: this.max / 2 },
				cursorWidth: { value: 5.0 },
				baseColor:   { value: cfg.themeColor( 'shading.cursorBase' ) },
				cursorColor: { value: cfg.themeColor( 'shading.cursor' ) },
			}, ctx.materials.commonUniforms, ctx.materials.commonDepthUniforms ),
			defines: {
				USE_COLOR: true,
				SURFACE: ( type !== MATERIAL_LINE )
			}
		} );

		//	Object.assign( this.uniforms, ctx.materials.commonDepthUniforms ); FIXME?

		return this;

	}

	DepthCursorMaterial.prototype = Object.create( ShaderMaterial.prototype );

	DepthCursorMaterial.prototype.setCursor = function ( value ) {

		const newValue = Math.max( Math.min( value, this.max ), 0 );

		this.uniforms.cursor.value = newValue;

		return newValue; // return value clamped to material range

	};

	DepthCursorMaterial.prototype.getCursor = function () {

		return this.uniforms.cursor.value;

	};

	function DepthMapMaterial ( terrain ) {

		const boundingBox = terrain.boundingBox;

		const minHeight = boundingBox.min.z;
		const maxHeight = boundingBox.max.z;

		ShaderMaterial.call( this, {
			vertexShader: Shaders.depthMapVertexShader,
			fragmentShader: Shaders.depthMapFragmentShader,
			type: 'CV.DepthMapMaterial',
			depthWrite: false,
			uniforms: {
				minZ:   { value: minHeight },
				scaleZ: { value: 1 / ( maxHeight - minHeight ) }
			}
		} );

		return this;

	}

	DepthMapMaterial.prototype = Object.create( ShaderMaterial.prototype );

	function ExtendedPointsMaterial ( ctx ) {

		PointsMaterial.call( this );

		const colourCache = ctx.materials.colourCache;
		const textureCache = ctx.materials.textureCache;

		this.map = textureCache.getTexture( 'disc' );
		this.color = colourCache.white;
		this.opacity = 1.0;
		this.alphaTest = 0.8;

		this.sizeAttenuation = false;
		this.transparent = true; // to ensure points rendered over lines.
		this.vertexColors = true;

		this.onBeforeCompile = function ( shader ) {

			var vertexShader = shader.vertexShader
				.replace( '#include <common>', '\nattribute float pSize;\n\n$&' )
				.replace( '\tgl_PointSize = size;', '\tgl_PointSize = pSize;' );

			shader.vertexShader = vertexShader;

		};

		return this;

	}

	ExtendedPointsMaterial.prototype = Object.create( PointsMaterial.prototype );

	function GlyphMaterial ( ctx, glyphAtlas, rotation, viewer ) {

		this.rotation = rotation;

		const self = this;

		const cellScale = glyphAtlas.cellScale;
		const container = viewer.container;
		const realPixels = glyphAtlas.cellSize;

		const cos = Math.cos( rotation );
		const sin = Math.sin( rotation );
		const scale = new Vector2( realPixels / container.clientWidth, realPixels / container.clientHeight );

		const rotationMatrix = new Float32Array( [ cos, sin, -sin, cos ] );

		ShaderMaterial.call( this, {
			vertexShader: Shaders.glyphVertexShader,
			fragmentShader: Shaders.glyphFragmentShader,
			type: 'CV.GlyphMaterial',
			uniforms: Object.assign( {
				cellScale: { value: cellScale },
				atlas: { value: glyphAtlas.getTexture() },
				rotate: { value: rotationMatrix },
				scale: { value: scale }
			}, ctx.materials.commonUniforms ),
		} );

		this.alphaTest = 0.9;
		this.depthTest = false;
		this.transparent = true;

		this.type = 'CV.GlyphMaterial';
		this.atlas = glyphAtlas;
		this.scaleFactor = 1 / glyphAtlas.cellScale;

		viewer.addEventListener( 'resized', _resize );

		return this;

		function _resize() {

			self.uniforms.scale.value.set( realPixels / container.clientWidth, realPixels / container.clientHeight );

		}

	}

	GlyphMaterial.prototype = Object.create( ShaderMaterial.prototype );

	GlyphMaterial.prototype.getAtlas = function () {

		return this.atlas;

	};

	function HeightMaterial ( ctx, type ) {

		const survey = ctx.survey;
		const limits = survey.modelLimits;

		const zMin = limits.min.z;
		const zMax = limits.max.z;
		const gradient = ctx.cfg.value( 'saturatedGradient', false ) ? 'gradientHi' : 'gradientLow';
		const textureCache = ctx.materials.textureCache;

		this.midRange = ( zMax + zMin ) / 2;

		ShaderMaterial.call( this, {
			vertexShader: Shaders.heightVertexShader,
			fragmentShader: Shaders.heightFragmentShader,
			type: 'CV.HeightMaterial',
			uniforms: Object.assign( {
				uLight: { value: survey.lightDirection },
				minZ:   { value: zMin },
				scaleZ: { value: 1 / ( zMax - zMin ) },
				cmap:   { value: textureCache.getTexture( gradient ) },
			}, ctx.materials.commonUniforms ),
			defines: {
				USE_COLOR: true,
				SURFACE: ( type !== MATERIAL_LINE )
			}
		} );

		return this;

	}

	HeightMaterial.prototype = Object.create( ShaderMaterial.prototype );

	const fragment_pars$1 = [
		'uniform sampler2D cmap;',
		'varying float zMap;',
		Shaders.commonTerrainCodePars
	].join( '\n' );

	const fragment_color$1 = [
		'diffuseColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) );',
		'diffuseColor.a = opacity;',
		Shaders.commonTerrainCodeColor
	].join( '\n' );

	function HypsometricMaterial ( ctx ) {

		const survey = ctx.survey;
		const cfg = ctx.cfg;
		const terrain = survey.terrain;
		const textureCache = ctx.materials.textureCache;

		MeshLambertMaterial.call( this );

		var zMin = cfg.themeValue( 'shading.hypsometric.min' );
		var zMax = cfg.themeValue( 'shading.hypsometric.max' );

		if ( terrain.boundBox === undefined ) terrain.computeBoundingBox();

		if ( zMin === undefined ) zMin = terrain.boundingBox.min.z;
		if ( zMax === undefined ) zMax = terrain.boundingBox.max.z;

		this.transparent = true;

		this.onBeforeCompile = function ( shader ) {

			Object.assign(
				shader.uniforms,
				ctx.materials.commonTerrainUniforms,
				{
					minZ:   { value: zMin },
					scaleZ: { value: 1 / ( zMax - zMin ) },
					cmap:   { value: textureCache.getTexture( 'hypsometric' ) }
				}
			);

			var vertexShader = shader.vertexShader
				.replace( '#include <common>', '\nuniform float minZ;\nuniform float scaleZ;\nvarying float zMap;\nvarying vec2 vPosition;\n$&' )
				.replace( 'include <begin_vertex>', '$&\nvPosition = vec2( position.x, position.y );\nzMap = saturate( ( position.z - minZ ) * scaleZ );' );

			var fragmentShader = shader.fragmentShader
				.replace( '#include <common>', '$&\n' + fragment_pars$1 + '\n' )
				.replace( '#include <color_fragment>', fragment_color$1 );

			shader.vertexShader = vertexShader;
			shader.fragmentShader = fragmentShader;

		};

		Object.defineProperty( this, 'opacity', {
			get: function () { return ctx.materials.terrainOpacity; }
		} );

		return this;

	}

	HypsometricMaterial.prototype = Object.create( MeshLambertMaterial.prototype );

	Object.assign( HypsometricMaterial.prototype, CommonTerrainMaterial.prototype );

	function MissingMaterial ( ctx ) {

		MeshLambertMaterial.call( this, { color: 0xff8888} );

		this.transparent = true;

		Object.defineProperty( this, 'opacity', {
			get: function () { return ctx.materials.terrainOpacity; }
		} );

		return this;

	}

	MissingMaterial.prototype = Object.create( MeshLambertMaterial.prototype );

	Object.assign( MissingMaterial.prototype, CommonTerrainMaterial.prototype );

	MathUtils.generateUUID = function () { return null; };

	Object3D.DefaultUp.set( 0, 0, 1 );

	Object3D.prototype.addStatic = function ( obj ) {

		obj.matrixAutoUpdate = false;
		obj.updateMatrix();

		this.add( obj );

	};

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  linewidth: <float>,
	 *  dashed: <boolean>,
	 *  dashScale: <float>,
	 *  dashSize: <float>,
	 *  dashOffset: <float>,
	 *  gapSize: <float>,
	 *  resolution: <Vector2>, // to be set by renderer
	 * }
	 */

	const uniforms = UniformsUtils.merge( [
		UniformsLib.common,
		UniformsLib.fog,
		{
			linewidth: { value: 1 },
			resolution: { value: new Vector2( 1, 1 ) },
			dashScale: { value: 1 },
			dashSize: { value: 1 },
			dashOffset: { value: 0 },
			gapSize: { value: 1 }, // todo FIX - maybe change to totalSize
			opacity: { value: 1 }
		}
	] );

	var LineMaterial = function ( ctx, mode = 'height') {

		const survey = ctx.survey;
		const cfg = ctx.cfg;
		const gradient = cfg.value( 'saturatedGradient', false ) ? 'gradientHi' : 'gradientLow';
		const textureCache = ctx.materials.textureCache;
		const surveyLimits = survey.modelLimits;

		const zMax = surveyLimits.max.z;
		const zMin = surveyLimits.min.z;

		const defines = {};

		let terrain = null;
		let limits = null;
		let range = null;

		if ( survey.terrain ) {

			terrain = survey.terrain;

			if ( terrain.boundingBox ) {

				limits = terrain.boundingBox;
				range = limits.getSize( new Vector3() );

			}

		}

		let customUniforms = {};

		switch ( mode ) {

		case 'height':

			defines.CV_HEIGHT = true;
			customUniforms = {
				minZ:   { value: zMin },
				scaleZ: { value: 1 / ( zMax - zMin ) },
				cmap:   { value: textureCache.getTexture( gradient ) },
			};

			break;

		case 'cursor':

			defines.CV_CURSOR = true;
			customUniforms = {
				cursor:      { value: 0 },
				cursorWidth: { value: 5.0 },
				baseColor:   { value: cfg.themeColor( 'shading.cursorBase' ) },
				cursorColor: { value: cfg.themeColor( 'shading.cursor' ) },
			};
			break;

		case 'depth':

			defines.CV_DEPTH = true;
			customUniforms = Object.assign(
				{
					modelMin:   { value: limits.min },
					scaleX:     { value: 1 / range.x },
					scaleY:     { value: 1 / range.y },
					rangeZ:     { value: range.z },
					depthScale: { value: 1 / ( surveyLimits.max.z - surveyLimits.min.z ) },
					cmap:       { value: textureCache.getTexture( gradient ) },
					depthMap:   { value: terrain.depthTexture },
				},
				ctx.materials.commonDepthUniforms
			);
			break;

		case 'depth-cursor':

			this.max = surveyLimits.max.z - surveyLimits.min.z;

			defines.CV_DEPTH_CURSOR = true;
			customUniforms = Object.assign(
				{
					modelMin:    { value: limits.min },
					scaleX:      { value: 1 / range.x },
					scaleY:      { value: 1 / range.y },
					rangeZ:      { value: range.z },
					depthMap:    { value: terrain.depthTexture },
					cursor:      { value: this.max / 2 },
					cursorWidth: { value: 5.0 },
					baseColor:   { value: cfg.themeColor( 'shading.cursorBase' ) },
					cursorColor: { value: cfg.themeColor( 'shading.cursor' ) },
				},
				ctx.materials.commonDepthUniforms
			);
			break;

		default:
			defines.CV_BASIC = true;

		}

		ShaderMaterial.call( this, {

			type: 'LineMaterial',

			uniforms: Object.assign(
				UniformsUtils.clone( uniforms ),
				customUniforms,
				ctx.materials.commonUniforms
			),

			vertexShader: Shaders.lineVertexShader,
			fragmentShader: Shaders.lineFragmentShader,

			clipping: true, // required for clipping support
			defines: defines
		} );

		this.dashed = false;

		// for cursor material variant
		this.halfRange = ( surveyLimits.max.z - surveyLimits.min.z ) / 2;

		Object.defineProperties( this, {

			color: {

				enumerable: true,

				get: function () {

					return this.uniforms.diffuse.value;

				},

				set: function ( value ) {

					this.uniforms.diffuse.value = value;

				}

			},

			linewidth: {

				enumerable: true,

				get: function () {

					return this.uniforms.linewidth.value;

				},

				set: function ( value ) {

					this.uniforms.linewidth.value = value;

				}

			},

			dashScale: {

				enumerable: true,

				get: function () {

					return this.uniforms.dashScale.value;

				},

				set: function ( value ) {

					this.uniforms.dashScale.value = value;

				}

			},

			dashSize: {

				enumerable: true,

				get: function () {

					return this.uniforms.dashSize.value;

				},

				set: function ( value ) {

					this.uniforms.dashSize.value = value;

				}

			},

			dashOffset: {

				enumerable: true,

				get: function () {

					return this.uniforms.dashOffset.value;

				},

				set: function ( value ) {

					this.uniforms.dashOffset.value = value;

				}

			},

			gapSize: {

				enumerable: true,

				get: function () {

					return this.uniforms.gapSize.value;

				},

				set: function ( value ) {

					this.uniforms.gapSize.value = value;

				}

			},

			opacity: {

				enumerable: true,

				get: function () {

					return this.uniforms.opacity.value;

				},

				set: function ( value ) {

					this.uniforms.opacity.value = value;

				}

			},

			resolution: {

				enumerable: true,

				get: function () {

					return this.uniforms.resolution.value;

				},

				set: function ( value ) {

					this.uniforms.resolution.value.copy( value );

				}

			}

		} );

		this.setValues( {
			color: 0xffffff,
			vertexColors: true,
			linewidth: 1
		} );

		this.resolution = new Vector2( ctx.container.clientWidth, ctx.container.clientHeight );

		ctx.viewer.addEventListener( 'resized', ( e ) => {

			const lineScale = e.lineScale ? e.lineScale : 1;

			this.resolution = new Vector2( e.width, e.height );
			this.linewidth = Math.max( 1, Math.floor( e.width / 1000 ) * lineScale );

		} );

	};

	LineMaterial.prototype = Object.create( ShaderMaterial.prototype );
	LineMaterial.prototype.constructor = LineMaterial;

	LineMaterial.prototype.isLineMaterial = true;

	LineMaterial.prototype.setCursor = function ( value ) {

		var newValue;

		if ( this.max !== undefined ) {

			newValue = Math.max( Math.min( value, this.max ), 0 ); // depthCursor

		} else {

			newValue = Math.max( Math.min( value, this.halfRange ), -this.halfRange );

		}

		this.uniforms.cursor.value = newValue;

		return newValue; // return value clamped to material range

	};

	LineMaterial.prototype.getCursor = function () {

		return this.uniforms.cursor.value;

	};

	const gradientColoursHi = [[167,1,221], [131,4,228], [74,2,231], [47,2,242], [2,27,247], [3,33,251], [4,39,254], [5,51,254], [6,75,254], [7,101,254], [8,127,238], [9,151,213], [10,177,168], [19,202,123], [30,227,78], [41,252,40], [72,254,36], [126,254,33], [167,254,30], [194,253,30], [220,224,29], [253,203,31], [254,176,25], [254,148,21], [254,120,18], [254,90,13], [254,61,9], [254,30,6], [254,2,2], [254,1,1], [254,1,1], [255,0, 0 ] ];
	const gradientColoursLow = [[235,99,111],[235,99,112],[234,99,113],[234,100,114],[233,100,114],[233,100,115],[232,100,116],[232,101,117],[231,101,118],[231,101,119],[230,101,119],[230,101,120],[230,102,121],[229,102,122],[229,102,123],[228,102,124],[228,103,124],[227,103,125],[227,103,126],[226,103,127],[226,103,128],[226,104,129],[225,104,129],[225,104,130],[224,104,131],[224,104,132],[223,105,133],[223,105,134],[222,105,134],[222,105,135],[221,106,136],[221,106,137],[221,106,138],[220,106,139],[220,106,139],[219,107,140],[219,107,141],[218,107,142],[218,107,143],[217,108,144],[217,108,144],[216,108,145],[216,108,146],[216,108,147],[215,109,148],[215,109,149],[214,109,149],[214,109,150],[213,110,151],[213,110,152],[212,110,153],[212,110,154],[211,110,154],[211,111,155],[211,111,156],[210,111,157],[210,111,158],[209,111,159],[209,112,159],[208,112,160],[208,112,161],[207,112,162],[207,113,163],[207,113,164],[206,113,164],[206,113,165],[205,113,166],[205,114,167],[204,114,168],[204,114,169],[203,114,169],[203,115,170],[202,115,171],[202,115,172],[201,115,172],[200,116,173],[199,116,173],[198,116,173],[197,117,174],[196,117,174],[194,118,174],[193,118,175],[192,118,175],[191,119,176],[190,119,176],[189,119,176],[188,120,177],[187,120,177],[186,121,177],[185,121,178],[184,121,178],[183,122,178],[181,122,179],[180,122,179],[179,123,179],[178,123,180],[177,124,180],[176,124,181],[175,124,181],[174,125,181],[173,125,182],[172,125,182],[171,126,182],[170,126,183],[168,126,183],[167,127,183],[166,127,184],[165,128,184],[164,128,184],[163,128,185],[162,129,185],[161,129,186],[160,129,186],[159,130,186],[158,130,187],[157,131,187],[155,131,187],[154,131,188],[153,132,188],[152,132,188],[151,132,189],[150,133,189],[149,133,189],[148,133,190],[147,134,190],[146,134,191],[145,135,191],[144,135,191],[142,135,192],[141,136,192],[140,136,192],[139,136,193],[138,137,193],[137,137,193],[136,138,194],[135,138,194],[134,138,194],[133,139,195],[132,139,195],[131,139,196],[129,140,196],[128,140,196],[127,141,197],[126,141,197],[125,141,197],[124,142,198],[123,142,198],[122,142,198],[120,142,197],[119,143,197],[117,143,197],[116,143,197],[114,143,196],[113,144,196],[111,144,196],[110,144,195],[108,144,195],[107,144,195],[105,145,195],[104,145,194],[102,145,194],[101,145,194],[100,146,193],[98,146,193],[97,146,193],[95,146,193],[94,146,192],[92,147,192],[91,147,192],[89,147,191],[88,147,191],[86,147,191],[85,148,191],[83,148,190],[82,148,190],[80,148,190],[79,149,189],[78,149,189],[76,149,189],[75,149,189],[73,149,188],[72,150,188],[70,150,188],[69,150,187],[67,150,187],[66,151,187],[64,151,186],[63,151,186],[61,151,186],[60,151,186],[59,152,185],[57,152,185],[56,152,185],[54,152,184],[53,153,184],[51,153,184],[50,153,184],[48,153,183],[47,153,183],[45,154,183],[44,154,182],[42,154,182],[41,154,182],[39,154,182],[38,155,181],[37,155,181],[35,155,181],[34,155,180],[32,156,180],[31,156,180],[29,156,180],[28,156,179],[26,156,179],[25,157,179],[23,157,178],[22,157,178],[20,157,178],[19,158,178],[17,158,177],[16,158,177],[16,158,176],[17,158,176],[17,158,175],[18,158,174],[18,158,174],[19,158,173],[19,158,172],[20,158,171],[20,158,171],[21,158,170],[21,158,169],[22,158,169],[22,159,168],[23,159,167],[23,159,167],[23,159,166],[24,159,165],[24,159,164],[25,159,164],[25,159,163],[26,159,162],[26,159,162],[27,159,161],[27,159,160],[28,159,160],[28,159,159],[29,159,158],[29,159,157],[30,159,157],[30,159,156],[30,159,155],[31,159,155],[31,159,154],[32,159,153],[32,159,153],[33,159,152],[33,160,151],[34,160,150],[34,160,150],[35,160,149],[35,160,148],[36,160,148],[36,160,147],[36,160,146],[37,160,146],[37,160,145],[38,160,144],[38,160,143],[39,160,143],[39,160,142],[40,160,141],[40,160,141],[41,160,140],[41,160,139],[42,160,139],[42,160,138],[43,160,137],[43,160,136],[43,160,136],[44,160,135],[44,161,134],[45,161,134],[45,161,133],[46,161,132],[46,161,132],[47,161,131],[47,161,130],[48,161,129],[48,161,129],[49,161,128],[49,161,127],[50,161,127],[50,161,126],[51,161,125],[52,161,125],[53,161,124],[54,161,123],[55,161,123],[56,161,122],[56,160,121],[57,160,121],[58,160,120],[59,160,120],[60,160,119],[61,160,118],[62,160,118],[63,160,117],[64,160,116],[65,160,116],[66,160,115],[67,160,114],[67,159,114],[68,159,113],[69,159,112],[70,159,112],[71,159,111],[72,159,111],[73,159,110],[74,159,109],[75,159,109],[76,159,108],[77,159,107],[78,159,107],[78,158,106],[79,158,105],[80,158,105],[81,158,104],[82,158,103],[83,158,103],[84,158,102],[85,158,102],[86,158,101],[87,158,100],[88,158,100],[89,158,99],[89,157,98],[90,157,98],[91,157,97],[92,157,96],[93,157,96],[94,157,95],[95,157,94],[96,157,94],[97,157,93],[98,157,93],[99,157,92],[100,157,91],[100,156,91],[101,156,90],[102,156,89],[103,156,89],[104,156,88],[105,156,87],[106,156,87],[107,156,86],[108,156,85],[109,156,85],[110,156,84],[111,156,84],[111,155,83],[112,155,82],[113,155,82],[114,155,81],[115,155,80],[116,155,80],[117,155,79],[118,155,79],[118,155,79],[119,154,78],[120,154,78],[121,154,78],[121,154,78],[122,154,78],[123,153,77],[123,153,77],[124,153,77],[125,153,77],[126,153,77],[126,152,77],[127,152,76],[128,152,76],[128,152,76],[129,152,76],[130,151,76],[131,151,75],[131,151,75],[132,151,75],[133,150,75],[133,150,75],[134,150,74],[135,150,74],[136,150,74],[136,149,74],[137,149,74],[138,149,73],[138,149,73],[139,149,73],[140,148,73],[141,148,73],[141,148,72],[142,148,72],[143,148,72],[143,147,72],[144,147,72],[145,147,72],[145,147,71],[146,147,71],[147,146,71],[148,146,71],[148,146,71],[149,146,70],[150,146,70],[150,145,70],[151,145,70],[152,145,70],[153,145,69],[153,145,69],[154,144,69],[155,144,69],[155,144,69],[156,144,68],[157,143,68],[158,143,68],[158,143,68],[159,143,68],[160,143,67],[160,142,67],[161,142,67],[162,142,67],[163,142,67],[163,142,67],[164,141,66],[165,141,66],[165,141,66],[166,141,66],[167,141,66],[168,140,65],[168,140,65],[169,140,65],[169,140,65],[170,140,66],[170,139,66],[171,139,66],[171,139,67],[172,139,67],[172,139,67],[172,138,68],[173,138,68],[173,138,68],[174,138,69],[174,138,69],[175,137,69],[175,137,70],[175,137,70],[176,137,70],[176,137,71],[177,136,71],[177,136,71],[177,136,72],[178,136,72],[178,135,72],[179,135,73],[179,135,73],[180,135,73],[180,135,74],[180,134,74],[181,134,74],[181,134,75],[182,134,75],[182,134,75],[183,133,76],[183,133,76],[183,133,76],[184,133,77],[184,133,77],[185,132,77],[185,132,77],[186,132,78],[186,132,78],[186,132,78],[187,131,79],[187,131,79],[188,131,79],[188,131,80],[189,131,80],[189,130,80],[189,130,81],[190,130,81],[190,130,81],[191,130,82],[191,129,82],[192,129,82],[192,129,83],[192,129,83],[193,128,83],[193,128,84],[194,128,84],[194,128,84],[194,128,85],[195,127,85],[195,127,85],[196,127,86],[196,127,86],[197,127,86],[197,126,87],[197,126,87],[198,126,87],[198,126,88],[199,126,88],[199,125,88],[200,125,89],[200,125,89]];
	const depthColours = [[255,255,204],[255,255,203],[255,255,203],[255,254,202],[255,254,202],[255,254,201],[255,254,200],[255,253,200],[255,253,199],[255,253,199],[255,253,198],[255,252,197],[255,252,197],[255,252,196],[255,252,196],[255,251,195],[255,251,194],[255,251,194],[255,251,193],[255,250,193],[255,250,192],[255,250,191],[255,250,191],[255,249,190],[255,249,190],[255,249,189],[255,249,188],[255,248,188],[255,248,187],[255,248,187],[255,248,186],[255,247,185],[255,247,185],[255,247,184],[255,247,184],[255,246,183],[255,246,182],[255,246,182],[255,246,181],[255,245,180],[255,245,180],[255,245,179],[255,245,179],[255,244,178],[255,244,177],[255,244,177],[255,244,176],[255,243,176],[255,243,175],[255,243,174],[255,243,174],[255,242,173],[255,242,173],[255,242,172],[255,242,171],[255,241,171],[255,241,170],[255,241,170],[255,241,169],[255,240,168],[255,240,168],[255,240,167],[255,240,167],[255,239,166],[255,239,165],[255,239,165],[255,239,164],[255,238,164],[255,238,163],[255,238,162],[255,238,162],[255,237,161],[255,237,161],[255,237,160],[255,237,159],[255,236,159],[255,236,158],[255,236,158],[255,236,157],[255,235,157],[255,235,156],[255,235,155],[255,235,155],[255,234,154],[255,234,154],[255,234,153],[255,233,153],[255,233,152],[255,233,151],[255,233,151],[255,232,150],[255,232,150],[255,232,149],[255,232,148],[255,231,148],[255,231,147],[255,231,147],[255,230,146],[255,230,146],[255,230,145],[255,230,144],[255,229,144],[255,229,143],[255,229,143],[255,229,142],[255,228,142],[255,228,141],[255,228,140],[255,227,140],[255,227,139],[254,227,139],[254,227,138],[254,226,138],[254,226,137],[254,226,136],[254,225,136],[254,225,135],[254,225,135],[254,225,134],[254,224,134],[254,224,133],[254,224,132],[254,224,132],[254,223,131],[254,223,131],[254,223,130],[254,222,130],[254,222,129],[254,222,128],[254,222,128],[254,221,127],[254,221,127],[254,221,126],[254,221,125],[254,220,125],[254,220,124],[254,220,124],[254,219,123],[254,219,123],[254,219,122],[254,219,121],[254,218,121],[254,218,120],[254,218,120],[254,218,119],[254,217,119],[254,217,118],[254,216,117],[254,216,117],[254,215,116],[254,215,116],[254,214,115],[254,214,115],[254,213,114],[254,213,113],[254,212,113],[254,212,112],[254,211,112],[254,211,111],[254,210,111],[254,210,110],[254,209,109],[254,208,109],[254,208,108],[254,207,108],[254,207,107],[254,206,106],[254,206,106],[254,205,105],[254,205,105],[254,204,104],[254,204,104],[254,203,103],[254,203,102],[254,202,102],[254,202,101],[254,201,101],[254,200,100],[254,200,100],[254,199,99],[254,199,98],[254,198,98],[254,198,97],[254,197,97],[254,197,96],[254,196,96],[254,196,95],[254,195,94],[254,195,94],[254,194,93],[254,193,93],[254,193,92],[254,192,92],[254,192,91],[254,191,90],[254,191,90],[254,190,89],[254,190,89],[254,189,88],[254,189,88],[254,188,87],[254,188,86],[254,187,86],[254,187,85],[254,186,85],[254,185,84],[254,185,83],[254,184,83],[254,184,82],[254,183,82],[254,183,81],[254,182,81],[254,182,80],[254,181,79],[254,181,79],[254,180,78],[254,180,78],[254,179,77],[254,179,77],[254,178,76],[254,177,76],[254,177,76],[254,176,75],[254,176,75],[254,175,75],[254,175,75],[254,174,74],[254,174,74],[254,173,74],[254,173,74],[254,172,74],[254,172,73],[254,171,73],[254,171,73],[254,170,73],[254,170,72],[254,169,72],[254,169,72],[254,168,72],[254,168,72],[254,167,71],[254,167,71],[254,166,71],[254,166,71],[254,165,71],[254,165,70],[254,164,70],[254,164,70],[254,163,70],[254,163,69],[254,162,69],[254,162,69],[254,161,69],[254,161,69],[254,160,68],[254,160,68],[253,159,68],[253,159,68],[253,158,67],[253,158,67],[253,157,67],[253,157,67],[253,156,67],[253,156,66],[253,155,66],[253,155,66],[253,154,66],[253,154,65],[253,153,65],[253,153,65],[253,152,65],[253,152,65],[253,151,64],[253,151,64],[253,150,64],[253,150,64],[253,149,64],[253,149,63],[253,148,63],[253,148,63],[253,147,63],[253,147,62],[253,146,62],[253,146,62],[253,145,62],[253,145,62],[253,144,61],[253,144,61],[253,143,61],[253,143,61],[253,142,60],[253,142,60],[253,141,60],[253,140,60],[253,139,60],[253,138,59],[253,138,59],[253,137,59],[253,136,59],[253,135,58],[253,134,58],[253,133,58],[253,132,58],[253,132,57],[253,131,57],[253,130,57],[253,129,57],[253,128,56],[253,127,56],[253,126,56],[253,125,56],[253,125,55],[253,124,55],[253,123,55],[253,122,55],[253,121,54],[253,120,54],[253,119,54],[253,119,54],[253,118,53],[253,117,53],[253,116,53],[253,115,53],[253,114,52],[253,113,52],[253,113,52],[253,112,52],[253,111,51],[253,110,51],[252,109,51],[252,108,51],[252,107,50],[252,106,50],[252,106,50],[252,105,50],[252,104,49],[252,103,49],[252,102,49],[252,101,49],[252,100,48],[252,100,48],[252,99,48],[252,98,48],[252,97,47],[252,96,47],[252,95,47],[252,94,47],[252,94,46],[252,93,46],[252,92,46],[252,91,46],[252,90,45],[252,89,45],[252,88,45],[252,87,45],[252,87,44],[252,86,44],[252,85,44],[252,84,44],[252,83,43],[252,82,43],[252,81,43],[252,81,43],[252,80,42],[252,79,42],[252,78,42],[252,77,42],[251,77,42],[251,76,41],[251,75,41],[250,74,41],[250,74,41],[250,73,41],[249,72,40],[249,72,40],[249,71,40],[248,70,40],[248,69,40],[248,69,40],[247,68,39],[247,67,39],[247,67,39],[246,66,39],[246,65,39],[245,64,38],[245,64,38],[245,63,38],[244,62,38],[244,62,38],[244,61,37],[243,60,37],[243,59,37],[243,59,37],[242,58,37],[242,57,36],[242,57,36],[241,56,36],[241,55,36],[241,54,36],[240,54,35],[240,53,35],[240,52,35],[239,52,35],[239,51,35],[239,50,35],[238,50,34],[238,49,34],[238,48,34],[237,47,34],[237,47,34],[237,46,33],[236,45,33],[236,45,33],[236,44,33],[235,43,33],[235,42,32],[235,42,32],[234,41,32],[234,40,32],[234,40,32],[233,39,31],[233,38,31],[232,37,31],[232,37,31],[232,36,31],[231,35,30],[231,35,30],[231,34,30],[230,33,30],[230,32,30],[230,32,30],[229,31,29],[229,30,29],[229,30,29],[228,29,29],[228,28,29],[228,27,28],[227,27,28],[227,26,28],[226,26,28],[226,25,28],[225,25,28],[224,25,29],[224,24,29],[223,24,29],[222,24,29],[222,23,29],[221,23,29],[220,22,29],[219,22,30],[219,22,30],[218,21,30],[217,21,30],[217,21,30],[216,20,30],[215,20,30],[215,20,30],[214,19,31],[213,19,31],[213,19,31],[212,18,31],[211,18,31],[211,17,31],[210,17,31],[209,17,32],[209,16,32],[208,16,32],[207,16,32],[206,15,32],[206,15,32],[205,15,32],[204,14,33],[204,14,33],[203,14,33],[202,13,33],[202,13,33],[201,12,33],[200,12,33],[200,12,33],[199,11,34],[198,11,34],[198,11,34],[197,10,34],[196,10,34],[195,10,34],[195,9,34],[194,9,35],[193,9,35],[193,8,35],[192,8,35],[191,7,35],[191,7,35],[190,7,35],[189,6,36],[189,6,36],[188,6,36],[187,5,36],[187,5,36],[186,5,36],[185,4,36],[185,4,36],[184,4,37],[183,3,37],[182,3,37],[182,2,37],[181,2,37],[180,2,37],[180,1,37],[179,1,38],[178,1,38],[178,0,38],[177,0,38]];
	const inclinationColours = [[255,255,0],[253,254,2],[251,253,4],[249,252,5],[247,251,7],[245,250,9],[243,249,11],[241,249,13],[239,248,14],[237,247,16],[235,246,18],[233,245,20],[231,244,22],[229,243,23],[227,242,25],[225,241,27],[223,240,29],[221,239,31],[219,238,32],[217,237,34],[215,237,36],[213,236,38],[211,235,40],[209,234,41],[207,233,43],[205,232,45],[203,231,47],[201,230,49],[199,229,50],[197,228,52],[195,227,54],[193,226,56],[191,226,58],[189,225,60],[187,224,61],[185,223,63],[183,222,65],[181,221,67],[179,220,69],[177,219,70],[175,218,72],[173,217,74],[171,216,76],[169,215,78],[167,214,79],[165,214,81],[163,213,83],[161,212,85],[159,211,87],[157,210,88],[155,209,90],[153,208,92],[151,207,94],[149,206,96],[147,205,97],[145,204,99],[143,203,101],[141,202,103],[139,202,105],[137,201,106],[135,200,108],[133,199,110],[131,198,112],[129,197,114],[126,196,115],[124,195,117],[122,194,119],[120,193,121],[118,192,123],[116,191,124],[114,191,126],[112,190,128],[110,189,130],[108,188,132],[106,187,133],[104,186,135],[102,185,137],[100,184,139],[98,183,141],[96,182,142],[94,181,144],[92,180,146],[90,179,148],[88,179,150],[86,178,151],[84,177,153],[82,176,155],[80,175,157],[78,174,159],[76,173,160],[74,172,162],[72,171,164],[70,170,166],[68,169,168],[66,168,169],[64,167,171],[62,167,173],[60,166,175],[58,165,177],[56,164,179],[54,163,180],[52,162,182],[50,161,184],[48,160,186],[46,159,188],[44,158,189],[42,157,191],[40,156,193],[38,156,195],[36,155,197],[34,154,198],[32,153,200],[30,152,202],[28,151,204],[26,150,206],[24,149,207],[22,148,209],[20,147,211],[18,146,213],[16,145,215],[14,144,216],[12,144,218],[10,143,220],[8,142,222],[6,141,224],[4,140,225],[2,139,227],[0,138,229]];
	const surveyColours = [[0xa6,0xce,0xe3],[0x1f,0x78,0xb4],[0xb2,0xdf,0x8a],[0x33,0xa0,0x2c],[0xfb,0x9a,0x99],[0xe3,0x1a,0x1c],[0xfd,0xbf,0x6f],[0xff,0x7f,0x00],[0xca,0xb2,0xd6],[0x6a,0x3d,0x9a],[0xff,0xff,0x99]];
	const hypsometric = [[148,191,139],[148,191,139],[168,198,143],[168,198,143],[189,204,150],[189,204,150],[209,215,171],[209,215,171],[225,228,181],[225,228,181],[239,235,192],[239,235,192],[232,225,182],[232,225,182],[222,214,163],[222,214,163],[211,202,157],[211,202,157],[202,185,130],[202,185,130],[195,167,107],[195,167,107],[192,154,83],[192,154,83],[184,146,71],[184,146,71],[175,140,71],[175,140,71],[168,136,71],[168,136,71],[159,128,72],[159,128,72]];

	const Colours = {
		inclination: inclinationColours,
		gradientLow: gradientColoursLow,
		gradientHi:  gradientColoursHi,
		survey:      surveyColours,
		depth:       depthColours,
		hypsometric: hypsometric
	};

	// define colors to share THREE.color objects

	function ColourCache ( ) {

		const cache = [];

		function createColors ( scale ) {

			const cache = [];

			for ( var i = 0, l = scale.length; i < l; i++ ) {

				const c = scale[ i ];

				cache[ i ] = new Color( c[ 0 ] / 255, c[ 1 ] / 255, c[ 2 ] / 255 );

			}

			return cache;

		}

		this.getColors = function ( name ) {

			var entry = cache[ name ];

			if ( entry === undefined ) {

				const scale = Colours[ name ];

				if ( scale === undefined ) console.error( 'unknown colour scale requested ' + name );

				entry = createColors( scale );
				cache[ name ] = entry;

			}

			return entry;

		};

		this.white = new Color( 0xffffff );

	}

	// define colors to share THREE.color objects

	function TextureCache () {

		const cache = [];

		function createTexture ( scale ) {

			const l = scale.length;
			const data = new Uint8Array( l * 3 );

			var offset = 0;

			for ( var i = l; i; ) {

				const c = scale[ --i ];

				data[ offset++ ] = c[ 0 ];
				data[ offset++ ] = c[ 1 ];
				data[ offset++ ] = c[ 2 ];

			}

			const texture = new DataTexture( data, l, 1, RGBFormat, UnsignedByteType );

			texture.minFilter = LinearFilter;
			texture.magFilter = LinearFilter;

			texture.needsUpdate = true;

			return texture;

		}

		this.getTexture = function ( name ) {

			var entry = cache[ name ];

			if ( entry === undefined ) {

				if ( name === 'disc' ) {

					entry = new TextureLoader().load( "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg id='a' width='32mm' height='32mm' version='1.1' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' %3E%3Ccircle id='d' cx='16' cy='16' r='14' color='%23000000' fill='%23fff' fill-rule='evenodd' stroke-width='0'/%3E%3C/svg%3E%0A" );

				} else if ( name === 'disc-outlined' ) {

					entry = new TextureLoader().load( "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg id='a' width='32mm' height='32mm' version='1.1' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' %3E%3Ccircle id='d' cx='16' cy='16' r='14' color='%23000000' fill='%23fff' fill-rule='evenodd' stroke-width='1' stroke='%23000'/%3E%3C/svg%3E%0A" );

				} else {

					const scale = Colours[ name ];

					if ( scale === undefined ) console.error( 'unknown colour scale requested ' + name );

					entry = createTexture( scale );

				}

				cache[ name ] = entry;

			}

			return entry;

		};

	}

	function GlyphAtlas ( glyphAtlasSpec ) {

		const atlasSize = 512;
		const fontSize = 28;
		const cellSize = 32;

		const divisions = atlasSize / cellSize;

		const canvas = document.createElement( 'canvas' );

		const glyphs = '\u202f\u00B0\u2610 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%,.-_/()[]\'"';
		const glyphCount = glyphs.length;

		this.cellScale = cellSize / atlasSize;
		this.cellSize = cellSize;
		this.glyphCount = glyphCount;
		this.divisions = divisions;

		this.map = {};

		if ( glyphCount > divisions * divisions ) {

			console.error( 'too many glyphs for atlas' );
			return;

		}

		if ( ! canvas ) console.error( 'creating canvas for glyph atlas failed' );

		canvas.width = atlasSize;
		canvas.height = atlasSize;

		const ctx = canvas.getContext( '2d' );

		if ( ! ctx ) console.error( 'cannot obtain 2D canvas' );

		// set background
		ctx.fillStyle = glyphAtlasSpec.background || 'rgba( 0, 0, 0, 0 )';
		ctx.fillRect( 0, 0, atlasSize, atlasSize );

		// set up text settings
		ctx.textAlign = 'left';
		ctx.font = fontSize + 'px ' + glyphAtlasSpec.font;
		ctx.fillStyle = glyphAtlasSpec.color || '#ffffff';

		this.ctx = ctx;

		for ( var i = 0; i < glyphCount; i++ ) {

			this.addGlyphToCanvas( glyphs.charAt( i ), i );

		}

		this.texture = new CanvasTexture( canvas );
		this.texture.minFilter = LinearFilter;
		this.generateMipmaps = false;

	}

	GlyphAtlas.prototype.addGlyphToCanvas = function ( glyph, i ) {

		const divisions = this.divisions;
		const ctx = this.ctx;
		const cellSize = this.cellSize;

		const glyphWidth = ctx.measureText( glyph ).width / cellSize;

		const row = Math.floor( i / divisions ) + 1;
		const column = i % divisions;

		const glyphData = {
			row: ( divisions - row ) / divisions,
			column: column / divisions,
			width: glyphWidth
		};

		this.map[ glyph ] = glyphData;

		ctx.fillText( glyph, cellSize * column, cellSize * row - 7 );

		return glyphData;

	};

	GlyphAtlas.prototype.getTexture = function () {

		return this.texture;

	};

	GlyphAtlas.prototype.getGlyph = function ( glyph ) {

		var glyphData = this.map[ glyph ];

		if ( glyphData === undefined ) {

			if ( this.glyphCount + 1 > this.divisions * this.divisions ) {

				console.warn( 'too many glyphs for atlas when adding [' + glyph + ']' );
				return;

			}

			glyphData = this.addGlyphToCanvas( glyph, this.glyphCount++ );

			this.texture.needsUpdate = true;

		}

		return glyphData;

	};

	function GlyphAtlasCache () {

		const atlasCache = [];

		this.getAtlas = function ( glyphAtlasSpec ) {

			const key = JSON.stringify( glyphAtlasSpec );

			var atlas = atlasCache[ key ];

			if ( atlas === undefined ) {

				atlas = new GlyphAtlas( glyphAtlasSpec );
				atlasCache[ key ] = atlas;

			}

			return atlas;

		};

	}

	function Materials ( viewer ) {

		const cache = new Map();
		const ctx = viewer.ctx;
		const self = this;

		var glyphAtlasCache = new GlyphAtlasCache();
		var cursorMaterials = new Set();
		var perSurveyMaterials = {};
		var cursorHeight = 0;

		const colourCache = new ColourCache();
		const textureCache = new TextureCache();

		this.colourCache = colourCache;
		this.textureCache = textureCache;

		const gradientType = ctx.cfg.value( 'saturatedGradient', false ) || ctx.cfg.themeValue( 'saturatedGradient' );
		const gradient = gradientType ? 'gradientHi' : 'gradientLow';
		const surfaceColour = ctx.cfg.themeValue( 'shading.single' );

		this.commonUniforms = {
			fogColor: { value: ctx.cfg.themeColor( 'background' ) },
			fogDensity: { value: 0.0025 },
			fogEnabled: { value: 0 },
			distanceTransparency: { value: 0.0 }
		};

		this.commonDepthUniforms = {
			datumShift: { value: 0.0 }
		};

		this.commonTerrainUniforms = {
			scale: { value: 0.0 },
			accuracy: { value: 0.0 },
			target: { value: new Vector2() },
			ringColor: { value: new Color( 0xff0000 ) }
		};

		this.terrainOpacity = 0.5;

		Object.defineProperty( this, 'cursorHeight', {
			get: function () { return cursorHeight; },
			set: updateCursors
		} );

		const distanceTransparency = this.commonUniforms.distanceTransparency;

		Object.defineProperty( this, 'distanceTransparency', {
			get: function () { return distanceTransparency.value; },
			set: function ( x ) { distanceTransparency.value = x; }
		} );

		function cacheMaterial ( name, material, stencil ) {

			cache.set( name, material );

			if ( stencil ) {

				material.stencilWrite = true;
				material.stencilZPass = IncrementStencilOp;

			}

			return material;

		}

		function getCacheMaterial ( name, materialFunc, stencil ) {

			var material = cache.get( 'name' );

			if ( material === undefined ) {

				material = cacheMaterial( name, materialFunc(), stencil );

			}

			return material;

		}

		function getSurveyCacheMaterial ( name, materialFunc, stencil ) {

			const material = getCacheMaterial( name, materialFunc, stencil );
			perSurveyMaterials[ name ] = material;

			return material;

		}

		function updateCursors( newHeight ) {

			cursorMaterials.forEach( function ( material ) {

				cursorHeight = material.setCursor( newHeight );

			} );

		}

		function updateDatumShifts( event ) {

			self.commonDepthUniforms.datumShift.value = event.value;

		}

		this.getLine2Material = function ( mode = '' ) {

			const func = function () { return new LineMaterial( ctx, mode ); };
			const material = getSurveyCacheMaterial( 'line2-' + mode, func, true );

			if ( mode == 'cursor' || mode == 'depth-cursor' ) {

				// set active cursor material for updating
				cursorMaterials.add( material );

			}

			return material;

		};

		this.getHeightMaterial = function ( type ) {

			const func = function () { return new HeightMaterial( ctx, type ); };
			return getSurveyCacheMaterial( 'height' + type, func, true );

		};

		this.getHypsometricMaterial = function () {

			const func = function () { return new HypsometricMaterial( ctx ); };
			return getSurveyCacheMaterial( 'hypsometric', func );

		};

		this.getDepthMapMaterial = function ( terrain ) {

			return new DepthMapMaterial( terrain );

		};

		this.getDepthMaterial = function ( type ) {

			const func = function () { return new DepthMaterial( ctx, type ); };
			return getSurveyCacheMaterial( 'depth' + type, func, true );

		};

		this.getCursorMaterial = function ( type ) {

			const func = function () { return new CursorMaterial( ctx, type ); };
			const material = getSurveyCacheMaterial( 'cursor' + type, func, true );

			// set active cursor material for updating
			cursorMaterials.add( material );

			return material;

		};

		this.getDepthCursorMaterial = function ( type ) {

			const func = function () { return new DepthCursorMaterial( ctx, type ); };
			const material = getSurveyCacheMaterial( 'depthCursor' + type, func, true );

			// set active cursor material for updating
			cursorMaterials.add( material );

			return material;

		};

		this.getBezelMaterial = function  () {

			var func;

			if ( ctx.cfg.themeValue( 'hud.bezelType' ) === 'flat' ) {

				func = function () { return new MeshBasicMaterial( { color: ctx.cfg.themeValue( 'hud.bezel' ) } ); };

			} else {

				func = function () { return new MeshPhongMaterial( { color: ctx.cfg.themeValue( 'hud.bezel' ), specular: 0x888888 } ); };

			}

			return getCacheMaterial( 'bezel', func, true );

		};

		this.getPlainMaterial = function  () {

			const func = function () { return new MeshBasicMaterial( { color: 0xffffff, vertexColors: true } ); };
			return getCacheMaterial( 'plain', func, true );

		};

		this.getSurfaceMaterial = function  () {

			const func = function () { return new MeshLambertMaterial( { color: surfaceColour, vertexColors: false } ); };
			return getCacheMaterial( 'surface', func, true );

		};


		this.getLineMaterial = function () {

			const func = function () { return new LineBasicMaterial( { color: 0xffffff, vertexColors: true } ); };
			return getCacheMaterial( 'line', func, true );

		};

		this.getExtendedPointsMaterial = function () {

			const func = function () { return new ExtendedPointsMaterial( ctx ); };
			return getCacheMaterial( 'extendedPoints', func, true );

		};

		this.getMissingMaterial = function () {

			const func = function () { return new MissingMaterial( ctx ); };
			return getCacheMaterial( 'missing', func );

		};

		this.getUnselectedMaterial = function () {

			const func = function () { return new LineBasicMaterial( { color: 0x444444, vertexColors: true } ); };
			return getCacheMaterial( 'unselected', func );

		};

		this.getUnselectedWallMaterial = function () {

			const func = function () { return new MeshLambertMaterial( { color: 0x444444, vertexColors: true} ); };
			return getCacheMaterial( 'unselectedWall', func );

		};

		this.getScaleMaterial = function () {

			const func = function () { return new MeshBasicMaterial( { color: 0xffffff, map: textureCache.getTexture( gradient ) } ); };
			return getCacheMaterial( 'scale', func );

		};

		this.getContourMaterial = function () {

			const func = function () { return new ContourMaterial( ctx ); };
			return getSurveyCacheMaterial( 'contour', func );

		};

		this.getGlyphMaterial = function ( glyphAtlasSpec, rotation ) {

			const atlas = glyphAtlasCache.getAtlas( glyphAtlasSpec );
			const name = JSON.stringify( glyphAtlasSpec ) + ':' + rotation.toString();

			const func = function () { return new GlyphMaterial( ctx, atlas, rotation, viewer ); };

			return getCacheMaterial( name, func );

		};

		this.getClusterMaterial = function ( count ) {

			const func = function () { return new ClusterMaterial( count ); };
			return getCacheMaterial( 'cluster' + count, func, true );

		};

		this.setTerrain = function ( terrain ) {

			terrain.addEventListener( 'datumShiftChange', updateDatumShifts );

		};

		this.flushCache = function () {

			var name;

			cursorMaterials.clear();

			for ( name in perSurveyMaterials ) {

				const material = perSurveyMaterials[ name ];

				material.dispose();
				cache.delete( name );

			}

			perSurveyMaterials = {};
			ctx.glyphStringCache = new Map();
			cursorHeight = 0;

		};

		this.setFog = function ( enable ) {

			self.commonUniforms.fogEnabled.value = enable ? 1 : 0;

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author marklundin / http://mark-lundin.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author tschw
	 */

	function AnaglyphEffect ( renderer, width, height ) {

		// Matrices generated with angler.js https://github.com/tschw/angler.js/
		// (in column-major element order, as accepted by WebGL)

		this.colorMatrixLeft = new Matrix3().fromArray( [

			1.0671679973602295, 	-0.0016435992438346148,		 0.0001777536963345483, // r out
			-0.028107794001698494,	-0.00019593400065787137,	-0.0002875397040043026, // g out
			-0.04279090091586113,	 0.000015809757314855233,	-0.00024287120322696865 // b out

		] );

		//	red						green 						blue  						in

		this.colorMatrixRight = new Matrix3().fromArray( [

			-0.0355340838432312,	-0.06440307199954987,		 0.018319187685847282,	// r out
			-0.10269022732973099,	 0.8079727292060852,		-0.04835830628871918,	// g out
			0.0001224992738571018,	-0.009558862075209618,		 0.567823588848114		// b out

		] );

		var _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

		var _scene = new Scene();

		var _stereo = new StereoCamera();

		_stereo.cameraL.layers.mask = 0xFFFFFFFF;
		_stereo.cameraR.layers.mask = 0xFFFFFFFF;

		var _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };

		if ( width === undefined ) width = 512;
		if ( height === undefined ) height = 512;

		var pixelRatio = renderer.getPixelRatio();

		var _renderTargetL = new WebGLRenderTarget( width * pixelRatio, height * pixelRatio, _params );
		var _renderTargetR = new WebGLRenderTarget( width * pixelRatio, height * pixelRatio, _params );

		var _material = new ShaderMaterial( {

			uniforms: {

				'mapLeft': { value: _renderTargetL.texture },
				'mapRight': { value: _renderTargetR.texture },

				'colorMatrixLeft': { value: this.colorMatrixLeft },
				'colorMatrixRight': { value: this.colorMatrixRight }

			},

			vertexShader: Shaders.anaglyphVertexShader,
			fragmentShader: Shaders.anaglyphFragmentShader

		} );

		var _mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), _material );
		_scene.add( _mesh );

		this.setLayers = function ( mask ) {

			_stereo.cameraL.layers.mask = mask;
			_stereo.cameraR.layers.mask = mask;

		};

		this.setSize = function ( width, height ) {

			renderer.setSize( width, height );

			var pixelRatio = renderer.getPixelRatio();

			_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );
			_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );

		};

		this.setEyeSeparation = function ( x ) {

			_stereo.eyeSep = x;

		};

		this.render = function ( scene, camera ) {

			scene.updateMatrixWorld();

			if ( camera.parent === null ) camera.updateMatrixWorld();

			_stereo.update( camera );

			renderer.setRenderTarget( _renderTargetL );
			renderer.clear();
			renderer.render( scene, _stereo.cameraL );

			renderer.setRenderTarget( _renderTargetR );
			renderer.clear();
			renderer.render( scene, _stereo.cameraR );

			renderer.setRenderTarget( null );
			renderer.render( _scene, _camera );

		};

		this.dispose = function() {

			if ( _renderTargetL ) _renderTargetL.dispose();
			if ( _renderTargetR ) _renderTargetR.dispose();

			if ( _material ) _material.dispose();
			if ( _mesh ) _mesh.geometry.dispose();
		};

	}

	function CameraManager ( ctx, renderer, scene ) {

		const container = ctx.container;

		var width = container.clientWidth;
		var height = container.clientHeight;
		var boundingRect = container.getBoundingClientRect();

		const orthographicCamera = new OrthographicCamera( -width / 2, width / 2, height / 2, -height / 2, 1, 4000 );
		const perspectiveCamera = new PerspectiveCamera( ctx.cfg.themeValue( 'fieldOfView' ) , width / height, 1, 16000 );

		const mouse = new Vector2();

		const self = this;

		scene.add( perspectiveCamera );
		scene.add( orthographicCamera );

		initCamera( perspectiveCamera );
		initCamera( orthographicCamera );

		this.activeCamera = perspectiveCamera;
		this.mode = CAMERA_PERSPECTIVE;

		const backMaterial = new MeshBasicMaterial( { side: BackSide, colorWrite: false } );
		const backMask = 1 << FEATURE_SURVEY | 1 << FEATURE_TERRAIN;

		var savedMask;
		var eyeSeparation = 0.5;
		var lastFrame = 0;

		ctx.viewer.addEventListener( 'resized', onResize );

		function onResize ( e ) {

			width = e.width;
			height = e.height;

			boundingRect = container.getBoundingClientRect();

			// adjust cameras to new aspect ratio etc.

			orthographicCamera.zoom *= width / ( orthographicCamera.right - orthographicCamera.left );

			orthographicCamera.left   = -width / 2;
			orthographicCamera.right  =  width / 2;
			orthographicCamera.top    =  height / 2;
			orthographicCamera.bottom = -height / 2;

			orthographicCamera.updateProjectionMatrix();

			perspectiveCamera.aspect = width / height;

			perspectiveCamera.updateProjectionMatrix();

			if ( self.activeEffect !== null ) {

				self.activeEffect.setSize( width, height );

			}

		}

		const basicRenderer = function () {

			renderer.render( scene, self.activeCamera );
			renderer.getContext().flush();

			lastFrame = renderer.info.render.frame;

		};

		const maskedRenderer = function () {

			// render depth buffer from underside of terrain
			const camera = self.activeCamera;

			if ( self.testCameraLayer( FEATURE_TERRAIN ) ) {

				camera.layers.mask = backMask;
				scene.overrideMaterial = backMaterial;

				renderer.render( scene, camera );

				scene.overrideMaterial = null;
				camera.layers.mask = savedMask;

			}

			renderer.render( scene, camera );
			renderer.getContext().flush();

			lastFrame = renderer.info.render.frame;

		};

		this.maskedTerrain = true;
		this.activeRenderer = maskedRenderer;

		this.activeEffect = null;

		function initCamera ( camera ) {

			camera.zoom = 1;

			camera.layers.set( 0 );

			camera.layers.enable( LEG_CAVE );
			camera.layers.enable( FEATURE_SELECTED_BOX );

		}

		this.resetCameras = function () {

			initCamera( perspectiveCamera );
			initCamera( orthographicCamera );

		};

		this.setCameraLayer = function ( layerTag, enable ) {

			if ( enable ) {

				perspectiveCamera.layers.enable( layerTag );
				orthographicCamera.layers.enable( layerTag );

			} else {

				perspectiveCamera.layers.disable( layerTag );
				orthographicCamera.layers.disable( layerTag );

			}

			savedMask = this.activeCamera.layers.mask;

			if ( this.activeEffect !== null ) {

				this.activeEffect.setLayers( savedMask );

			}

		};

		this.testCameraLayer = function ( layerTag ) {

			return ( ( savedMask & 1 << layerTag ) > 0 );

		};

		this.setCamera = function ( mode, target ) {

			if ( this.mode === mode ) return;

			var offsetLength;
			var activeCamera = this.activeCamera;

			const offset = activeCamera.position.clone().sub( target );

			if ( this.activeEffect !== null ) {

				this.activeEffect.dispose();

			}

			var activeEffect = null;

			switch ( mode ) {

			case CAMERA_ANAGLYPH:

				activeEffect = new AnaglyphEffect( renderer, width, height );

				if ( activeCamera.isPerspective ) break;

			case CAMERA_PERSPECTIVE: // eslint-disable-line no-fallthrough

				offsetLength = 4 * height * Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov / 2 ) / orthographicCamera.zoom / 2;

				offset.setLength( offsetLength );

				activeCamera = perspectiveCamera;

				break;

			case CAMERA_ORTHOGRAPHIC:

				offsetLength = offset.length();

				orthographicCamera.zoom = 2 * height * Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov / 2 ) / offsetLength;

				activeCamera = orthographicCamera;

				break;

			default:

				console.warn( 'unknown camera mode', mode );
				return;

			}

			if ( activeEffect !== null ) {

				activeEffect.setLayers( activeCamera.layers.mask );

				this.activeRenderer = function () {

					activeEffect.render( scene, self.activeCamera );

				};

			} else {

				if ( this.maskedTerrain ) {

					this.activeRenderer = maskedRenderer;

				} else {

					this.activeRenderer = basicRenderer;

				}

			}

			// update new camera with position to give same apparent zoom and view

			activeCamera.position.copy( offset.add( target ) );

			activeCamera.updateProjectionMatrix();
			activeCamera.lookAt( target );

			this.activeCamera = activeCamera;
			this.activeEffect = activeEffect;
			this.mode = mode;

		};

		this.getLastFrame = function () {

			return lastFrame;

		};

		this.getMouse = function ( x, y ) {

			mouse.set(
				( ( x - boundingRect.left ) / container.clientWidth ) * 2 - 1,
				- ( ( y - boundingRect.top ) / container.clientHeight ) * 2 + 1
			);

			return mouse;

		};

		Object.defineProperties( this, {

			'eyeSeparation': {
				get: function () { return eyeSeparation; },
				set: function ( x ) {

					// x varies from 0 to 1
					// base separation = 0.064
					eyeSeparation = x;

					if ( this.activeEffect !== null ) {

						this.activeEffect.setEyeSeparation( 0.064 + ( x - 0.5 ) * 0.06 );

					}

				}

			},

			'focalLength': {
				get: function () { return perspectiveCamera.getFocalLength(); },
				set: function ( x ) {
					perspectiveCamera.setFocalLength( x );
				}
			}

		} );

	}

	function LightingManager ( ctx, scene ) {

		const cfg = ctx.cfg;
		const lightPosition = new Vector3();
		const currentLightPosition = new Vector3();
		const directionalLight = new DirectionalLight( 0xffffff );
		const ambientLight = new AmbientLight( 0xffffff, 0.3 );

		const inclination = cfg.themeAngle( 'lighting.inclination' );
		const azimuth = cfg.themeAngle( 'lighting.azimuth' ) - Math.PI / 2;

		lightPosition.setFromSpherical( new Spherical( 1, inclination, azimuth ) );
		lightPosition.applyAxisAngle( new Vector3( 1, 0, 0 ), Math.PI / 2 );

		currentLightPosition.copy( lightPosition );

		directionalLight.position.copy( lightPosition );

		scene.addStatic( directionalLight );
		scene.addStatic( ambientLight );

		this.setRotation = function( rotation ) {

			currentLightPosition.copy( lightPosition );
			currentLightPosition.applyAxisAngle( Object3D.DefaultUp, rotation.z );

			directionalLight.position.copy( currentLightPosition );
			directionalLight.updateMatrix();

		};

		Object.defineProperty( this, 'directionalLighting', {
			get: function () { return directionalLight.visible; },
			set: function ( on ) {

				directionalLight.visible = on;
				ambientLight.intensity = on ? 0.3 : 1.0;

			}
		} );

	}

	const __v1$1 = new Vector3();
	const __m4 = new Matrix4();
	const __e = new Euler();

	function CameraMove ( controls, renderFunction ) {

		this.controls = controls;
		this.renderFunction = renderFunction;

		this.endCameraPosition = new Vector3();
		this.endPOI = new Vector3();
		this.endZoom = 1;
		this.endQuaternion = new Quaternion();

		this.frameCount = 0;
		this.skipNext = false;
		this.rotation = 0;
		this.delta = 0;
		this.running = false;
		this.animationFunction = null;
		this.rafID = 0;

		this.doAnimate = this.animate.bind( this );

	}

	CameraMove.fitBox = function ( camera, box, viewAxis ) {

		const size = box.getSize( __v1$1 );

		var elevation = CAMERA_OFFSET;
		var zoom = 1;

		var dX, dY, dZ;

		if ( viewAxis === undefined || viewAxis.z !== 0 ) {

			dX = size.x;
			dY = size.y;
			dZ = size.z;

		} else if ( viewAxis.x !== 0 ) {

			dX = size.y;
			dY = size.z;
			dZ = size.x;

		} else {

			dX = size.x;
			dY = size.z;
			dZ = size.y;

		}

		if ( camera.isPerspectiveCamera ) {

			const tan2 = 2 * Math.tan( MathUtils.DEG2RAD * 0.5 * camera.getEffectiveFOV() );

			const e1 = dY / tan2;
			const e2 = ( 1 / camera.aspect ) * dX / tan2;

			elevation = Math.max( e1, e2 ) * 1.1 + dZ / 2;

			if ( elevation === 0 ) elevation = 100;

		} else {

			const hRatio = ( camera.right - camera.left ) / dX;
			const vRatio = ( camera.top - camera.bottom ) / dY;

			zoom = Math.min( hRatio, vRatio ) * 1 / 1.1;

		}

		return { zoom: zoom, elevation: elevation };

	};

	CameraMove.prototype.getCardinalAxis = function ( targetAxis ) {

		const camera = this.controls.cameraManager.activeCamera;

		camera.getWorldDirection( __v1$1 );

		const x = Math.abs( __v1$1.x );
		const y = Math.abs( __v1$1.y );
		const z = Math.abs( __v1$1.z );

		if ( x > y && x > z ) {

			targetAxis.set( Math.sign( __v1$1.x ), 0, 0 );

		} else if ( y > z ) {

			targetAxis.set( 0, Math.sign( __v1$1.y ), 0 );

		} else {

			targetAxis.set( 0, 0, Math.sign( __v1$1.z ) );

		}

	};

	CameraMove.prototype.prepareRotation = function ( endCamera, orientation ) {

		const camera = this.controls.cameraManager.activeCamera;

		__v1$1.copy( endCamera ).sub( this.endPOI ).normalize();

		const zDot = __v1$1.dot( Object3D.DefaultUp );

		if ( Math.abs( zDot ) > 0.99999 && orientation !== undefined ) {

			// apply correction if looking verticaly to set to required cardinal direction for 'up'
			endCamera.add( orientation.multiplyScalar( 0.02 * __v1$1.z ) );

		}

		// calculate end state rotation of camera

		__m4.lookAt( endCamera, this.endPOI, Object3D.DefaultUp );

		this.endQuaternion.setFromRotationMatrix( __m4 ).normalize();

		// rotation to nearest degree
		this.rotation = Math.round( 2 * Math.acos( Math.abs( MathUtils.clamp( this.endQuaternion.dot( camera.quaternion ), - 1, 1 ) ) ) * MathUtils.RAD2DEG );

	};

	CameraMove.prototype.prepare = function () {

		const targetAxis = new Vector3();
		const orientation = new Vector3();

		return function prepare ( endBox, requiredTargetAxis ) {

			if ( this.running ) return this;

			const camera = this.controls.cameraManager.activeCamera;
			const endPOI = this.endPOI;
			const cameraStart = camera.position;
			const endCameraPosition = this.endCameraPosition;

			this.skipNext = false;

			// move camera to cardinal axis closest to current camera direction
			// or axis provided by caller

			if ( requiredTargetAxis === undefined ) {

				this.getCardinalAxis( targetAxis );

				if ( targetAxis.z !== 0 ) {

					// set orientation from current orientation, snapping to cardinals
					__e.setFromQuaternion( camera.quaternion );

					const direction = Math.round( 2 * ( __e.z + Math.PI ) / Math.PI );

					switch ( direction ) {

					case 0:
					case 4:

						orientation.set( 0, 1, 0 ); // S
						break;

					case 1:

						orientation.set( -1, 0, 0 ); // E
						break;

					case 2:

						orientation.set( 0, -1, 0 ); // N
						break;

					case 3:

						orientation.set( 1, 0, 0 ); // W
						break;

					default:

						orientation.set( 0, -1, 0 ); // up = N when looking vertically

					}

				}

			} else {

				targetAxis.copy( requiredTargetAxis );
				orientation.set( 0, -1, 0 ); // up = N when looking vertically

			}

			const fit = CameraMove.fitBox( camera, endBox, targetAxis );

			endBox.getCenter( endPOI );

			this.endZoom = fit.zoom;

			endCameraPosition.copy( endPOI ).add( targetAxis.negate().multiplyScalar( fit.elevation ) );

			// skip move if extremely small

			const cameraOffset = cameraStart.distanceTo( endCameraPosition );

			// calculate end state rotation of camera

			this.prepareRotation( endCameraPosition, orientation );

			if ( cameraOffset < 0.1 * endCameraPosition.z ) {

				// simple rotation of camera, minimal camera position change

				this.skipNext = ( this.rotation === 0 );

			} else {

				this.rotation = 0;

			}

			this.animationFunction = this.animateMove;

			return this;

		};

	}();

	CameraMove.prototype.preparePoint = function ( endPOI ) {

		if ( this.running ) return this;

		const camera = this.controls.cameraManager.activeCamera;

		// calculate end state rotation of camera
		this.endPOI.copy( endPOI );
		this.endCameraPosition.copy( camera.position );

		this.prepareRotation( camera.position );

		// minimal camera rotation or no change of POI
		this.skipNext = ( this.rotation === 0 );

		this.animationFunction = this.animateMove;

		return this;

	};

	CameraMove.prototype.prepareSimpleMove = function ( endCameraPosition ) {

		if ( this.running ) return this;

		this.endCameraPosition.copy( endCameraPosition );

		this.animationFunction = this.animateSimpleMove;
		this.skipNext = false;

		return this;

	};

	CameraMove.prototype.start = function ( timed ) {

		if ( this.running || this.skipNext ) return;

		const controls = this.controls;

		if ( timed ) {

			this.frameCount = ( this.rotation > 0 ) ? Math.max( 1, Math.round( this.rotation / 2 ) ) : 30;

		} else {

			this.frameCount = 1;

		}

		controls.enabled = false;

		this.running = true;

		this.animate();

	};

	CameraMove.prototype.cancel = function () {

		if ( this.rafID !== 0 ) window.cancelAnimationFrame( this.rafID );

		if ( ! this.running ) return;

		this.frameCount = 1;
		this.running = false;
		this.rafID = 0;

		this.animate();

		this.controls.enabled = true;
		this.controls.autoRotate = false;

	};

	CameraMove.prototype.animate = function () {

		const controls = this.controls;

		if ( controls.autoRotate ) {

			controls.update();

		} else if ( this.animationFunction ) {

			this.animationFunction();

			if ( --this.frameCount === 0 ) {

				this.animationFunction = null;
				this.endAnimation();

			}

		}

		if ( this.running ) this.rafID = window.requestAnimationFrame( this.doAnimate );

	};

	CameraMove.prototype.endAnimation = function () {

		const controls = this.controls;
		const camera = controls.cameraManager.activeCamera;

		controls.target.copy( this.endPOI );

		if ( this.rotation > 0 ) camera.position.copy( this.endCameraPosition );

		this.running = false;
		this.rotation = 0;
		this.rafID = 0;

		controls.update();
		controls.enabled = true;

		controls.end();

	};

	CameraMove.prototype.animateMove = function () {

		// update camera position

		const camera = this.controls.cameraManager.activeCamera;
		const target = this.controls.target;
		const dt = 1 - ( this.frameCount - 1 ) / this.frameCount;

		if ( ! this.rotation ) {

			camera.position.lerp( this.endCameraPosition, dt);
			camera.zoom = camera.zoom + ( this.endZoom - camera.zoom ) * dt;

			if ( camera.isOrthographicCamera ) camera.updateProjectionMatrix();

			camera.lookAt( target.lerp( this.endPOI, dt ) );

		}

		camera.quaternion.slerp( this.endQuaternion, dt );

		this.renderFunction();

	};

	CameraMove.prototype.animateSimpleMove = function () {

		// update camera position

		const camera = this.controls.cameraManager.activeCamera;
		const dt = 1 - ( this.frameCount - 1 ) / this.frameCount;

		camera.position.lerp( this.endCameraPosition, dt);

		this.renderFunction();

	};

	CameraMove.prototype.setAngleCommon = function ( delta ) {

		this.frameCount = Math.max( 1, Math.round( Math.abs( delta ) * 90 / Math.PI ) );
		this.delta = delta / this.frameCount;
		this.running = true;

		this.animate();

	};

	CameraMove.prototype.setAzimuthAngle = function ( targetAngle ) {

		const controls = this.controls;

		if ( this.running || controls.autoRotate ) return this;

		var delta = ( controls.getAzimuthalAngle() - targetAngle );
		var deltaSize = Math.abs( delta );

		if ( deltaSize > Math.PI ) delta = 2 * Math.PI - deltaSize;

		this.animationFunction = this.animateAzimuthMove;

		this.setAngleCommon( delta );

	};

	CameraMove.prototype.animateAzimuthMove = function () {

		this.controls.rotateLeft( this.delta );

	};

	CameraMove.prototype.setPolarAngle = function ( targetAngle ) {

		if ( this.running ) return this;

		this.animationFunction = this.animatePolarMove;

		this.setAngleCommon( this.controls.getPolarAngle() - targetAngle );

	};

	CameraMove.prototype.animatePolarMove = function () {

		this.controls.rotateUp( this.delta );

	};

	CameraMove.prototype.setAutoRotate = function ( state ) {

		const controls = this.controls;

		if ( state ) {

			if ( this.running ) return;

			controls.autoRotate = true;

			this.running = true;
			this.animationFunction = false;

			this.animate();

		} else {

			if ( controls.autoRotate ) this.running = false;

			controls.autoRotate = false;
			controls.enabled = true;
			this.rafID = 0;

		}

	};

	function replaceExtension( fileName, newExtention ) {

		if ( fileName === undefined ) return 'file set';

		return fileName.split( '.' ).shift() + '.' + newExtention;

	}

	function dataURL( json ) {

		return 'data:text/json;charset=utf8,' + encodeURIComponent( JSON.stringify( json, null, '\t' ) );

	}

	// extend Vector3 to add methods to calculate lengths corrected for distortions introduced

	class StationPosition extends Vector3 {

		constructor( x, y, z ) {

			super( x, y, z );

		}

	}

	StationPosition.scaleFactor = 1;

	Object.assign( StationPosition.prototype, Vector3.prototype );

	StationPosition.prototype.connections = 0;
	StationPosition.prototype.splays = 0;

	StationPosition.prototype.correctedDistanceTo = function ( v ) {

		return Math.sqrt( this.correctedDistanceToSquared( v ) );

	};

	StationPosition.prototype.correctedDistanceToSquared = function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = ( this.z - v.z ) * StationPosition.scaleFactor;

		return dx * dx + dy * dy + dz * dz;

	};

	function Svx3dHandler ( fileName ) {

		this.fileName = fileName;
		this.groups = [];
		this.section = null;

	}

	Svx3dHandler.prototype.constructor = Svx3dHandler;

	Svx3dHandler.prototype.type = 'arraybuffer';

	Svx3dHandler.prototype.parse = function ( cave, dataStream, metadata, section ) {

		cave.metadata = metadata;

		this.section = section;
		this.groups = [];
		this.cave = cave;
		this.stationMap = new Map();
		this.dataStream = dataStream;

		var pos = 0; // file position

		// read file header

		readLF(); // Survex 3D Image File
		this.version = readLF(); // 3d version
		const auxInfo = readNSLF();
		readLF(); // Date

		var sourceCRS = ( auxInfo[ 1 ] === undefined ) ? null : auxInfo[ 1 ]; // coordinate reference system ( proj4 format )

		console.log( 'Survex .3d version ', this.version );

		this.pos = pos;

		return cave.setCRS( sourceCRS ).then( this.parse2.bind( this ) );

		//return this.parse2();

		function readLF () { // read until Line feed

			return readNSLF()[ 0 ];

		}

		function readNSLF () { // read until Line feed and split by null bytes

			const bytes = new Uint8Array( dataStream, 0 );
			const strings = [];

			var lfString = [];
			var b;

			do {

				b = bytes[ pos++ ];

				if ( b === 0x0a || b === 0 ) {

					strings.push( String.fromCharCode.apply( null, lfString ).trim() );
					lfString = [];

				} else {

					lfString.push( b );

				}

			} while ( b != 0x0a );

			return strings;

		}

	};

	Svx3dHandler.prototype.parse2 = function () {

		const cave = this.cave;

		var pos = this.pos;

		switch ( this.version ) {

		case 'Bv0.01':

			this.handleOld( this.dataStream, pos, 1 );

			break;

		case 'v3':
		case 'v4':
		case 'v5':
		case 'v6':
		case 'v7':
		case 'v8':

			this.handleVx( this.dataStream, pos, Number( this.version.charAt( 1 ) ), this.section );

			break;

		default:

			throw new Error( 'unsupported .3d version ' + this.version );

		}

		// if pre selecting a section - trim returned surveyTree
		if ( this.section !== null ) cave.surveyTree.trim( this.section.split( '.' ) );

		cave.addStations( this.stationMap );

		cave.addLineSegments( this.groups );

		return cave;

	};

	Svx3dHandler.prototype.handleOld = function ( source, pos, version ) {

		const cave       = this.cave;

		const surveyTree = cave.surveyTree;
		const projection = cave.projection;
		const limits     = cave.limits;

		const groups     = this.groups;
		const stationMap = this.stationMap;

		const cmd      = [];
		const stations = new Map();

		const dataView   = new DataView( source, 0 );
		const data       = new Uint8Array( source, 0 );
		const dataLength = data.length;

		var label     = '';
		var sectionId = 0;
		var legs      = [];

		var lastPosition = new StationPosition(); // value to allow approach vector for xsect coord frame
		var i, j, li, lj;

		// init cmd handler table with error handler for unsupported records or invalid records

		function _errorHandler ( e ) { throw new Error( 'unhandled command: ' + e.toString( 16 ) + ' @ ' + pos.toString( 16 ) ); }

		for ( i = 0; i < 256; i++ ) {

			cmd[ i ] = _errorHandler;

		}

		cmd[ 0x00 ] = cmd_STOP;
		cmd[   -1 ] = cmd_STOP;

		cmd[ 0x01 ] = cmd_SKIP;

		cmd[ 0x02 ] = cmd_LABEL_V1; // version numbers not related to Survex versions
		cmd[ 0x03 ] = cmd_LABEL_V1;

		cmd[ 0x04 ] = cmd_MOVE;
		cmd[ 0x05 ] = cmd_LINE_V1;

		cmd[ 0x06 ] = cmd_LABEL_V2;
		cmd[ 0x07 ] = cmd_LABEL_V3;

		for ( i = 0x40; i < 0x80; i++ ) {

			cmd[ i ] = cmd_LABEL_V4;

		}

		for ( i = 0x80; i < 0x100; i++ ) {

			cmd[ i ] = cmd_LINE_V2;

		}

		// dispatch table end

		// common record iterator
		// loop though data, handling record types as required.

		if ( version === 1 ) {

			while ( pos < dataLength ) {

				const cmdCode = dataView.getInt32( pos, true );
				pos += 4;

				if ( ! cmd[ cmdCode ]() ) break;

			}

		} else {

			alert( 'Unsupported version' + version );

			while ( pos < dataLength ) {

				if ( ! cmd[ data[ pos ] ]( data[ pos++ ] ) ) break;

			}

		}

		groups.push( legs );

		// assign survey ids to all leg vertices by looking up tree node for coords

		for ( i = 0, li = groups.length; i < li; i++ ) {

			const group = groups[ i ];

			for ( j = 0, lj = group.length; j < lj; j++ ) {

				const leg = group[ j ];
				const coords = leg.coords;

				const node = stations.get( coords );

				if ( node === undefined ) continue;

				leg.survey = node.parent.id;

			}

		}

		function cmd_STOP ( /* c */ ) {

			return true;

		}

		function cmd_SKIP ( /* c */ ) {

			console.log( 'SKIP' );
			return false;

		}

		function cmd_LABEL_V1 ( /* c */ ) {

			const db = [];

			var nextByte = data[ pos++ ];

			while ( nextByte !== 10 ) {

				db.push( nextByte );
				nextByte = data[ pos++ ];

			}

			if ( db[ 0 ] === 92 ) db.shift(); // remove initial '/' characters

			label = String.fromCharCode.apply( null, db );

			var node = surveyTree.addLeaf( label.split( '.' ), { p: lastPosition, type: STATION_NORMAL } );

			// track coords to sectionId to allow survey ID's to be added to leg vertices
			stations.set( lastPosition, node );

			return true;

		}

		function cmd_LABEL_V2 ( /* c */ ) {

			console.log( 'LABEL_V2' );
			return false;

		}

		function cmd_LABEL_V3 ( /* c */ ) {

			console.log( 'LABEL_V3' );
			return false;

		}

		function cmd_LABEL_V4 ( /* c */ ) {

			console.log( 'LABEL_V4' );
			return false;

		}

		function cmd_MOVE ( /* c */ ) {

			const coords = readCoordinates();

			lastPosition = coords;

			// lookahead at next command
			if ( version === 1 && dataView.getInt32( pos, true ) === 2 ) {

				// version 1 uses MOVE+LABEL pairs to label stations
				return true;

			}

			if ( legs.length > 1 ) groups.push( legs );

			legs = [];

			legs.push( { coords: coords } );

			return true;

		}

		function cmd_LINE_V1 ( /* c */ ) {

			const coords = readCoordinates();

			legs.push( { coords: coords, type: LEG_CAVE, survey: sectionId } );

			lastPosition.connections++;
			coords.connections++;

			lastPosition = coords;

			return true;

		}

		function cmd_LINE_V2 ( /* c */ ) {

			console.log( 'LINE_V2' );
			return false;

		}

		function readCoordinates () {

			const l = new DataView( source, pos );

			var coords = new StationPosition(
				l.getInt32( 0, true ) / 100,
				l.getInt32( 4, true ) / 100,
				l.getInt32( 8, true ) / 100
			);

			pos += 12;

			const key = coords.x + ',' + coords.y + ',' + coords.z;
			const cachedCoords = stationMap.get( key );

			if ( cachedCoords !== undefined ) {

				coords = cachedCoords;

			} else {

				if ( projection !== null) {

					const projectedCoords = projection.forward( {
						x: coords.x,
						y: coords.y
					} );

					coords.x = projectedCoords.x;
					coords.y = projectedCoords.y;

				}

				limits.expandByPoint( coords );

				stationMap.set( key, coords );

			}

			return coords;

		}

	};

	Svx3dHandler.prototype.handleVx = function ( source, pos, version, section ) {

		const cave       = this.cave;

		const surveyTree = cave.surveyTree;
		const messages   = cave.messages;
		const projection = cave.projection;
		const limits     = cave.limits;

		const groups     = this.groups;
		const xGroups    = [];
		const stationMap = this.stationMap;

		const cmd = [];

		const stations = new Map();

		const data       = new Uint8Array( source, 0 );
		const dataView   = new DataView( source, 0 );
		const dataLength = data.length;

		var legs      = [];
		var label     = '';
		var xSects    = [];
		var sectionId = 0;

		var move = false;
		var lastPosition = new StationPosition();
		var lastKey = null; // map key for last coordinates read

		var lastXSectPosition = new Vector3(); // value to allow approach vector for xsect coord frame
		var i;
		var labelChanged = false;
		var inSection = ( section === null );
		var splayExpected = false; // xsect expected to end on a splay

		var message;

		// functions

		var readLabel;

		// init cmd handler table with error handler for unsupported records or invalid records

		function _errorHandler ( e ) { throw new Error( 'unhandled command: ' + e.toString( 16 ) + ' @ ' + pos.toString( 16 ) ); }

		for ( i = 0; i < 256; i++ ) {

			cmd[ i ] = _errorHandler;

		}

		if ( version === 8 ) {
			// v8 dispatch table start

			cmd[ 0x00 ] = cmd_STYLE;
			cmd[ 0x01 ] = cmd_STYLE;
			cmd[ 0x02 ] = cmd_STYLE;
			cmd[ 0x03 ] = cmd_STYLE;
			cmd[ 0x04 ] = cmd_STYLE;

			cmd[ 0x0f ] = cmd_MOVE;
			cmd[ 0x10 ] = cmd_DATE_NODATE;
			cmd[ 0x11 ] = cmd_DATEV8_1;
			cmd[ 0x12 ] = cmd_DATEV8_2;
			cmd[ 0x13 ] = cmd_DATEV8_3;

			cmd[ 0x1F ] = cmd_ERROR;

			cmd[ 0x30 ] = cmd_XSECT16;
			cmd[ 0x31 ] = cmd_XSECT16;

			cmd[ 0x32 ] = cmd_XSECT32;
			cmd[ 0x33 ] = cmd_XSECT32;

			for ( i = 0x40; i < 0x80; i++ ) {

				cmd[ i ] = cmd_LINE;

			}

			for ( i = 0x80; i < 0x100; i++ ) {

				cmd[ i ] = cmd_LABEL;

			}

			// dispatch table end

			readLabel = readLabelV8;

			// skip v8 file wide flags after header
			pos++;

		} else {

			// dispatch table for v7 format

			for ( i = 0x01; i < 0x0f; i++ ) {

				cmd[ i ] = cmd_TRIM_PLUS;

			}

			cmd[ 0x0f ] = cmd_MOVE;

			for ( i = 0x10; i < 0x20; i++ ) {

				cmd[ i ] = cmd_TRIM;

			}

			cmd[ 0x00 ] = cmd_STOP;
			cmd[ 0x20 ] = cmd_DATE_V7;
			cmd[ 0x21 ] = cmd_DATE2_V7;
			cmd[ 0x23 ] = cmd_DATE3_V7;
			cmd[ 0x24 ] = cmd_DATE_NODATE;
			cmd[ 0x22 ] = cmd_ERROR;

			cmd[ 0x30 ] = cmd_XSECT16;
			cmd[ 0x31 ] = cmd_XSECT16;

			cmd[ 0x32 ] = cmd_XSECT32;
			cmd[ 0x33 ] = cmd_XSECT32;

			for ( i = 0x40; i < 0x80; i++ ) {

				cmd[ i ] = cmd_LABEL;

			}

			for ( i = 0x80; i < 0xc0; i++ ) {

				cmd[ i ] = cmd_LINE;

			}
			// dispatch table end

			readLabel = readLabelV7;

		}

		if ( version >= 4 && version <= 6 ) {

			cmd[ 0x20 ] = cmd_DATE_V4;
			cmd[ 0x21 ] = cmd_DATE2_V4;

		}

		// common record iterator
		// loop though data, handling record types as required.

		while ( pos < dataLength ) {

			if ( ! cmd[ data[ pos ] ]( data[ pos++ ] ) ) break;

		}

		if ( xSects.length > 1 ) {

			xGroups.push( xSects );

		}

		// fake approach vector for initial leg in xSect sequence
		// FIXME = only xsects from current file

		const caveXgroups = cave.xGroups;

		for ( i = 0; i < xGroups.length; i++ ) {

			const group = xGroups[ i ];

			if ( group.length < 2 ) continue;

			const x1 = group[ 0 ];
			const x2 = group[ 1 ];

			// mirror vector from first to second leg
			const start = x1.end;
			const end = x2.end;

			const newStart = new Vector3().copy( start ).multiplyScalar( 2 ).sub( end );

			x1.start = newStart;

			caveXgroups.push( group );

		}

		stationMap.forEach( function ( coords ) { limits.expandByPoint( coords ); } );

		groups.push( legs );

		return;

		function readLabelV7 () {
			// find length of label and read label = v3 - v7 .3d format

			var len = 0;

			switch ( data[ pos ] ) {

			case 0xfe:

				len = dataView.getUint16( pos, true ) + data[ pos ];
				pos += 2;

				break;

			case 0xff:

				len = dataView.getUint32( pos, true );
				pos += 4;

				break;

			default:

				len = data[ pos++ ];

			}

			if ( len === 0 ) return;

			label += String.fromCharCode.apply( null, data.subarray( pos, ( pos += len ) ) );

			labelChanged = true;

			if ( section !== null ) inSection = label.startsWith( section );

			return;

		}

		function readLabelV8 ( flags ) {

			if ( flags & 0x20 ) return false; // no label change

			var b = data[ pos++ ];
			var add = 0;
			var del = 0;

			if ( b !== 0 ) {

				// handle 4b= bit del/add codes
				del = b >> 4; // left most 4 bits
				add = b & 0x0f; // right most 4 bits

			} else {

				// handle 8 bit and 32 bit del/add codes
				b = data[ pos++ ];

				if ( b !== 0xff ) {

					del = b;

				} else {

					del = dataView.getUint32( pos, true );
					pos += 4;

				}

				b = data[ pos++ ];

				if ( b !== 0xff ) {

					add = b;

				} else {

					add = dataView.getUint32( pos, true );
					pos += 4;

				}

			}

			if ( add === 0 && del === 0 ) return;

			if ( del ) label = label.slice( 0, -del );

			if ( add ) {

				label += String.fromCharCode.apply( null, data.subarray( pos, ( pos += add ) ) );

			}

			labelChanged = true;

			if ( section !== null ) inSection = label.startsWith( section );

			return;

		}

		function cmd_STOP ( /* c */ ) {

			if ( label ) label = '';

			return true;

		}

		function cmd_TRIM_PLUS ( c ) { // v7 and previous

			label = label.slice( 0, -16 );

			if ( label.charAt( label.length - 1 ) === '.' ) label = label.slice( 0, -1 ); // strip trailing '.'

			const parts = label.split( '.' );

			parts.splice( -( c ) );
			label = parts.join( '.' );

			if ( label ) label += '.';
			labelChanged = true;

			return true;

		}

		function cmd_TRIM ( c ) { // v7 and previous

			const trim = c - 15;

			label = label.slice( 0, -trim );
			labelChanged = true;

			return true;

		}

		function cmd_DATE_V4 ( /* c */ ) {

			pos += 4;

			return true;

		}

		function cmd_DATE_V7 ( /* c */ ) {

			pos += 2;

			return true;

		}

		function cmd_DATE3_V7 ( /* c */ ) {

			pos += 4;

			return true;

		}

		function cmd_DATE2_V4 ( /* c */ ) {

			pos += 8;

			return true;

		}

		function cmd_DATE2_V7 ( /* c */ ) {

			pos += 3;

			return true;

		}

		function cmd_STYLE ( /* c */ ) {

			return true;

		}

		function cmd_DATEV8_1 ( /* c */ ) {

			pos += 2;

			return true;

		}

		function cmd_DATEV8_2 ( /* c */ ) {

			pos += 3;

			return true;

		}

		function cmd_DATEV8_3 ( /* c */ ) {

			pos += 4;

			return true;
		}

		function cmd_DATE_NODATE ( /* c */ ) {

			return true;

		}

		function cmd_LINE ( c ) {

			const flags = c & 0x3f;

			readLabel( flags );

			if ( labelChanged && label !== '' ) {

				// we have a new section name
				// add it to the survey tree

				sectionId = surveyTree.addPath( label ).id;
				labelChanged = false;

			}

			if ( inSection ) {

				// add start of run of legs
				if ( move ) {

					legs.push( { coords: lastPosition } );
					move = false;

				}

				const thisPosition = readCoordinates();

				if ( thisPosition === lastPosition ) return true;

				if ( flags & 0x01 ) {

					legs.push( { coords: thisPosition, type: LEG_SURFACE, survey: sectionId } );

				} else if ( flags & 0x04 ) {

					lastPosition.splays++;
					legs.push( { coords: thisPosition, type: LEG_SPLAY, survey: sectionId } );

					thisPosition.splays = -1;

				} else {

					// reference count underground legs ignoring splay and surface legs
					// used for topology reconstruction

					lastPosition.connections++;
					thisPosition.connections++;

					legs.push( { coords: thisPosition, type: LEG_CAVE, survey: sectionId } );

				}

				lastPosition = thisPosition;

			} else {

				if ( move ) {

					// correct marking of last position moved to.
					dropLastCoordinates();
					move = false;

				}

				// skip coordinates
				pos += 12;

			}

			return true;

		}

		function cmd_MOVE ( /* c */ ) {

			// new set of line segments
			if ( legs.length > 1 ) groups.push( legs );

			legs = [];

			if ( ! inSection && move ) dropLastCoordinates();

			lastPosition = readCoordinates();

			move = true;

			return true;

		}

		function cmd_ERROR ( /* c */ ) {

			/*

			var l = new DataView( source, pos );

			var legs = l.getInt32( 0, true );
			var length = l.getInt32( 4, true );

			var E = l.getInt32( 8, true );
			var H = l.getInt32( 12, true );
			var V = l.getInt32( 16, true );

			*/

			pos += 20;

			return true;

		}

		function cmd_LABEL ( c ) {

			const flags = c & 0x7f;

			readLabel( 0 );

			if ( ( ! ( flags & 0x0E ) || flags & 0x20 ) || ! inSection ) { // skip surface only stations

				pos += 12; //skip coordinates
				return true;

			}

			const coords = readCoordinates();

			var path = label.split( '.' );

			stations.set( label, coords );

			surveyTree.addLeaf( path, { p: coords, type: ( flags & 0x04 ) ? STATION_ENTRANCE : STATION_NORMAL } );

			return true;

		}

		function cmd_XSECT16 ( c ) {

			const flags = c & 0x01;

			readLabel( flags );

			const l = new DataView( source, pos );

			pos += 8;

			return commonXSECT(
				flags,
				{
					l: l.getInt16( 0, true ) / 100,
					r: l.getInt16( 2, true ) / 100,
					u: l.getInt16( 4, true ) / 100,
					d: l.getInt16( 6, true ) / 100
				}
			);

		}

		function cmd_XSECT32 ( c ) {

			const flags = c & 0x01;

			readLabel( flags );

			const l = new DataView( source, pos );

			pos += 16;

			return commonXSECT(
				flags,
				{
					l: l.getInt32( 0, true ) / 100,
					r: l.getInt32( 0, true ) / 100,
					u: l.getInt32( 0, true ) / 100,
					d: l.getInt32( 0, true ) / 100
				}
			);

		}

		function commonXSECT ( flags, lrud ) {

			if ( section !== null && ! label.startsWith( section ) ) return true;

			const position = stations.get( label );

			if ( ! position ) return true;

			const station = label.split( '.' );

			// get survey path by removing last component of station name
			station.pop();

			const surveyId = surveyTree.getIdByPathArray( station );

			xSects.push( { start: lastXSectPosition, end: position, lrud: lrud, survey: surveyId, type: WALL_SQUARE } );

			// some XSECTS are not flagged as last in passage
			// if a station has only one connection and is not the first in a set of XSECTS
			// it is at the end of a run of legs. Add a break to remove flyback artifacts

			var endRun = false;

			if ( flags ) {

				endRun = true;

			} else if ( position.connections === 1 && xSects.length > 1 && ! lastPosition.connections == 0 ) {

				message = {
					station: label,
					text: 'LRUD fault'
				};

				if ( position.splays === 0 ) {

					endRun = true;
					messages.push( message );

				} else {

					// expecting next is a splay
					splayExpected = true;

				}

			} else if ( splayExpected && position.connections !== 0 ) {

				messages.push( message );

				splayExpected = false;

			}

			if ( endRun ) {

				if ( xSects.length > 0 ) xGroups.push( xSects );

				lastXSectPosition = new Vector3();
				xSects = [];
				splayExpected = false;

			} else {

				lastXSectPosition = position;

			}

			return true;

		}

		function readCoordinates () {

			const l = new DataView( source, pos );

			lastKey = String.fromCharCode.apply( null, data.subarray( pos, pos + 12 ) );

			var coords = new StationPosition(
				l.getInt32( 0, true ) / 100,
				l.getInt32( 4, true ) / 100,
				l.getInt32( 8, true ) / 100
			);

			pos += 12;

			const cachedCoords = stationMap.get( lastKey );

			if ( cachedCoords !== undefined ) {

				coords = cachedCoords;

			} else {

				if ( projection !== null) {

					const projectedCoords = projection.forward( {
						x: coords.x,
						y: coords.y
					} );

					coords.x = projectedCoords.x;
					coords.y = projectedCoords.y;

				}

				stationMap.set( lastKey, coords );

			}

			return coords;

		}

		function dropLastCoordinates () {

			// don't drop coordinates we know are in the section being extracted
			if ( lastPosition.connections ) return;

			stationMap.delete( lastKey );

		}

	};

	Svx3dHandler.prototype.getLineSegments = function () {

		const lineSegments = [];
		const groups = this.groups;

		for ( var i = 0, l = groups.length; i < l; i++ ) {

			const g = groups[ i ];

			for ( var v = 0, vMax = g.length - 1; v < vMax; v++ ) {

				// create vertex pairs for each line segment.
				// all vertices except first and last are duplicated.
				const from = g[ v ];
				const to   = g[ v + 1 ];

				const fromCoords = from.coords;
				const toCoords = to.coords;

				lineSegments.push( { from: fromCoords, to: toCoords, type: to.type, survey: to.survey } );

			}

		}

		return lineSegments;

	};

	Svx3dHandler.prototype.getTerrainDimensions = function () {

		return { lines: 0, samples: 0 };

	};

	Svx3dHandler.prototype.getTerrainBitmap = function () {

		return false;

	};

	var modelOffset = 0;

	function loxHandler ( fileName ) {

		this.fileName = fileName;

	}

	loxHandler.prototype.constructor = loxHandler;

	loxHandler.prototype.type = 'arraybuffer';

	loxHandler.prototype.parse = function ( cave, dataStream, metadata, section ) {

		modelOffset += 100000;

		cave.metadata = metadata;

		cave.setCRS( null );

		const lineSegments = cave.lineSegments;
		const surveyTree   = cave.surveyTree;
		const limits       = cave.limits;
		const projection   = cave.projection;

		const xSects  = [];
		const terrain = {};

		const skipTerrain = ( projection !== null );

		// polyfilled for IE11, or otherwise not available.
		const utf8Decoder = new TextDecoder( 'utf-8' );

		// assumes little endian data ATM - FIXME

		var source = dataStream;

		const l = source.byteLength;
		const idOffset = modelOffset;
		const stations = [];

		var pos = 0; // file position
		var dataStart;
		var f = new DataView( source, 0 );

		var sectionId = 0;
		var lastParentId;
		var parentNode;

		// read file and parse chunk by chunk

		while ( pos < l ) readChunkHdr();

		// Drop data to give GC a chance ASAP

		source = null;

		cave.addStations( stations );

		cave.addXsects( xSects );

		return Promise.resolve( cave );

		// .lox parsing functions

		function readChunkHdr () {

			const m_type     = readUint();
			const m_recSize  = readUint();
			const m_recCount = readUint();
			const m_dataSize = readUint();

			var doFunction;

			// offset of data region for out of line strings/images/scrap data.
			dataStart = pos + m_recSize;

			switch ( m_type ) {

			case 1:

				doFunction = readSurvey;

				break;

			case 2:

				doFunction = readStation;

				break;

			case 3:

				doFunction = readShot;

				break;

			case 4:

				doFunction = readScrap;

				break;

			case 5:

				doFunction = readSurface;

				break;

			case 6:

				doFunction = readSurfaceBMP;

				break;

			default:

				throw new Error( 'unknown chunk header. type : ', m_type );

			}

			for ( var i = 0; i < m_recCount; i++ ) doFunction();

			pos += m_dataSize;

		}

		function readUint () {

			const i = f.getUint32( pos, true );

			pos += 4;

			return i;

		}

		function readFloat64 () {

			const i = f.getFloat64( pos, true );

			pos += 8;

			return i;

		}

		function readDataPtr () {

			const m_position = readUint();
			const m_size     = readUint();

			return { position: m_position, size: m_size };

		}

		function readString ( ptr ) {

			// strings are null terminated. Ignore last byte in string
			const bytes = new Uint8Array( source, dataStart + ptr.position, ptr.size - 1 );

			return utf8Decoder.decode( bytes );

		}

		function readSurvey () {

			const m_id     = readUint();
			const namePtr  = readDataPtr();
			const m_parent = readUint();
			const titlePtr = readDataPtr();

			if ( lastParentId !== m_parent ) {

				parentNode = surveyTree.findById( ( lastParentId === undefined ) ? 0 : m_parent + idOffset );
				lastParentId = m_parent;

				if ( parentNode === undefined ) parentNode = surveyTree;

			}

			if ( m_parent != m_id ) {

				const node = parentNode.addById( readString( namePtr ), m_id + idOffset );

				if ( node === null ) throw new Error( 'error constructing survey tree for', readString( titlePtr ) );

				if ( section !== null && node.getPath() === section ) {

					sectionId = m_id;

				}

			}

		}

		function readStation () {

			const m_id       = readUint();
			const m_surveyId = readUint();
			const namePtr    = readDataPtr();
			const commentPtr = readDataPtr();

			const m_flags = readUint();
			const coords = readCoords();

			stations[ m_id ] = coords;

			// add stations to surveyTree make station id negative to avoid clashes with survey id space.

			// m_flags & 0x01 = surface

			if ( lastParentId !== m_surveyId ) {

				parentNode = surveyTree.findById( m_surveyId + idOffset );
				lastParentId = m_surveyId;

			}

			const name = ( namePtr.size === 0 ) ? '[' + m_id + ']' : readString( namePtr );
			const obj = { p: coords, type: ( m_flags & 0x02 ) ? STATION_ENTRANCE : STATION_NORMAL };

			if ( commentPtr.size > 0 ) obj.comment = readString( commentPtr );

			parentNode.addById( name, - ( m_id + idOffset ), obj );

		}

		function readCoords () {

			const coords = new StationPosition(
				readFloat64(),
				readFloat64(),
				readFloat64()
			);

			if ( projection !== null ) {

				const projectedCoords = projection.forward( {
					x: coords.x,
					y: coords.y
				} );

				coords.x = projectedCoords.x;
				coords.y = projectedCoords.y;

			}

			limits.expandByPoint( coords );

			return coords;

		}

		function readShot () {

			const m_from_r = readUint();
			const m_to_r   = readUint();

			var m_from, m_to, fromLRUD, toLRUD;

			if ( m_to_r > m_from_r ) {

				m_from = m_from_r;
				m_to = m_to_r;
				fromLRUD = readLrudForward();
				toLRUD   = readLrudForward();

			} else {

				m_from = m_to_r;
				m_to = m_from_r;
				toLRUD   = readLrudReverse();
				fromLRUD = readLrudReverse();

			}

			const m_flags       = readUint();
			const m_sectionType = readUint();
			const m_surveyId    = readUint();

			pos += 8; // readFloat64(); // m_threshold

			if ( sectionId !== 0 && m_surveyId !== sectionId ) return;

			var type = LEG_CAVE;

			if ( m_flags & 0x01 ) type = LEG_SURFACE;
			if ( m_flags & 0x08 ) type = LEG_SPLAY;

			const from = stations[ m_from ];
			const to   = stations[ m_to ];

			/*
			.lox section types

			LXFILE_SHOT_SECTION_NONE 0
			LXFILE_SHOT_SECTION_OVAL 1
			LXFILE_SHOT_SECTION_SQUARE 2
			LXFILE_SHOT_SECTION_DIAMOND 3
			LXFILE_SHOT_SECTION_TUNNEL 4
			*/

			const surveyId = m_surveyId + idOffset;

			if ( m_sectionType !== 0x00 && type === LEG_CAVE ) {

				xSects.push( { m_from: m_from, m_to: m_to, start: from, end: to, fromLRUD: fromLRUD, lrud: toLRUD, survey: surveyId, type: m_sectionType } );

			}

			// omit zero length legs

			if ( from.equals( to ) ) return;

			if ( type === LEG_CAVE ) {

				from.connections++;
				to.connections++;

			}

			lineSegments.push( { from: from, to: to, type: type, survey: surveyId } );

		}

		function readLrudForward () {

			return {
				l: readFloat64(),
				r: readFloat64(),
				u: readFloat64(),
				d: readFloat64()
			};

		}

		function readLrudReverse () {

			return {
				r: readFloat64(),
				l: readFloat64(),
				u: readFloat64(),
				d: readFloat64()
			};

		}

		function readScrap () {

			readUint(); // m_id

			const m_surveyId   = readUint();

			const m_numPoints  = readUint();
			const pointsPtr    = readDataPtr();

			const m_num3Angles = readUint();
			const facesPtr     = readDataPtr();

			const scrap = { vertices: [], faces: [], survey: m_surveyId + idOffset };

			var lastFace;
			var i, j;

			if ( sectionId !== 0 && m_surveyId !== sectionId ) return;

			for ( i = 0; i < m_numPoints; i++ ) {

				const offset = dataStart + pointsPtr.position + i * 24; // 24 = 3 * sizeof( double )
				const f = new DataView( source, offset );

				scrap.vertices.push( new Vector3(
					f.getFloat64( 0,  true ),
					f.getFloat64( 8,  true ),
					f.getFloat64( 16, true )
				) );

			}

			// read faces from out of line data area

			for ( i = 0; i < m_num3Angles; i++ ) {

				const offset = dataStart + facesPtr.position + i * 12; // 12 = 3 * sizeof( uint32 )
				const f = new DataView( source, offset );

				const face = [
					f.getUint32( 0, true ),
					f.getUint32( 4, true ),
					f.getUint32( 8, true )
				];

				// check for face winding order == orientation

				fix_direction: { if ( lastFace !== undefined ) {

					for ( j = 0; j < 3; j++ ) { // this case triggers more often than those below.

						if ( face[ j ] == lastFace[ ( j + 2 ) % 3 ] && face[ ( j + 1 ) % 3 ] == lastFace[ ( j + 3 ) % 3 ] ) {

							face.reverse();
							break fix_direction;

						}

					}

					for ( j = 0; j < 3; j++ ) {

						if ( face[ j ] == lastFace[ j ] && face[ ( j + 1 ) % 3 ] == lastFace[ ( j + 1 ) % 3 ] ) {

							face.reverse();
							break fix_direction;

						}

					}

					for ( j = 0; j < 3; j++ ) {

						if ( face[ j ] == lastFace[ ( j + 1 ) % 3 ] && face[ ( j + 1 ) % 3 ] == lastFace[ ( j + 2 ) % 3 ] ) {

							face.reverse();
							break fix_direction;

						}

					}

				} }

				scrap.faces.push( face );
				lastFace = face;

			}

			cave.scraps.push( scrap );

		}

		function readSurface () {

			readUint(); // m_id

			const m_width  = readUint();
			const m_height = readUint();

			const surfacePtr = readDataPtr();
			const m_calib    = readCalibration();

			if ( skipTerrain ) return;

			const ab = source.slice( pos, pos + surfacePtr.size ); // required for 64b alignment

			const dtm = new Float64Array( ab, 0 );

			terrain.dtm = {
				data: dtm,
				samples: m_width,
				lines:   m_height,
				calib:   m_calib
			};

			cave.terrains.push( terrain );
			cave.hasTerrain = true;

		}

		function readCalibration () {

			const xOrigin =	readFloat64(); // x origin
			const yOrigin =	readFloat64(); // y origin
			const xx = readFloat64(); // xx ( 2 x 2 ) rotate and scale matrix
			const xy = readFloat64(); // xy "
			const yx = readFloat64(); // yx "
			const yy = readFloat64(); // yy "

			return {
				xOrigin: xOrigin,
				yOrigin: yOrigin,
				xx: xx,
				xy: xy,
				yx: yx,
				yy: yy
			};

		}

		function readSurfaceBMP () {

			readUint(); // m_type
			readUint(); // m_surfaceId

			const imagePtr = readDataPtr();
			const m_calib = readCalibration();

			if ( skipTerrain ) return;

			terrain.bitmap = {
				image: extractImage( imagePtr ),
				calib: m_calib
			};

		}

		function extractImage ( imagePtr ) {

			const imgData = new Uint8Array( source, dataStart + imagePtr.position, imagePtr.size );

			const b1 = imgData[ 0 ];
			const b2 = imgData[ 1 ];

			var type;

			if ( b1 === 0xff && b2 === 0xd8 ) {

				type = 'image/jpeg';

			} else if ( b1 === 0x89 && b2 === 0x50 ) {

				type = 'image/png';

			} else {

				return '';

			}

			const blob = new Blob( [ imgData ], { type: type } );

			return URL.createObjectURL( blob );

		}

	};

	const ftom = 12 * 0.0254;

	function pltHandler ( fileName ) {

		this.fileName = fileName;

	}

	pltHandler.prototype.constructor = pltHandler;

	pltHandler.prototype.type = 'text';

	pltHandler.prototype.parse = function ( cave, dataStream, metadata /*, section */ ) {

		cave.metadata = metadata;

		cave.setCRS( null );

		const surveyTree  = cave.surveyTree;
		const limits      = cave.limits;
		const projection  = cave.projection;

		const stationMap  = new Map();
		const xSects      = [];
		const stations    = [];
		const groups      = [];

		const lines = dataStream.split( /[\n\r]+/ );
		const l = lines.length;

		var path = [];
		var segments = [];
		var stationName;
		var surveyName;
		var surveyId = 0;
		var lastStationIndex = -1;
		var section = 'root';
		var lrud, i, stationIndex, coords;

		for ( i = 0; i < l; i++ ) {

			const parts = lines[ i ].split( /\s+/ );

			const cmd = parts[ 0 ].charAt( 0 );

			switch ( cmd ) {

			case 'M': // move

				if ( segments.length > 1 ) groups.push( segments );

				segments = [];
				lastStationIndex = -1;

			case 'D': // eslint-disable-line no-fallthrough

				stationName = parts[ 4 ].substring( 1 );

				path[ 2 ] = stationName;

				coords = readCoords( parts );
				stationIndex = coords.stationIndex;

				segments.push( { coords: coords, type: LEG_CAVE, survey: surveyId } );

				if ( coords.connections === 0 ) {

					const obj = { p: coords, type: STATION_NORMAL };

					// parse comment
					if ( parts[ 13 ] !== undefined ) obj.comment = parts.slice( 13 ).join( ' ' );

					surveyTree.addLeaf( path, obj );

				}

				coords.connections++;

				if ( parts[ 5 ] === 'P' ) {

					let l = +parts[ 6 ];
					let u = +parts[ 7 ];
					let d = +parts[ 8 ];
					let r = +parts[ 9 ];

					let nCount = 0;

					if ( l < 0 ) { l = 0; nCount++; }
					if ( u < 0 ) { u = 0; nCount++; }
					if ( d < 0 ) { d = 0; nCount++; }
					if ( r < 0 ) { r = 0; nCount++; }

					if ( nCount !== 4 ) {

						lrud = {
							l: l * ftom,
							u: u * ftom,
							d: d * ftom,
							r: r * ftom
						};

						var from = ( lastStationIndex !== -1 ) ? stations[ lastStationIndex ] : null;

						xSects.push( { m_from: lastStationIndex, m_to: stationIndex, start: from, end: coords, lrud: lrud, survey: surveyId, type: 2  } );

					}

					lastStationIndex = stationIndex;

				}

				break;

			case 'N': // line survey

				surveyName = parts[ 0 ].substring( 1 );

				path = [ section, surveyName ];
				surveyId = surveyTree.addPath( section + '.' + surveyName ).id;

				break;

			case 'Z': // end of survey

				/*
				limits.min.set(
					+parts[ 3 ],
					+parts[ 1 ],
					+parts[ 5 ]
				);

				limits.max.set(
					+parts[ 4 ],
					+parts[ 2 ],
					+parts[ 6 ]
				);
				*/

				break;

			case 'F': // feature survey
			case 'L': // feature location
			case 'X': // end of survey
			case 'O': // Datum
			case 'G': // UTM Zone
			case 'P': // fixed point
			case 'R': // loop spec
			case 'C': // loop count
			case '\x1A': // end of file

				break;

			case 'S':

				section = lines[ i ].substring( 1 );
				break;

			default:

				console.log( 'unknown command ', cmd );

			}

		}

		if ( segments.length > 1 ) groups.push( segments );

		cave.addStations( stations );

		cave.addLineSegments( groups );

		cave.addXsects( xSects );

		return Promise.resolve( cave );

		function readCoords( parts ) {

			const lastKey = parts[ 1 ] + ':' + parts[ 2 ] + ':' + parts[ 3 ];
			const cachedCoords = stationMap.get( lastKey );

			var coords;

			if ( cachedCoords !== undefined ) {

				coords = cachedCoords;

			} else {

				coords = new StationPosition(
					+parts[ 2 ] * ftom,
					+parts[ 1 ] * ftom,
					+parts[ 3 ] * ftom
				);

				if ( projection !== null ) {

					const projectedCoords = projection.forward( {
						x: coords.x,
						y: coords.y
					} );

					coords.x = projectedCoords.x;
					coords.y = projectedCoords.y;

				}

				coords.stationIndex = stations.length;

				stations.push( coords );
				stationMap.set( lastKey, coords );

				limits.expandByPoint( coords );

			}

			return coords;

		}

	};

	function Tree( name, id, root, parent ) { // root parameter only used internally

		if ( root === undefined ) {

			this.id = 0;
			this.maxId = 0;
			this.root = this;
			this.parent = null;
			this.pathCache = [];

		} else {

			this.root = root;
			this.parent = parent;
			this.id = ( id === null ) ? ++root.maxId : id;

			parent.children.push( this );

		}

		this.name = name || '';
		this.children = [];

	}

	Tree.prototype.sorted = false;

	Tree.prototype.traverse = function ( func ) {

		const children = this.children;

		func ( this );

		for ( var i = 0; i < children.length; i++ ) {

			children[ i ].traverse( func );

		}

	};

	Tree.prototype.traverseDepthFirst = function ( func ) {

		const children = this.children;

		for ( var i = 0; i < children.length; i++ ) {

			children[ i ].traverseDepthFirst( func );

		}

		func ( this );

	};

	Tree.prototype.forEachChild = function ( func ) {

		const children = this.children;

		for ( var i = 0; i < children.length; i++ ) {

			func( children[ i ] );

		}

	};

	Tree.prototype.addById = function ( name, id, properties ) {

		const root = this.root;
		const node = new Tree( name, id, root, this );

		if ( properties !== undefined ) Object.assign( node, properties );

		root.maxId = Math.max( root.maxId, id );

		return node;

	};

	Tree.prototype.findById = function ( id ) {

		if ( this.id == id ) return this;

		for ( var i = 0, l = this.children.length; i < l; i++ ) {

			const found = this.children[ i ].findById( id );

			if ( found ) return found;

		}

		return undefined;

	};

	Tree.prototype.getByPath = function ( path ) {

		const pathArray = path.split( '.' );
		const node = this.getByPathArray( pathArray );

		return ( pathArray.length === 0 ) ? node: undefined;

	};

	Tree.prototype.getByPathArray = function ( path ) {

		var node = this.root;
		var search = true;

		while ( search && path.length > 0 ) {

			search = false;

			for ( var i = 0, l = node.children.length; i < l; i++ ) {

				const child = node.children[ i ];

				if ( child.name === path[ 0 ] ) {

					node = child;
					path.shift();
					search = true;

					break;

				}

			}

		}

		return node;

	};

	Tree.prototype.addLeaf = function ( path, properties ) {

		// short cut for flat surveys with little tree structure
		if ( path.length === 1 ) {

			const newNode = new Tree( path[ 0 ], null, this.root, this );

			if ( properties !== undefined ) Object.assign( newNode, properties );

			return newNode;

		}

		// find part of path that exists already using cache

		var node;
		var leaf = [];

		while ( node === undefined && path.length > 1 ) {

			leaf.unshift( path.pop() );
			node = this.root.pathCache[ path.join( '.' ) ];

		}

		// we have a valid path - attach the leaf here

		if ( node !== undefined) {

			const newNode = new Tree( leaf.join( '.' ), null, this.root, node );

			if ( properties !== undefined ) Object.assign( newNode, properties );

			return newNode;

		}

		// fallback in case path not created

		path = path.concat( leaf );

		node = this.getByPathArray( path );

		if ( path.length === 0 ) return node;

		// add remainder of path to node

		while ( path.length > 0 ) {

			const newNode = new Tree( path.shift(), null, this.root, node );

			node = newNode;

		}

		if ( properties !== undefined ) Object.assign( node, properties );

		return node;

	};

	Tree.prototype.addPath = function ( path ) {

		// find part of path that exists already
		var pathArray = path.split( '.' );

		var node = this.getByPathArray( pathArray );

		if ( pathArray.length === 0 ) return node;

		// add remainder of path to node

		while ( pathArray.length > 0 ) {

			const newNode = new Tree( pathArray.shift(), null, this.root, node );

			this.root.pathCache[ newNode.getPath() ] = newNode;

			node = newNode;

		}

		return node;

	};

	Tree.prototype.getPath = function ( endNode ) {

		const path = [];

		var node = this;

		if ( endNode === undefined ) endNode = this.root;

		do {

			path.push( node.name );
			node = node.parent;

		} while ( node !== endNode && node !== null );

		return path.reverse().join( '.' );

	};

	Tree.prototype.getSubtreeIds = function ( idSet ) {

		this.traverse( _getId );

		function _getId( node ) {

			idSet.add( node.id );

		}

		return idSet;

	};

	Tree.prototype.getIdByPath = function ( path ) {

		return this.getIdByPathArray( path.split( '.' ) );

	};

	Tree.prototype.getIdByPathArray = function ( array ) {

		const node = this.getByPathArray( array );

		if ( array.length === 0 ) {

			return node.id;

		} else {

			return undefined;

		}

	};

	Tree.prototype.trim = function ( path ) {

		const prefix = path.shift();
		const children = this.children;

		var child;

		if ( prefix === undefined ) return;

		for ( var i = 0; i < children.length; i++ ) {

			child = children[ i ];

			if ( child.name === prefix ) break;

		}

		this.children = [ child ];

		child.trim( path );

	};

	Tree.prototype.isStation = function () {

		return ( this.p !== undefined );

	};

	function globals(defs) {
	  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
	  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
	  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

	  defs.WGS84 = defs['EPSG:4326'];
	  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
	  defs.GOOGLE = defs['EPSG:3857'];
	  defs['EPSG:900913'] = defs['EPSG:3857'];
	  defs['EPSG:102113'] = defs['EPSG:3857'];
	}

	var PJD_3PARAM = 1;
	var PJD_7PARAM = 2;
	var PJD_GRIDSHIFT = 3;
	var PJD_WGS84 = 4; // WGS84 or equivalent
	var PJD_NODATUM = 5; // WGS84 or equivalent
	var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
	var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
	var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
	var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
	var HALF_PI = Math.PI/2;
	// ellipoid pj_set_ell.c
	var SIXTH = 0.1666666666666666667;
	/* 1/6 */
	var RA4 = 0.04722222222222222222;
	/* 17/360 */
	var RA6 = 0.02215608465608465608;
	var EPSLN = 1.0e-10;
	// you'd think you could use Number.EPSILON above but that makes
	// Mollweide get into an infinate loop.

	var D2R = 0.01745329251994329577;
	var R2D = 57.29577951308232088;
	var FORTPI = Math.PI/4;
	var TWO_PI = Math.PI * 2;
	// SPI is slightly greater than Math.PI, so values that exceed the -180..180
	// degree range by a tiny amount don't get wrapped. This prevents points that
	// have drifted from their original location along the 180th meridian (due to
	// floating point error) from changing their sign.
	var SPI = 3.14159265359;

	var exports$1 = {};

	exports$1.greenwich = 0.0; //"0dE",
	exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
	exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
	exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
	exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
	exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
	exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
	exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
	exports$1.ferro = -17.666666666667; //"17d40'W",
	exports$1.brussels = 4.367975; //"4d22'4.71\"E",
	exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
	exports$1.athens = 23.7163375; //"23d42'58.815\"E",
	exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"

	var units = {
	  ft: {to_meter: 0.3048},
	  'us-ft': {to_meter: 1200 / 3937}
	};

	var ignoredChar = /[\s_\-\/\(\)]/g;
	function match(obj, key) {
	  if (obj[key]) {
	    return obj[key];
	  }
	  var keys = Object.keys(obj);
	  var lkey = key.toLowerCase().replace(ignoredChar, '');
	  var i = -1;
	  var testkey, processedKey;
	  while (++i < keys.length) {
	    testkey = keys[i];
	    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
	    if (processedKey === lkey) {
	      return obj[testkey];
	    }
	  }
	}

	function projStr(defData) {
	  var self = {};
	  var paramObj = defData.split('+').map(function(v) {
	    return v.trim();
	  }).filter(function(a) {
	    return a;
	  }).reduce(function(p, a) {
	    var split = a.split('=');
	    split.push(true);
	    p[split[0].toLowerCase()] = split[1];
	    return p;
	  }, {});
	  var paramName, paramVal, paramOutname;
	  var params = {
	    proj: 'projName',
	    datum: 'datumCode',
	    rf: function(v) {
	      self.rf = parseFloat(v);
	    },
	    lat_0: function(v) {
	      self.lat0 = v * D2R;
	    },
	    lat_1: function(v) {
	      self.lat1 = v * D2R;
	    },
	    lat_2: function(v) {
	      self.lat2 = v * D2R;
	    },
	    lat_ts: function(v) {
	      self.lat_ts = v * D2R;
	    },
	    lon_0: function(v) {
	      self.long0 = v * D2R;
	    },
	    lon_1: function(v) {
	      self.long1 = v * D2R;
	    },
	    lon_2: function(v) {
	      self.long2 = v * D2R;
	    },
	    alpha: function(v) {
	      self.alpha = parseFloat(v) * D2R;
	    },
	    lonc: function(v) {
	      self.longc = v * D2R;
	    },
	    x_0: function(v) {
	      self.x0 = parseFloat(v);
	    },
	    y_0: function(v) {
	      self.y0 = parseFloat(v);
	    },
	    k_0: function(v) {
	      self.k0 = parseFloat(v);
	    },
	    k: function(v) {
	      self.k0 = parseFloat(v);
	    },
	    a: function(v) {
	      self.a = parseFloat(v);
	    },
	    b: function(v) {
	      self.b = parseFloat(v);
	    },
	    r_a: function() {
	      self.R_A = true;
	    },
	    zone: function(v) {
	      self.zone = parseInt(v, 10);
	    },
	    south: function() {
	      self.utmSouth = true;
	    },
	    towgs84: function(v) {
	      self.datum_params = v.split(",").map(function(a) {
	        return parseFloat(a);
	      });
	    },
	    to_meter: function(v) {
	      self.to_meter = parseFloat(v);
	    },
	    units: function(v) {
	      self.units = v;
	      var unit = match(units, v);
	      if (unit) {
	        self.to_meter = unit.to_meter;
	      }
	    },
	    from_greenwich: function(v) {
	      self.from_greenwich = v * D2R;
	    },
	    pm: function(v) {
	      var pm = match(exports$1, v);
	      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
	    },
	    nadgrids: function(v) {
	      if (v === '@null') {
	        self.datumCode = 'none';
	      }
	      else {
	        self.nadgrids = v;
	      }
	    },
	    axis: function(v) {
	      var legalAxis = "ewnsud";
	      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
	        self.axis = v;
	      }
	    },
	    approx: function() {
	      self.approx = true;
	    }
	  };
	  for (paramName in paramObj) {
	    paramVal = paramObj[paramName];
	    if (paramName in params) {
	      paramOutname = params[paramName];
	      if (typeof paramOutname === 'function') {
	        paramOutname(paramVal);
	      }
	      else {
	        self[paramOutname] = paramVal;
	      }
	    }
	    else {
	      self[paramName] = paramVal;
	    }
	  }
	  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
	    self.datumCode = self.datumCode.toLowerCase();
	  }
	  return self;
	}

	var NEUTRAL = 1;
	var KEYWORD = 2;
	var NUMBER = 3;
	var QUOTED = 4;
	var AFTERQUOTE = 5;
	var ENDED = -1;
	var whitespace = /\s/;
	var latin = /[A-Za-z]/;
	var keyword = /[A-Za-z84]/;
	var endThings = /[,\]]/;
	var digets = /[\d\.E\-\+]/;
	// const ignoredChar = /[\s_\-\/\(\)]/g;
	function Parser(text) {
	  if (typeof text !== 'string') {
	    throw new Error('not a string');
	  }
	  this.text = text.trim();
	  this.level = 0;
	  this.place = 0;
	  this.root = null;
	  this.stack = [];
	  this.currentObject = null;
	  this.state = NEUTRAL;
	}
	Parser.prototype.readCharicter = function() {
	  var char = this.text[this.place++];
	  if (this.state !== QUOTED) {
	    while (whitespace.test(char)) {
	      if (this.place >= this.text.length) {
	        return;
	      }
	      char = this.text[this.place++];
	    }
	  }
	  switch (this.state) {
	    case NEUTRAL:
	      return this.neutral(char);
	    case KEYWORD:
	      return this.keyword(char)
	    case QUOTED:
	      return this.quoted(char);
	    case AFTERQUOTE:
	      return this.afterquote(char);
	    case NUMBER:
	      return this.number(char);
	    case ENDED:
	      return;
	  }
	};
	Parser.prototype.afterquote = function(char) {
	  if (char === '"') {
	    this.word += '"';
	    this.state = QUOTED;
	    return;
	  }
	  if (endThings.test(char)) {
	    this.word = this.word.trim();
	    this.afterItem(char);
	    return;
	  }
	  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
	};
	Parser.prototype.afterItem = function(char) {
	  if (char === ',') {
	    if (this.word !== null) {
	      this.currentObject.push(this.word);
	    }
	    this.word = null;
	    this.state = NEUTRAL;
	    return;
	  }
	  if (char === ']') {
	    this.level--;
	    if (this.word !== null) {
	      this.currentObject.push(this.word);
	      this.word = null;
	    }
	    this.state = NEUTRAL;
	    this.currentObject = this.stack.pop();
	    if (!this.currentObject) {
	      this.state = ENDED;
	    }

	    return;
	  }
	};
	Parser.prototype.number = function(char) {
	  if (digets.test(char)) {
	    this.word += char;
	    return;
	  }
	  if (endThings.test(char)) {
	    this.word = parseFloat(this.word);
	    this.afterItem(char);
	    return;
	  }
	  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
	};
	Parser.prototype.quoted = function(char) {
	  if (char === '"') {
	    this.state = AFTERQUOTE;
	    return;
	  }
	  this.word += char;
	  return;
	};
	Parser.prototype.keyword = function(char) {
	  if (keyword.test(char)) {
	    this.word += char;
	    return;
	  }
	  if (char === '[') {
	    var newObjects = [];
	    newObjects.push(this.word);
	    this.level++;
	    if (this.root === null) {
	      this.root = newObjects;
	    } else {
	      this.currentObject.push(newObjects);
	    }
	    this.stack.push(this.currentObject);
	    this.currentObject = newObjects;
	    this.state = NEUTRAL;
	    return;
	  }
	  if (endThings.test(char)) {
	    this.afterItem(char);
	    return;
	  }
	  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
	};
	Parser.prototype.neutral = function(char) {
	  if (latin.test(char)) {
	    this.word = char;
	    this.state = KEYWORD;
	    return;
	  }
	  if (char === '"') {
	    this.word = '';
	    this.state = QUOTED;
	    return;
	  }
	  if (digets.test(char)) {
	    this.word = char;
	    this.state = NUMBER;
	    return;
	  }
	  if (endThings.test(char)) {
	    this.afterItem(char);
	    return;
	  }
	  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
	};
	Parser.prototype.output = function() {
	  while (this.place < this.text.length) {
	    this.readCharicter();
	  }
	  if (this.state === ENDED) {
	    return this.root;
	  }
	  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
	};

	function parseString(txt) {
	  var parser = new Parser(txt);
	  return parser.output();
	}

	function mapit(obj, key, value) {
	  if (Array.isArray(key)) {
	    value.unshift(key);
	    key = null;
	  }
	  var thing = key ? {} : obj;

	  var out = value.reduce(function(newObj, item) {
	    sExpr(item, newObj);
	    return newObj
	  }, thing);
	  if (key) {
	    obj[key] = out;
	  }
	}

	function sExpr(v, obj) {
	  if (!Array.isArray(v)) {
	    obj[v] = true;
	    return;
	  }
	  var key = v.shift();
	  if (key === 'PARAMETER') {
	    key = v.shift();
	  }
	  if (v.length === 1) {
	    if (Array.isArray(v[0])) {
	      obj[key] = {};
	      sExpr(v[0], obj[key]);
	      return;
	    }
	    obj[key] = v[0];
	    return;
	  }
	  if (!v.length) {
	    obj[key] = true;
	    return;
	  }
	  if (key === 'TOWGS84') {
	    obj[key] = v;
	    return;
	  }
	  if (key === 'AXIS') {
	    if (!(key in obj)) {
	      obj[key] = [];
	    }
	    obj[key].push(v);
	    return;
	  }
	  if (!Array.isArray(key)) {
	    obj[key] = {};
	  }

	  var i;
	  switch (key) {
	    case 'UNIT':
	    case 'PRIMEM':
	    case 'VERT_DATUM':
	      obj[key] = {
	        name: v[0].toLowerCase(),
	        convert: v[1]
	      };
	      if (v.length === 3) {
	        sExpr(v[2], obj[key]);
	      }
	      return;
	    case 'SPHEROID':
	    case 'ELLIPSOID':
	      obj[key] = {
	        name: v[0],
	        a: v[1],
	        rf: v[2]
	      };
	      if (v.length === 4) {
	        sExpr(v[3], obj[key]);
	      }
	      return;
	    case 'PROJECTEDCRS':
	    case 'PROJCRS':
	    case 'GEOGCS':
	    case 'GEOCCS':
	    case 'PROJCS':
	    case 'LOCAL_CS':
	    case 'GEODCRS':
	    case 'GEODETICCRS':
	    case 'GEODETICDATUM':
	    case 'EDATUM':
	    case 'ENGINEERINGDATUM':
	    case 'VERT_CS':
	    case 'VERTCRS':
	    case 'VERTICALCRS':
	    case 'COMPD_CS':
	    case 'COMPOUNDCRS':
	    case 'ENGINEERINGCRS':
	    case 'ENGCRS':
	    case 'FITTED_CS':
	    case 'LOCAL_DATUM':
	    case 'DATUM':
	      v[0] = ['name', v[0]];
	      mapit(obj, key, v);
	      return;
	    default:
	      i = -1;
	      while (++i < v.length) {
	        if (!Array.isArray(v[i])) {
	          return sExpr(v, obj[key]);
	        }
	      }
	      return mapit(obj, key, v);
	  }
	}

	var D2R$1 = 0.01745329251994329577;



	function rename(obj, params) {
	  var outName = params[0];
	  var inName = params[1];
	  if (!(outName in obj) && (inName in obj)) {
	    obj[outName] = obj[inName];
	    if (params.length === 3) {
	      obj[outName] = params[2](obj[outName]);
	    }
	  }
	}

	function d2r(input) {
	  return input * D2R$1;
	}

	function cleanWKT(wkt) {
	  if (wkt.type === 'GEOGCS') {
	    wkt.projName = 'longlat';
	  } else if (wkt.type === 'LOCAL_CS') {
	    wkt.projName = 'identity';
	    wkt.local = true;
	  } else {
	    if (typeof wkt.PROJECTION === 'object') {
	      wkt.projName = Object.keys(wkt.PROJECTION)[0];
	    } else {
	      wkt.projName = wkt.PROJECTION;
	    }
	  }
	  if (wkt.AXIS) {
	    var axisOrder = '';
	    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
	      var axis = wkt.AXIS[i];
	      var descriptor = axis[0].toLowerCase();
	      if (descriptor.indexOf('north') !== -1) {
	        axisOrder += 'n';
	      } else if (descriptor.indexOf('south') !== -1) {
	        axisOrder += 's';
	      } else if (descriptor.indexOf('east') !== -1) {
	        axisOrder += 'e';
	      } else if (descriptor.indexOf('west') !== -1) {
	        axisOrder += 'w';
	      }
	    }
	    if (axisOrder.length === 2) {
	      axisOrder += 'u';
	    }
	    if (axisOrder.length === 3) {
	      wkt.axis = axisOrder;
	    }
	  }
	  if (wkt.UNIT) {
	    wkt.units = wkt.UNIT.name.toLowerCase();
	    if (wkt.units === 'metre') {
	      wkt.units = 'meter';
	    }
	    if (wkt.UNIT.convert) {
	      if (wkt.type === 'GEOGCS') {
	        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
	          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
	        }
	      } else {
	        wkt.to_meter = wkt.UNIT.convert;
	      }
	    }
	  }
	  var geogcs = wkt.GEOGCS;
	  if (wkt.type === 'GEOGCS') {
	    geogcs = wkt;
	  }
	  if (geogcs) {
	    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
	    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
	    //}
	    if (geogcs.DATUM) {
	      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
	    } else {
	      wkt.datumCode = geogcs.name.toLowerCase();
	    }
	    if (wkt.datumCode.slice(0, 2) === 'd_') {
	      wkt.datumCode = wkt.datumCode.slice(2);
	    }
	    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
	      wkt.datumCode = 'nzgd49';
	    }
	    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
	      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
	        wkt.sphere = true;
	      }
	      wkt.datumCode = 'wgs84';
	    }
	    if (wkt.datumCode.slice(-6) === '_ferro') {
	      wkt.datumCode = wkt.datumCode.slice(0, - 6);
	    }
	    if (wkt.datumCode.slice(-8) === '_jakarta') {
	      wkt.datumCode = wkt.datumCode.slice(0, - 8);
	    }
	    if (~wkt.datumCode.indexOf('belge')) {
	      wkt.datumCode = 'rnb72';
	    }
	    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
	      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
	      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
	        wkt.ellps = 'intl';
	      }

	      wkt.a = geogcs.DATUM.SPHEROID.a;
	      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
	    }

	    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
	      wkt.datum_params = geogcs.DATUM.TOWGS84;
	    }
	    if (~wkt.datumCode.indexOf('osgb_1936')) {
	      wkt.datumCode = 'osgb36';
	    }
	    if (~wkt.datumCode.indexOf('osni_1952')) {
	      wkt.datumCode = 'osni52';
	    }
	    if (~wkt.datumCode.indexOf('tm65')
	      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
	      wkt.datumCode = 'ire65';
	    }
	    if (wkt.datumCode === 'ch1903+') {
	      wkt.datumCode = 'ch1903';
	    }
	    if (~wkt.datumCode.indexOf('israel')) {
	      wkt.datumCode = 'isr93';
	    }
	  }
	  if (wkt.b && !isFinite(wkt.b)) {
	    wkt.b = wkt.a;
	  }

	  function toMeter(input) {
	    var ratio = wkt.to_meter || 1;
	    return input * ratio;
	  }
	  var renamer = function(a) {
	    return rename(wkt, a);
	  };
	  var list = [
	    ['standard_parallel_1', 'Standard_Parallel_1'],
	    ['standard_parallel_2', 'Standard_Parallel_2'],
	    ['false_easting', 'False_Easting'],
	    ['false_northing', 'False_Northing'],
	    ['central_meridian', 'Central_Meridian'],
	    ['latitude_of_origin', 'Latitude_Of_Origin'],
	    ['latitude_of_origin', 'Central_Parallel'],
	    ['scale_factor', 'Scale_Factor'],
	    ['k0', 'scale_factor'],
	    ['latitude_of_center', 'Latitude_Of_Center'],
	    ['latitude_of_center', 'Latitude_of_center'],
	    ['lat0', 'latitude_of_center', d2r],
	    ['longitude_of_center', 'Longitude_Of_Center'],
	    ['longitude_of_center', 'Longitude_of_center'],
	    ['longc', 'longitude_of_center', d2r],
	    ['x0', 'false_easting', toMeter],
	    ['y0', 'false_northing', toMeter],
	    ['long0', 'central_meridian', d2r],
	    ['lat0', 'latitude_of_origin', d2r],
	    ['lat0', 'standard_parallel_1', d2r],
	    ['lat1', 'standard_parallel_1', d2r],
	    ['lat2', 'standard_parallel_2', d2r],
	    ['azimuth', 'Azimuth'],
	    ['alpha', 'azimuth', d2r],
	    ['srsCode', 'name']
	  ];
	  list.forEach(renamer);
	  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
	    wkt.long0 = wkt.longc;
	  }
	  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
	    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
	    wkt.lat_ts = wkt.lat1;
	  }
	}
	function wkt(wkt) {
	  var lisp = parseString(wkt);
	  var type = lisp.shift();
	  var name = lisp.shift();
	  lisp.unshift(['name', name]);
	  lisp.unshift(['type', type]);
	  var obj = {};
	  sExpr(lisp, obj);
	  cleanWKT(obj);
	  return obj;
	}

	function defs(name) {
	  /*global console*/
	  var that = this;
	  if (arguments.length === 2) {
	    var def = arguments[1];
	    if (typeof def === 'string') {
	      if (def.charAt(0) === '+') {
	        defs[name] = projStr(arguments[1]);
	      }
	      else {
	        defs[name] = wkt(arguments[1]);
	      }
	    } else {
	      defs[name] = def;
	    }
	  }
	  else if (arguments.length === 1) {
	    if (Array.isArray(name)) {
	      return name.map(function(v) {
	        if (Array.isArray(v)) {
	          defs.apply(that, v);
	        }
	        else {
	          defs(v);
	        }
	      });
	    }
	    else if (typeof name === 'string') {
	      if (name in defs) {
	        return defs[name];
	      }
	    }
	    else if ('EPSG' in name) {
	      defs['EPSG:' + name.EPSG] = name;
	    }
	    else if ('ESRI' in name) {
	      defs['ESRI:' + name.ESRI] = name;
	    }
	    else if ('IAU2000' in name) {
	      defs['IAU2000:' + name.IAU2000] = name;
	    }
	    else {
	      console.log(name);
	    }
	    return;
	  }


	}
	globals(defs);

	function testObj(code){
	  return typeof code === 'string';
	}
	function testDef(code){
	  return code in defs;
	}
	var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
	function testWKT(code){
	  return codeWords.some(function (word) {
	    return code.indexOf(word) > -1;
	  });
	}
	var codes = ['3857', '900913', '3785', '102113'];
	function checkMercator(item) {
	  var auth = match(item, 'authority');
	  if (!auth) {
	    return;
	  }
	  var code = match(auth, 'epsg');
	  return code && codes.indexOf(code) > -1;
	}
	function checkProjStr(item) {
	  var ext = match(item, 'extension');
	  if (!ext) {
	    return;
	  }
	  return match(ext, 'proj4');
	}
	function testProj(code){
	  return code[0] === '+';
	}
	function parse(code){
	  if (testObj(code)) {
	    //check to see if this is a WKT string
	    if (testDef(code)) {
	      return defs[code];
	    }
	    if (testWKT(code)) {
	      var out = wkt(code);
	      // test of spetial case, due to this being a very common and often malformed
	      if (checkMercator(out)) {
	        return defs['EPSG:3857'];
	      }
	      var maybeProjStr = checkProjStr(out);
	      if (maybeProjStr) {
	        return projStr(maybeProjStr);
	      }
	      return out;
	    }
	    if (testProj(code)) {
	      return projStr(code);
	    }
	  }else {
	    return code;
	  }
	}

	function extend(destination, source) {
	  destination = destination || {};
	  var value, property;
	  if (!source) {
	    return destination;
	  }
	  for (property in source) {
	    value = source[property];
	    if (value !== undefined) {
	      destination[property] = value;
	    }
	  }
	  return destination;
	}

	function msfnz(eccent, sinphi, cosphi) {
	  var con = eccent * sinphi;
	  return cosphi / (Math.sqrt(1 - con * con));
	}

	function sign(x) {
	  return x<0 ? -1 : 1;
	}

	function adjust_lon(x) {
	  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
	}

	function tsfnz(eccent, phi, sinphi) {
	  var con = eccent * sinphi;
	  var com = 0.5 * eccent;
	  con = Math.pow(((1 - con) / (1 + con)), com);
	  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
	}

	function phi2z(eccent, ts) {
	  var eccnth = 0.5 * eccent;
	  var con, dphi;
	  var phi = HALF_PI - 2 * Math.atan(ts);
	  for (var i = 0; i <= 15; i++) {
	    con = eccent * Math.sin(phi);
	    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }
	  //console.log("phi2z has NoConvergence");
	  return -9999;
	}

	function init() {
	  var con = this.b / this.a;
	  this.es = 1 - con * con;
	  if(!('x0' in this)){
	    this.x0 = 0;
	  }
	  if(!('y0' in this)){
	    this.y0 = 0;
	  }
	  this.e = Math.sqrt(this.es);
	  if (this.lat_ts) {
	    if (this.sphere) {
	      this.k0 = Math.cos(this.lat_ts);
	    }
	    else {
	      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	    }
	  }
	  else {
	    if (!this.k0) {
	      if (this.k) {
	        this.k0 = this.k;
	      }
	      else {
	        this.k0 = 1;
	      }
	    }
	  }
	}

	/* Mercator forward equations--mapping lat,long to x,y
	  --------------------------------------------------*/

	function forward(p) {
	  var lon = p.x;
	  var lat = p.y;
	  // convert to radians
	  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
	    return null;
	  }

	  var x, y;
	  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	    return null;
	  }
	  else {
	    if (this.sphere) {
	      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
	    }
	    else {
	      var sinphi = Math.sin(lat);
	      var ts = tsfnz(this.e, lat, sinphi);
	      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	      y = this.y0 - this.a * this.k0 * Math.log(ts);
	    }
	    p.x = x;
	    p.y = y;
	    return p;
	  }
	}

	/* Mercator inverse equations--mapping x,y to lat/long
	  --------------------------------------------------*/
	function inverse(p) {

	  var x = p.x - this.x0;
	  var y = p.y - this.y0;
	  var lon, lat;

	  if (this.sphere) {
	    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
	  }
	  else {
	    var ts = Math.exp(-y / (this.a * this.k0));
	    lat = phi2z(this.e, ts);
	    if (lat === -9999) {
	      return null;
	    }
	  }
	  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
	var merc = {
	  init: init,
	  forward: forward,
	  inverse: inverse,
	  names: names
	};

	function init$1() {
	  //no-op for longlat
	}

	function identity(pt) {
	  return pt;
	}
	var names$1 = ["longlat", "identity"];
	var longlat = {
	  init: init$1,
	  forward: identity,
	  inverse: identity,
	  names: names$1
	};

	var projs = [merc, longlat];
	var names$2 = {};
	var projStore = [];

	function add(proj, i) {
	  var len = projStore.length;
	  if (!proj.names) {
	    console.log(i);
	    return true;
	  }
	  projStore[len] = proj;
	  proj.names.forEach(function(n) {
	    names$2[n.toLowerCase()] = len;
	  });
	  return this;
	}

	function get(name) {
	  if (!name) {
	    return false;
	  }
	  var n = name.toLowerCase();
	  if (typeof names$2[n] !== 'undefined' && projStore[names$2[n]]) {
	    return projStore[names$2[n]];
	  }
	}

	function start() {
	  projs.forEach(add);
	}
	var projections = {
	  start: start,
	  add: add,
	  get: get
	};

	var exports$2 = {};
	exports$2.MERIT = {
	  a: 6378137.0,
	  rf: 298.257,
	  ellipseName: "MERIT 1983"
	};

	exports$2.SGS85 = {
	  a: 6378136.0,
	  rf: 298.257,
	  ellipseName: "Soviet Geodetic System 85"
	};

	exports$2.GRS80 = {
	  a: 6378137.0,
	  rf: 298.257222101,
	  ellipseName: "GRS 1980(IUGG, 1980)"
	};

	exports$2.IAU76 = {
	  a: 6378140.0,
	  rf: 298.257,
	  ellipseName: "IAU 1976"
	};

	exports$2.airy = {
	  a: 6377563.396,
	  b: 6356256.910,
	  ellipseName: "Airy 1830"
	};

	exports$2.APL4 = {
	  a: 6378137,
	  rf: 298.25,
	  ellipseName: "Appl. Physics. 1965"
	};

	exports$2.NWL9D = {
	  a: 6378145.0,
	  rf: 298.25,
	  ellipseName: "Naval Weapons Lab., 1965"
	};

	exports$2.mod_airy = {
	  a: 6377340.189,
	  b: 6356034.446,
	  ellipseName: "Modified Airy"
	};

	exports$2.andrae = {
	  a: 6377104.43,
	  rf: 300.0,
	  ellipseName: "Andrae 1876 (Den., Iclnd.)"
	};

	exports$2.aust_SA = {
	  a: 6378160.0,
	  rf: 298.25,
	  ellipseName: "Australian Natl & S. Amer. 1969"
	};

	exports$2.GRS67 = {
	  a: 6378160.0,
	  rf: 298.2471674270,
	  ellipseName: "GRS 67(IUGG 1967)"
	};

	exports$2.bessel = {
	  a: 6377397.155,
	  rf: 299.1528128,
	  ellipseName: "Bessel 1841"
	};

	exports$2.bess_nam = {
	  a: 6377483.865,
	  rf: 299.1528128,
	  ellipseName: "Bessel 1841 (Namibia)"
	};

	exports$2.clrk66 = {
	  a: 6378206.4,
	  b: 6356583.8,
	  ellipseName: "Clarke 1866"
	};

	exports$2.clrk80 = {
	  a: 6378249.145,
	  rf: 293.4663,
	  ellipseName: "Clarke 1880 mod."
	};

	exports$2.clrk58 = {
	  a: 6378293.645208759,
	  rf: 294.2606763692654,
	  ellipseName: "Clarke 1858"
	};

	exports$2.CPM = {
	  a: 6375738.7,
	  rf: 334.29,
	  ellipseName: "Comm. des Poids et Mesures 1799"
	};

	exports$2.delmbr = {
	  a: 6376428.0,
	  rf: 311.5,
	  ellipseName: "Delambre 1810 (Belgium)"
	};

	exports$2.engelis = {
	  a: 6378136.05,
	  rf: 298.2566,
	  ellipseName: "Engelis 1985"
	};

	exports$2.evrst30 = {
	  a: 6377276.345,
	  rf: 300.8017,
	  ellipseName: "Everest 1830"
	};

	exports$2.evrst48 = {
	  a: 6377304.063,
	  rf: 300.8017,
	  ellipseName: "Everest 1948"
	};

	exports$2.evrst56 = {
	  a: 6377301.243,
	  rf: 300.8017,
	  ellipseName: "Everest 1956"
	};

	exports$2.evrst69 = {
	  a: 6377295.664,
	  rf: 300.8017,
	  ellipseName: "Everest 1969"
	};

	exports$2.evrstSS = {
	  a: 6377298.556,
	  rf: 300.8017,
	  ellipseName: "Everest (Sabah & Sarawak)"
	};

	exports$2.fschr60 = {
	  a: 6378166.0,
	  rf: 298.3,
	  ellipseName: "Fischer (Mercury Datum) 1960"
	};

	exports$2.fschr60m = {
	  a: 6378155.0,
	  rf: 298.3,
	  ellipseName: "Fischer 1960"
	};

	exports$2.fschr68 = {
	  a: 6378150.0,
	  rf: 298.3,
	  ellipseName: "Fischer 1968"
	};

	exports$2.helmert = {
	  a: 6378200.0,
	  rf: 298.3,
	  ellipseName: "Helmert 1906"
	};

	exports$2.hough = {
	  a: 6378270.0,
	  rf: 297.0,
	  ellipseName: "Hough"
	};

	exports$2.intl = {
	  a: 6378388.0,
	  rf: 297.0,
	  ellipseName: "International 1909 (Hayford)"
	};

	exports$2.kaula = {
	  a: 6378163.0,
	  rf: 298.24,
	  ellipseName: "Kaula 1961"
	};

	exports$2.lerch = {
	  a: 6378139.0,
	  rf: 298.257,
	  ellipseName: "Lerch 1979"
	};

	exports$2.mprts = {
	  a: 6397300.0,
	  rf: 191.0,
	  ellipseName: "Maupertius 1738"
	};

	exports$2.new_intl = {
	  a: 6378157.5,
	  b: 6356772.2,
	  ellipseName: "New International 1967"
	};

	exports$2.plessis = {
	  a: 6376523.0,
	  rf: 6355863.0,
	  ellipseName: "Plessis 1817 (France)"
	};

	exports$2.krass = {
	  a: 6378245.0,
	  rf: 298.3,
	  ellipseName: "Krassovsky, 1942"
	};

	exports$2.SEasia = {
	  a: 6378155.0,
	  b: 6356773.3205,
	  ellipseName: "Southeast Asia"
	};

	exports$2.walbeck = {
	  a: 6376896.0,
	  b: 6355834.8467,
	  ellipseName: "Walbeck"
	};

	exports$2.WGS60 = {
	  a: 6378165.0,
	  rf: 298.3,
	  ellipseName: "WGS 60"
	};

	exports$2.WGS66 = {
	  a: 6378145.0,
	  rf: 298.25,
	  ellipseName: "WGS 66"
	};

	exports$2.WGS7 = {
	  a: 6378135.0,
	  rf: 298.26,
	  ellipseName: "WGS 72"
	};

	var WGS84 = exports$2.WGS84 = {
	  a: 6378137.0,
	  rf: 298.257223563,
	  ellipseName: "WGS 84"
	};

	exports$2.sphere = {
	  a: 6370997.0,
	  b: 6370997.0,
	  ellipseName: "Normal Sphere (r=6370997)"
	};

	function eccentricity(a, b, rf, R_A) {
	  var a2 = a * a; // used in geocentric
	  var b2 = b * b; // used in geocentric
	  var es = (a2 - b2) / a2; // e ^ 2
	  var e = 0;
	  if (R_A) {
	    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
	    a2 = a * a;
	    es = 0;
	  } else {
	    e = Math.sqrt(es); // eccentricity
	  }
	  var ep2 = (a2 - b2) / b2; // used in geocentric
	  return {
	    es: es,
	    e: e,
	    ep2: ep2
	  };
	}
	function sphere(a, b, rf, ellps, sphere) {
	  if (!a) { // do we have an ellipsoid?
	    var ellipse = match(exports$2, ellps);
	    if (!ellipse) {
	      ellipse = WGS84;
	    }
	    a = ellipse.a;
	    b = ellipse.b;
	    rf = ellipse.rf;
	  }

	  if (rf && !b) {
	    b = (1.0 - 1.0 / rf) * a;
	  }
	  if (rf === 0 || Math.abs(a - b) < EPSLN) {
	    sphere = true;
	    b = a;
	  }
	  return {
	    a: a,
	    b: b,
	    rf: rf,
	    sphere: sphere
	  };
	}

	var exports$3 = {};
	exports$3.wgs84 = {
	  towgs84: "0,0,0",
	  ellipse: "WGS84",
	  datumName: "WGS84"
	};

	exports$3.ch1903 = {
	  towgs84: "674.374,15.056,405.346",
	  ellipse: "bessel",
	  datumName: "swiss"
	};

	exports$3.ggrs87 = {
	  towgs84: "-199.87,74.79,246.62",
	  ellipse: "GRS80",
	  datumName: "Greek_Geodetic_Reference_System_1987"
	};

	exports$3.nad83 = {
	  towgs84: "0,0,0",
	  ellipse: "GRS80",
	  datumName: "North_American_Datum_1983"
	};

	exports$3.nad27 = {
	  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
	  ellipse: "clrk66",
	  datumName: "North_American_Datum_1927"
	};

	exports$3.potsdam = {
	  towgs84: "606.0,23.0,413.0",
	  ellipse: "bessel",
	  datumName: "Potsdam Rauenberg 1950 DHDN"
	};

	exports$3.carthage = {
	  towgs84: "-263.0,6.0,431.0",
	  ellipse: "clark80",
	  datumName: "Carthage 1934 Tunisia"
	};

	exports$3.hermannskogel = {
	  towgs84: "653.0,-212.0,449.0",
	  ellipse: "bessel",
	  datumName: "Hermannskogel"
	};

	exports$3.osni52 = {
	  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
	  ellipse: "airy",
	  datumName: "Irish National"
	};

	exports$3.ire65 = {
	  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
	  ellipse: "mod_airy",
	  datumName: "Ireland 1965"
	};

	exports$3.rassadiran = {
	  towgs84: "-133.63,-157.5,-158.62",
	  ellipse: "intl",
	  datumName: "Rassadiran"
	};

	exports$3.nzgd49 = {
	  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
	  ellipse: "intl",
	  datumName: "New Zealand Geodetic Datum 1949"
	};

	exports$3.osgb36 = {
	  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
	  ellipse: "airy",
	  datumName: "Airy 1830"
	};

	exports$3.s_jtsk = {
	  towgs84: "589,76,480",
	  ellipse: 'bessel',
	  datumName: 'S-JTSK (Ferro)'
	};

	exports$3.beduaram = {
	  towgs84: '-106,-87,188',
	  ellipse: 'clrk80',
	  datumName: 'Beduaram'
	};

	exports$3.gunung_segara = {
	  towgs84: '-403,684,41',
	  ellipse: 'bessel',
	  datumName: 'Gunung Segara Jakarta'
	};

	exports$3.rnb72 = {
	  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
	  ellipse: "intl",
	  datumName: "Reseau National Belge 1972"
	};

	function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
	  var out = {};

	  if (datumCode === undefined || datumCode === 'none') {
	    out.datum_type = PJD_NODATUM;
	  } else {
	    out.datum_type = PJD_WGS84;
	  }

	  if (datum_params) {
	    out.datum_params = datum_params.map(parseFloat);
	    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
	      out.datum_type = PJD_3PARAM;
	    }
	    if (out.datum_params.length > 3) {
	      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
	        out.datum_type = PJD_7PARAM;
	        out.datum_params[3] *= SEC_TO_RAD;
	        out.datum_params[4] *= SEC_TO_RAD;
	        out.datum_params[5] *= SEC_TO_RAD;
	        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
	      }
	    }
	  }

	  if (nadgrids) {
	    out.datum_type = PJD_GRIDSHIFT;
	    out.grids = nadgrids;
	  }
	  out.a = a; //datum object also uses these values
	  out.b = b;
	  out.es = es;
	  out.ep2 = ep2;
	  return out;
	}

	/**
	 * Resources for details of NTv2 file formats:
	 * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
	 * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
	 */

	var loadedNadgrids = {};

	/**
	 * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
	 * as an ArrayBuffer.
	 */
	function nadgrid(key, data) {
	  var view = new DataView(data);
	  var isLittleEndian = detectLittleEndian(view);
	  var header = readHeader(view, isLittleEndian);
	  if (header.nSubgrids > 1) {
	    console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
	  }
	  var subgrids = readSubgrids(view, header, isLittleEndian);
	  var nadgrid = {header: header, subgrids: subgrids};
	  loadedNadgrids[key] = nadgrid;
	  return nadgrid;
	}

	/**
	 * Given a proj4 value for nadgrids, return an array of loaded grids
	 */
	function getNadgrids(nadgrids) {
	  // Format details: http://proj.maptools.org/gen_parms.html
	  if (nadgrids === undefined) { return null; }
	  var grids = nadgrids.split(',');
	  return grids.map(parseNadgridString);
	}

	function parseNadgridString(value) {
	  if (value.length === 0) {
	    return null;
	  }
	  var optional = value[0] === '@';
	  if (optional) {
	    value = value.slice(1);
	  }
	  if (value === 'null') {
	    return {name: 'null', mandatory: !optional, grid: null, isNull: true};
	  }
	  return {
	    name: value,
	    mandatory: !optional,
	    grid: loadedNadgrids[value] || null,
	    isNull: false
	  };
	}

	function secondsToRadians(seconds) {
	  return (seconds / 3600) * Math.PI / 180;
	}

	function detectLittleEndian(view) {
	  var nFields = view.getInt32(8, false);
	  if (nFields === 11) {
	    return false;
	  }
	  nFields = view.getInt32(8, true);
	  if (nFields !== 11) {
	    console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
	  }
	  return true;
	}

	function readHeader(view, isLittleEndian) {
	  return {
	    nFields: view.getInt32(8, isLittleEndian),
	    nSubgridFields: view.getInt32(24, isLittleEndian),
	    nSubgrids: view.getInt32(40, isLittleEndian),
	    shiftType: decodeString(view, 56, 56 + 8).trim(),
	    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
	    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
	    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
	    toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
	  };
	}

	function decodeString(view, start, end) {
	  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
	}

	function readSubgrids(view, header, isLittleEndian) {
	  var gridOffset = 176;
	  var grids = [];
	  for (var i = 0; i < header.nSubgrids; i++) {
	    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
	    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
	    var lngColumnCount = Math.round(
	      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
	    var latColumnCount = Math.round(
	      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
	    // Proj4 operates on radians whereas the coordinates are in seconds in the grid
	    grids.push({
	      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
	      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
	      lim: [lngColumnCount, latColumnCount],
	      count: subHeader.gridNodeCount,
	      cvs: mapNodes(nodes)
	    });
	  }
	  return grids;
	}

	function mapNodes(nodes) {
	  return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
	}

	function readGridHeader(view, offset, isLittleEndian) {
	  return {
	    name: decodeString(view, offset + 8, offset + 16).trim(),
	    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
	    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
	    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
	    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
	    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
	    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
	    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
	    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
	  };
	}

	function readGridNodes(view, offset, gridHeader, isLittleEndian) {
	  var nodesOffset = offset + 176;
	  var gridRecordLength = 16;
	  var gridShiftRecords = [];
	  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
	    var record = {
	      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
	      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
	      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
	      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
	    };
	    gridShiftRecords.push(record);
	  }
	  return gridShiftRecords;
	}

	function Projection(srsCode,callback) {
	  if (!(this instanceof Projection)) {
	    return new Projection(srsCode);
	  }
	  callback = callback || function(error){
	    if(error){
	      throw error;
	    }
	  };
	  var json = parse(srsCode);
	  if(typeof json !== 'object'){
	    callback(srsCode);
	    return;
	  }
	  var ourProj = Projection.projections.get(json.projName);
	  if(!ourProj){
	    callback(srsCode);
	    return;
	  }
	  if (json.datumCode && json.datumCode !== 'none') {
	    var datumDef = match(exports$3, json.datumCode);
	    if (datumDef) {
	      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
	      json.ellps = datumDef.ellipse;
	      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
	    }
	  }
	  json.k0 = json.k0 || 1.0;
	  json.axis = json.axis || 'enu';
	  json.ellps = json.ellps || 'wgs84';
	  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
	  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
	  var nadgrids = getNadgrids(json.nadgrids);
	  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
	    nadgrids);

	  extend(this, json); // transfer everything over from the projection because we don't know what we'll need
	  extend(this, ourProj); // transfer all the methods from the projection

	  // copy the 4 things over we calulated in deriveConstants.sphere
	  this.a = sphere_.a;
	  this.b = sphere_.b;
	  this.rf = sphere_.rf;
	  this.sphere = sphere_.sphere;

	  // copy the 3 things we calculated in deriveConstants.eccentricity
	  this.es = ecc.es;
	  this.e = ecc.e;
	  this.ep2 = ecc.ep2;

	  // add in the datum object
	  this.datum = datumObj;

	  // init the projection
	  this.init();

	  // legecy callback from back in the day when it went to spatialreference.org
	  callback(null, this);

	}
	Projection.projections = projections;
	Projection.projections.start();

	function compareDatums(source, dest) {
	  if (source.datum_type !== dest.datum_type) {
	    return false; // false, datums are not equal
	  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
	    // the tolerance for es is to ensure that GRS80 and WGS84
	    // are considered identical
	    return false;
	  } else if (source.datum_type === PJD_3PARAM) {
	    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
	  } else if (source.datum_type === PJD_7PARAM) {
	    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
	  } else {
	    return true; // datums are equal
	  }
	} // cs_compare_datums()

	/*
	 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
	 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
	 * according to the current ellipsoid parameters.
	 *
	 *    Latitude  : Geodetic latitude in radians                     (input)
	 *    Longitude : Geodetic longitude in radians                    (input)
	 *    Height    : Geodetic height, in meters                       (input)
	 *    X         : Calculated Geocentric X coordinate, in meters    (output)
	 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
	 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
	 *
	 */
	function geodeticToGeocentric(p, es, a) {
	  var Longitude = p.x;
	  var Latitude = p.y;
	  var Height = p.z ? p.z : 0; //Z value not always supplied

	  var Rn; /*  Earth radius at location  */
	  var Sin_Lat; /*  Math.sin(Latitude)  */
	  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
	  var Cos_Lat; /*  Math.cos(Latitude)  */

	  /*
	   ** Don't blow up if Latitude is just a little out of the value
	   ** range as it may just be a rounding issue.  Also removed longitude
	   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
	   */
	  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
	    Latitude = -HALF_PI;
	  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
	    Latitude = HALF_PI;
	  } else if (Latitude < -HALF_PI) {
	    /* Latitude out of range */
	    //..reportError('geocent:lat out of range:' + Latitude);
	    return { x: -Infinity, y: -Infinity, z: p.z };
	  } else if (Latitude > HALF_PI) {
	    /* Latitude out of range */
	    return { x: Infinity, y: Infinity, z: p.z };
	  }

	  if (Longitude > Math.PI) {
	    Longitude -= (2 * Math.PI);
	  }
	  Sin_Lat = Math.sin(Latitude);
	  Cos_Lat = Math.cos(Latitude);
	  Sin2_Lat = Sin_Lat * Sin_Lat;
	  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
	  return {
	    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
	    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
	    z: ((Rn * (1 - es)) + Height) * Sin_Lat
	  };
	} // cs_geodetic_to_geocentric()

	function geocentricToGeodetic(p, es, a, b) {
	  /* local defintions and variables */
	  /* end-criterium of loop, accuracy of sin(Latitude) */
	  var genau = 1e-12;
	  var genau2 = (genau * genau);
	  var maxiter = 30;

	  var P; /* distance between semi-minor axis and location */
	  var RR; /* distance between center and location */
	  var CT; /* sin of geocentric latitude */
	  var ST; /* cos of geocentric latitude */
	  var RX;
	  var RK;
	  var RN; /* Earth radius at location */
	  var CPHI0; /* cos of start or old geodetic latitude in iterations */
	  var SPHI0; /* sin of start or old geodetic latitude in iterations */
	  var CPHI; /* cos of searched geodetic latitude */
	  var SPHI; /* sin of searched geodetic latitude */
	  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
	  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

	  var X = p.x;
	  var Y = p.y;
	  var Z = p.z ? p.z : 0.0; //Z value not always supplied
	  var Longitude;
	  var Latitude;
	  var Height;

	  P = Math.sqrt(X * X + Y * Y);
	  RR = Math.sqrt(X * X + Y * Y + Z * Z);

	  /*      special cases for latitude and longitude */
	  if (P / a < genau) {

	    /*  special case, if P=0. (X=0., Y=0.) */
	    Longitude = 0.0;

	    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
	     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
	    if (RR / a < genau) {
	      Latitude = HALF_PI;
	      Height = -b;
	      return {
	        x: p.x,
	        y: p.y,
	        z: p.z
	      };
	    }
	  } else {
	    /*  ellipsoidal (geodetic) longitude
	     *  interval: -PI < Longitude <= +PI */
	    Longitude = Math.atan2(Y, X);
	  }

	  /* --------------------------------------------------------------
	   * Following iterative algorithm was developped by
	   * "Institut for Erdmessung", University of Hannover, July 1988.
	   * Internet: www.ife.uni-hannover.de
	   * Iterative computation of CPHI,SPHI and Height.
	   * Iteration of CPHI and SPHI to 10**-12 radian resp.
	   * 2*10**-7 arcsec.
	   * --------------------------------------------------------------
	   */
	  CT = Z / RR;
	  ST = P / RR;
	  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
	  CPHI0 = ST * (1.0 - es) * RX;
	  SPHI0 = CT * RX;
	  iter = 0;

	  /* loop to find sin(Latitude) resp. Latitude
	   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
	  do {
	    iter++;
	    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

	    /*  ellipsoidal (geodetic) height */
	    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

	    RK = es * RN / (RN + Height);
	    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
	    CPHI = ST * (1.0 - RK) * RX;
	    SPHI = CT * RX;
	    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
	    CPHI0 = CPHI;
	    SPHI0 = SPHI;
	  }
	  while (SDPHI * SDPHI > genau2 && iter < maxiter);

	  /*      ellipsoidal (geodetic) latitude */
	  Latitude = Math.atan(SPHI / Math.abs(CPHI));
	  return {
	    x: Longitude,
	    y: Latitude,
	    z: Height
	  };
	} // cs_geocentric_to_geodetic()

	/****************************************************************/
	// pj_geocentic_to_wgs84( p )
	//  p = point to transform in geocentric coordinates (x,y,z)


	/** point object, nothing fancy, just allows values to be
	    passed back and forth by reference rather than by value.
	    Other point classes may be used as long as they have
	    x and y properties, which will get modified in the transform method.
	*/
	function geocentricToWgs84(p, datum_type, datum_params) {

	  if (datum_type === PJD_3PARAM) {
	    // if( x[io] === HUGE_VAL )
	    //    continue;
	    return {
	      x: p.x + datum_params[0],
	      y: p.y + datum_params[1],
	      z: p.z + datum_params[2],
	    };
	  } else if (datum_type === PJD_7PARAM) {
	    var Dx_BF = datum_params[0];
	    var Dy_BF = datum_params[1];
	    var Dz_BF = datum_params[2];
	    var Rx_BF = datum_params[3];
	    var Ry_BF = datum_params[4];
	    var Rz_BF = datum_params[5];
	    var M_BF = datum_params[6];
	    // if( x[io] === HUGE_VAL )
	    //    continue;
	    return {
	      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
	      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
	      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
	    };
	  }
	} // cs_geocentric_to_wgs84

	/****************************************************************/
	// pj_geocentic_from_wgs84()
	//  coordinate system definition,
	//  point to transform in geocentric coordinates (x,y,z)
	function geocentricFromWgs84(p, datum_type, datum_params) {

	  if (datum_type === PJD_3PARAM) {
	    //if( x[io] === HUGE_VAL )
	    //    continue;
	    return {
	      x: p.x - datum_params[0],
	      y: p.y - datum_params[1],
	      z: p.z - datum_params[2],
	    };

	  } else if (datum_type === PJD_7PARAM) {
	    var Dx_BF = datum_params[0];
	    var Dy_BF = datum_params[1];
	    var Dz_BF = datum_params[2];
	    var Rx_BF = datum_params[3];
	    var Ry_BF = datum_params[4];
	    var Rz_BF = datum_params[5];
	    var M_BF = datum_params[6];
	    var x_tmp = (p.x - Dx_BF) / M_BF;
	    var y_tmp = (p.y - Dy_BF) / M_BF;
	    var z_tmp = (p.z - Dz_BF) / M_BF;
	    //if( x[io] === HUGE_VAL )
	    //    continue;

	    return {
	      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
	      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
	      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
	    };
	  } //cs_geocentric_from_wgs84()
	}

	function checkParams(type) {
	  return (type === PJD_3PARAM || type === PJD_7PARAM);
	}

	function datum_transform(source, dest, point) {
	  // Short cut if the datums are identical.
	  if (compareDatums(source, dest)) {
	    return point; // in this case, zero is sucess,
	    // whereas cs_compare_datums returns 1 to indicate TRUE
	    // confusing, should fix this
	  }

	  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
	  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
	    return point;
	  }

	  // If this datum requires grid shifts, then apply it to geodetic coordinates.
	  var source_a = source.a;
	  var source_es = source.es;
	  if (source.datum_type === PJD_GRIDSHIFT) {
	    var gridShiftCode = applyGridShift(source, false, point);
	    if (gridShiftCode !== 0) {
	      return undefined;
	    }
	    source_a = SRS_WGS84_SEMIMAJOR;
	    source_es = SRS_WGS84_ESQUARED;
	  }

	  var dest_a = dest.a;
	  var dest_b = dest.b;
	  var dest_es = dest.es;
	  if (dest.datum_type === PJD_GRIDSHIFT) {
	    dest_a = SRS_WGS84_SEMIMAJOR;
	    dest_b = SRS_WGS84_SEMIMINOR;
	    dest_es = SRS_WGS84_ESQUARED;
	  }

	  // Do we need to go through geocentric coordinates?
	  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
	    return point;
	  }

	  // Convert to geocentric coordinates.
	  point = geodeticToGeocentric(point, source_es, source_a);
	  // Convert between datums
	  if (checkParams(source.datum_type)) {
	    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
	  }
	  if (checkParams(dest.datum_type)) {
	    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
	  }
	  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

	  if (dest.datum_type === PJD_GRIDSHIFT) {
	    var destGridShiftResult = applyGridShift(dest, true, point);
	    if (destGridShiftResult !== 0) {
	      return undefined;
	    }
	  }

	  return point;
	}

	function applyGridShift(source, inverse, point) {
	  if (source.grids === null || source.grids.length === 0) {
	    console.log('Grid shift grids not found');
	    return -1;
	  }
	  var input = {x: -point.x, y: point.y};
	  var output = {x: Number.NaN, y: Number.NaN};
	  var attemptedGrids = [];
	  for (var i = 0; i < source.grids.length; i++) {
	    var grid = source.grids[i];
	    attemptedGrids.push(grid.name);
	    if (grid.isNull) {
	      output = input;
	      break;
	    }
	    grid.mandatory;
	    if (grid.grid === null) {
	      if (grid.mandatory) {
	        console.log("Unable to find mandatory grid '" + grid.name + "'");
	        return -1;
	      }
	      continue;
	    }
	    var subgrid = grid.grid.subgrids[0];
	    // skip tables that don't match our point at all
	    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
	    var minX = subgrid.ll[0] - epsilon;
	    var minY = subgrid.ll[1] - epsilon;
	    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
	    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
	    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
	      continue;
	    }
	    output = applySubgridShift(input, inverse, subgrid);
	    if (!isNaN(output.x)) {
	      break;
	    }
	  }
	  if (isNaN(output.x)) {
	    console.log("Failed to find a grid shift table for location '"+
	      -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
	    return -1;
	  }
	  point.x = -output.x;
	  point.y = output.y;
	  return 0;
	}

	function applySubgridShift(pin, inverse, ct) {
	  var val = {x: Number.NaN, y: Number.NaN};
	  if (isNaN(pin.x)) { return val; }
	  var tb = {x: pin.x, y: pin.y};
	  tb.x -= ct.ll[0];
	  tb.y -= ct.ll[1];
	  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
	  var t = nadInterpolate(tb, ct);
	  if (inverse) {
	    if (isNaN(t.x)) {
	      return val;
	    }
	    t.x = tb.x - t.x;
	    t.y = tb.y - t.y;
	    var i = 9, tol = 1e-12;
	    var dif, del;
	    do {
	      del = nadInterpolate(t, ct);
	      if (isNaN(del.x)) {
	        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
	        break;
	      }
	      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
	      t.x += dif.x;
	      t.y += dif.y;
	    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
	    if (i < 0) {
	      console.log("Inverse grid shift iterator failed to converge.");
	      return val;
	    }
	    val.x = adjust_lon(t.x + ct.ll[0]);
	    val.y = t.y + ct.ll[1];
	  } else {
	    if (!isNaN(t.x)) {
	      val.x = pin.x + t.x;
	      val.y = pin.y + t.y;
	    }
	  }
	  return val;
	}

	function nadInterpolate(pin, ct) {
	  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
	  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
	  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
	  var val= {x: Number.NaN, y: Number.NaN};
	  var inx;
	  if (indx.x < 0 || indx.x >= ct.lim[0]) {
	    return val;
	  }
	  if (indx.y < 0 || indx.y >= ct.lim[1]) {
	    return val;
	  }
	  inx = (indx.y * ct.lim[0]) + indx.x;
	  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
	  inx++;
	  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
	  inx += ct.lim[0];
	  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
	  inx--;
	  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
	  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
	    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
	  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
	  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
	  return val;
	}

	function adjust_axis(crs, denorm, point) {
	  var xin = point.x,
	    yin = point.y,
	    zin = point.z || 0.0;
	  var v, t, i;
	  var out = {};
	  for (i = 0; i < 3; i++) {
	    if (denorm && i === 2 && point.z === undefined) {
	      continue;
	    }
	    if (i === 0) {
	      v = xin;
	      if ("ew".indexOf(crs.axis[i]) !== -1) {
	        t = 'x';
	      } else {
	        t = 'y';
	      }

	    }
	    else if (i === 1) {
	      v = yin;
	      if ("ns".indexOf(crs.axis[i]) !== -1) {
	        t = 'y';
	      } else {
	        t = 'x';
	      }
	    }
	    else {
	      v = zin;
	      t = 'z';
	    }
	    switch (crs.axis[i]) {
	    case 'e':
	      out[t] = v;
	      break;
	    case 'w':
	      out[t] = -v;
	      break;
	    case 'n':
	      out[t] = v;
	      break;
	    case 's':
	      out[t] = -v;
	      break;
	    case 'u':
	      if (point[t] !== undefined) {
	        out.z = v;
	      }
	      break;
	    case 'd':
	      if (point[t] !== undefined) {
	        out.z = -v;
	      }
	      break;
	    default:
	      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
	      return null;
	    }
	  }
	  return out;
	}

	function common$1 (array){
	  var out = {
	    x: array[0],
	    y: array[1]
	  };
	  if (array.length>2) {
	    out.z = array[2];
	  }
	  if (array.length>3) {
	    out.m = array[3];
	  }
	  return out;
	}

	function checkSanity (point) {
	  checkCoord(point.x);
	  checkCoord(point.y);
	}
	function checkCoord(num) {
	  if (typeof Number.isFinite === 'function') {
	    if (Number.isFinite(num)) {
	      return;
	    }
	    throw new TypeError('coordinates must be finite numbers');
	  }
	  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
	    throw new TypeError('coordinates must be finite numbers');
	  }
	}

	function checkNotWGS(source, dest) {
	  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
	}

	function transform(source, dest, point) {
	  var wgs84;
	  if (Array.isArray(point)) {
	    point = common$1(point);
	  }
	  checkSanity(point);
	  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
	  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
	    wgs84 = new Projection('WGS84');
	    point = transform(source, wgs84, point);
	    source = wgs84;
	  }
	  // DGR, 2010/11/12
	  if (source.axis !== 'enu') {
	    point = adjust_axis(source, false, point);
	  }
	  // Transform source points to long/lat, if they aren't already.
	  if (source.projName === 'longlat') {
	    point = {
	      x: point.x * D2R,
	      y: point.y * D2R,
	      z: point.z || 0
	    };
	  } else {
	    if (source.to_meter) {
	      point = {
	        x: point.x * source.to_meter,
	        y: point.y * source.to_meter,
	        z: point.z || 0
	      };
	    }
	    point = source.inverse(point); // Convert Cartesian to longlat
	    if (!point) {
	      return;
	    }
	  }
	  // Adjust for the prime meridian if necessary
	  if (source.from_greenwich) {
	    point.x += source.from_greenwich;
	  }

	  // Convert datums if needed, and if possible.
	  point = datum_transform(source.datum, dest.datum, point);
	  if (!point) {
	    return;
	  }

	  // Adjust for the prime meridian if necessary
	  if (dest.from_greenwich) {
	    point = {
	      x: point.x - dest.from_greenwich,
	      y: point.y,
	      z: point.z || 0
	    };
	  }

	  if (dest.projName === 'longlat') {
	    // convert radians to decimal degrees
	    point = {
	      x: point.x * R2D,
	      y: point.y * R2D,
	      z: point.z || 0
	    };
	  } else { // else project
	    point = dest.forward(point);
	    if (dest.to_meter) {
	      point = {
	        x: point.x / dest.to_meter,
	        y: point.y / dest.to_meter,
	        z: point.z || 0
	      };
	    }
	  }

	  // DGR, 2010/11/12
	  if (dest.axis !== 'enu') {
	    return adjust_axis(dest, true, point);
	  }

	  return point;
	}

	var wgs84 = Projection('WGS84');

	function transformer(from, to, coords) {
	  var transformedArray, out, keys;
	  if (Array.isArray(coords)) {
	    transformedArray = transform(from, to, coords) || {x: NaN, y: NaN};
	    if (coords.length > 2) {
	      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
	        if (typeof transformedArray.z === 'number') {
	          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
	        } else {
	          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
	        }
	      } else {
	        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
	      }
	    } else {
	      return [transformedArray.x, transformedArray.y];
	    }
	  } else {
	    out = transform(from, to, coords);
	    keys = Object.keys(coords);
	    if (keys.length === 2) {
	      return out;
	    }
	    keys.forEach(function (key) {
	      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
	        if (key === 'x' || key === 'y' || key === 'z') {
	          return;
	        }
	      } else {
	        if (key === 'x' || key === 'y') {
	          return;
	        }
	      }
	      out[key] = coords[key];
	    });
	    return out;
	  }
	}

	function checkProj(item) {
	  if (item instanceof Projection) {
	    return item;
	  }
	  if (item.oProj) {
	    return item.oProj;
	  }
	  return Projection(item);
	}

	function proj4(fromProj, toProj, coord) {
	  fromProj = checkProj(fromProj);
	  var single = false;
	  var obj;
	  if (typeof toProj === 'undefined') {
	    toProj = fromProj;
	    fromProj = wgs84;
	    single = true;
	  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
	    coord = toProj;
	    toProj = fromProj;
	    fromProj = wgs84;
	    single = true;
	  }
	  toProj = checkProj(toProj);
	  if (coord) {
	    return transformer(fromProj, toProj, coord);
	  } else {
	    obj = {
	      forward: function (coords) {
	        return transformer(fromProj, toProj, coords);
	      },
	      inverse: function (coords) {
	        return transformer(toProj, fromProj, coords);
	      }
	    };
	    if (single) {
	      obj.oProj = toProj;
	    }
	    return obj;
	  }
	}

	/**
	 * UTM zones are grouped, and assigned to one of a group of 6
	 * sets.
	 *
	 * {int} @private
	 */
	var NUM_100K_SETS = 6;

	/**
	 * The column letters (for easting) of the lower left value, per
	 * set.
	 *
	 * {string} @private
	 */
	var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

	/**
	 * The row letters (for northing) of the lower left value, per
	 * set.
	 *
	 * {string} @private
	 */
	var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

	var A = 65; // A
	var I = 73; // I
	var O = 79; // O
	var V = 86; // V
	var Z = 90; // Z
	var mgrs = {
	  forward: forward$1,
	  inverse: inverse$1,
	  toPoint: toPoint
	};
	/**
	 * Conversion of lat/lon to MGRS.
	 *
	 * @param {object} ll Object literal with lat and lon properties on a
	 *     WGS84 ellipsoid.
	 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
	 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
	 * @return {string} the MGRS string for the given location and accuracy.
	 */
	function forward$1(ll, accuracy) {
	  accuracy = accuracy || 5; // default accuracy 1m
	  return encode(LLtoUTM({
	    lat: ll[1],
	    lon: ll[0]
	  }), accuracy);
	}
	/**
	 * Conversion of MGRS to lat/lon.
	 *
	 * @param {string} mgrs MGRS string.
	 * @return {array} An array with left (longitude), bottom (latitude), right
	 *     (longitude) and top (latitude) values in WGS84, representing the
	 *     bounding box for the provided MGRS reference.
	 */
	function inverse$1(mgrs) {
	  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	  if (bbox.lat && bbox.lon) {
	    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
	  }
	  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
	}
	function toPoint(mgrs) {
	  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	  if (bbox.lat && bbox.lon) {
	    return [bbox.lon, bbox.lat];
	  }
	  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
	}/**
	 * Conversion from degrees to radians.
	 *
	 * @private
	 * @param {number} deg the angle in degrees.
	 * @return {number} the angle in radians.
	 */
	function degToRad(deg) {
	  return (deg * (Math.PI / 180.0));
	}

	/**
	 * Conversion from radians to degrees.
	 *
	 * @private
	 * @param {number} rad the angle in radians.
	 * @return {number} the angle in degrees.
	 */
	function radToDeg(rad) {
	  return (180.0 * (rad / Math.PI));
	}

	/**
	 * Converts a set of Longitude and Latitude co-ordinates to UTM
	 * using the WGS84 ellipsoid.
	 *
	 * @private
	 * @param {object} ll Object literal with lat and lon properties
	 *     representing the WGS84 coordinate to be converted.
	 * @return {object} Object literal containing the UTM value with easting,
	 *     northing, zoneNumber and zoneLetter properties, and an optional
	 *     accuracy property in digits. Returns null if the conversion failed.
	 */
	function LLtoUTM(ll) {
	  var Lat = ll.lat;
	  var Long = ll.lon;
	  var a = 6378137.0; //ellip.radius;
	  var eccSquared = 0.00669438; //ellip.eccsq;
	  var k0 = 0.9996;
	  var LongOrigin;
	  var eccPrimeSquared;
	  var N, T, C, A, M;
	  var LatRad = degToRad(Lat);
	  var LongRad = degToRad(Long);
	  var LongOriginRad;
	  var ZoneNumber;
	  // (int)
	  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

	  //Make sure the longitude 180.00 is in Zone 60
	  if (Long === 180) {
	    ZoneNumber = 60;
	  }

	  // Special zone for Norway
	  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
	    ZoneNumber = 32;
	  }

	  // Special zones for Svalbard
	  if (Lat >= 72.0 && Lat < 84.0) {
	    if (Long >= 0.0 && Long < 9.0) {
	      ZoneNumber = 31;
	    }
	    else if (Long >= 9.0 && Long < 21.0) {
	      ZoneNumber = 33;
	    }
	    else if (Long >= 21.0 && Long < 33.0) {
	      ZoneNumber = 35;
	    }
	    else if (Long >= 33.0 && Long < 42.0) {
	      ZoneNumber = 37;
	    }
	  }

	  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
	  // in middle of
	  // zone
	  LongOriginRad = degToRad(LongOrigin);

	  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
	  T = Math.tan(LatRad) * Math.tan(LatRad);
	  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
	  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

	  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

	  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

	  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
	  if (Lat < 0.0) {
	    UTMNorthing += 10000000.0; //10000000 meter offset for
	    // southern hemisphere
	  }

	  return {
	    northing: Math.round(UTMNorthing),
	    easting: Math.round(UTMEasting),
	    zoneNumber: ZoneNumber,
	    zoneLetter: getLetterDesignator(Lat)
	  };
	}

	/**
	 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
	 * class where the Zone can be specified as a single string eg."60N" which
	 * is then broken down into the ZoneNumber and ZoneLetter.
	 *
	 * @private
	 * @param {object} utm An object literal with northing, easting, zoneNumber
	 *     and zoneLetter properties. If an optional accuracy property is
	 *     provided (in meters), a bounding box will be returned instead of
	 *     latitude and longitude.
	 * @return {object} An object literal containing either lat and lon values
	 *     (if no accuracy was provided), or top, right, bottom and left values
	 *     for the bounding box calculated according to the provided accuracy.
	 *     Returns null if the conversion failed.
	 */
	function UTMtoLL(utm) {

	  var UTMNorthing = utm.northing;
	  var UTMEasting = utm.easting;
	  var zoneLetter = utm.zoneLetter;
	  var zoneNumber = utm.zoneNumber;
	  // check the ZoneNummber is valid
	  if (zoneNumber < 0 || zoneNumber > 60) {
	    return null;
	  }

	  var k0 = 0.9996;
	  var a = 6378137.0; //ellip.radius;
	  var eccSquared = 0.00669438; //ellip.eccsq;
	  var eccPrimeSquared;
	  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
	  var N1, T1, C1, R1, D, M;
	  var LongOrigin;
	  var mu, phi1Rad;

	  // remove 500,000 meter offset for longitude
	  var x = UTMEasting - 500000.0;
	  var y = UTMNorthing;

	  // We must know somehow if we are in the Northern or Southern
	  // hemisphere, this is the only time we use the letter So even
	  // if the Zone letter isn't exactly correct it should indicate
	  // the hemisphere correctly
	  if (zoneLetter < 'N') {
	    y -= 10000000.0; // remove 10,000,000 meter offset used
	    // for southern hemisphere
	  }

	  // There are 60 zones with zone 1 being at West -180 to -174
	  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
	  // in middle of
	  // zone

	  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	  M = y / k0;
	  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

	  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
	  // double phi1 = ProjMath.radToDeg(phi1Rad);

	  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
	  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
	  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
	  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
	  D = x / (N1 * k0);

	  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
	  lat = radToDeg(lat);

	  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
	  lon = LongOrigin + radToDeg(lon);

	  var result;
	  if (utm.accuracy) {
	    var topRight = UTMtoLL({
	      northing: utm.northing + utm.accuracy,
	      easting: utm.easting + utm.accuracy,
	      zoneLetter: utm.zoneLetter,
	      zoneNumber: utm.zoneNumber
	    });
	    result = {
	      top: topRight.lat,
	      right: topRight.lon,
	      bottom: lat,
	      left: lon
	    };
	  }
	  else {
	    result = {
	      lat: lat,
	      lon: lon
	    };
	  }
	  return result;
	}

	/**
	 * Calculates the MGRS letter designator for the given latitude.
	 *
	 * @private
	 * @param {number} lat The latitude in WGS84 to get the letter designator
	 *     for.
	 * @return {char} The letter designator.
	 */
	function getLetterDesignator(lat) {
	  //This is here as an error flag to show that the Latitude is
	  //outside MGRS limits
	  var LetterDesignator = 'Z';

	  if ((84 >= lat) && (lat >= 72)) {
	    LetterDesignator = 'X';
	  }
	  else if ((72 > lat) && (lat >= 64)) {
	    LetterDesignator = 'W';
	  }
	  else if ((64 > lat) && (lat >= 56)) {
	    LetterDesignator = 'V';
	  }
	  else if ((56 > lat) && (lat >= 48)) {
	    LetterDesignator = 'U';
	  }
	  else if ((48 > lat) && (lat >= 40)) {
	    LetterDesignator = 'T';
	  }
	  else if ((40 > lat) && (lat >= 32)) {
	    LetterDesignator = 'S';
	  }
	  else if ((32 > lat) && (lat >= 24)) {
	    LetterDesignator = 'R';
	  }
	  else if ((24 > lat) && (lat >= 16)) {
	    LetterDesignator = 'Q';
	  }
	  else if ((16 > lat) && (lat >= 8)) {
	    LetterDesignator = 'P';
	  }
	  else if ((8 > lat) && (lat >= 0)) {
	    LetterDesignator = 'N';
	  }
	  else if ((0 > lat) && (lat >= -8)) {
	    LetterDesignator = 'M';
	  }
	  else if ((-8 > lat) && (lat >= -16)) {
	    LetterDesignator = 'L';
	  }
	  else if ((-16 > lat) && (lat >= -24)) {
	    LetterDesignator = 'K';
	  }
	  else if ((-24 > lat) && (lat >= -32)) {
	    LetterDesignator = 'J';
	  }
	  else if ((-32 > lat) && (lat >= -40)) {
	    LetterDesignator = 'H';
	  }
	  else if ((-40 > lat) && (lat >= -48)) {
	    LetterDesignator = 'G';
	  }
	  else if ((-48 > lat) && (lat >= -56)) {
	    LetterDesignator = 'F';
	  }
	  else if ((-56 > lat) && (lat >= -64)) {
	    LetterDesignator = 'E';
	  }
	  else if ((-64 > lat) && (lat >= -72)) {
	    LetterDesignator = 'D';
	  }
	  else if ((-72 > lat) && (lat >= -80)) {
	    LetterDesignator = 'C';
	  }
	  return LetterDesignator;
	}

	/**
	 * Encodes a UTM location as MGRS string.
	 *
	 * @private
	 * @param {object} utm An object literal with easting, northing,
	 *     zoneLetter, zoneNumber
	 * @param {number} accuracy Accuracy in digits (1-5).
	 * @return {string} MGRS string for the given UTM location.
	 */
	function encode(utm, accuracy) {
	  // prepend with leading zeroes
	  var seasting = "00000" + utm.easting,
	    snorthing = "00000" + utm.northing;

	  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
	}

	/**
	 * Get the two letter 100k designator for a given UTM easting,
	 * northing and zone number value.
	 *
	 * @private
	 * @param {number} easting
	 * @param {number} northing
	 * @param {number} zoneNumber
	 * @return the two letter 100k designator for the given UTM location.
	 */
	function get100kID(easting, northing, zoneNumber) {
	  var setParm = get100kSetForZone(zoneNumber);
	  var setColumn = Math.floor(easting / 100000);
	  var setRow = Math.floor(northing / 100000) % 20;
	  return getLetter100kID(setColumn, setRow, setParm);
	}

	/**
	 * Given a UTM zone number, figure out the MGRS 100K set it is in.
	 *
	 * @private
	 * @param {number} i An UTM zone number.
	 * @return {number} the 100k set the UTM zone is in.
	 */
	function get100kSetForZone(i) {
	  var setParm = i % NUM_100K_SETS;
	  if (setParm === 0) {
	    setParm = NUM_100K_SETS;
	  }

	  return setParm;
	}

	/**
	 * Get the two-letter MGRS 100k designator given information
	 * translated from the UTM northing, easting and zone number.
	 *
	 * @private
	 * @param {number} column the column index as it relates to the MGRS
	 *        100k set spreadsheet, created from the UTM easting.
	 *        Values are 1-8.
	 * @param {number} row the row index as it relates to the MGRS 100k set
	 *        spreadsheet, created from the UTM northing value. Values
	 *        are from 0-19.
	 * @param {number} parm the set block, as it relates to the MGRS 100k set
	 *        spreadsheet, created from the UTM zone. Values are from
	 *        1-60.
	 * @return two letter MGRS 100k code.
	 */
	function getLetter100kID(column, row, parm) {
	  // colOrigin and rowOrigin are the letters at the origin of the set
	  var index = parm - 1;
	  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
	  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

	  // colInt and rowInt are the letters to build to return
	  var colInt = colOrigin + column - 1;
	  var rowInt = rowOrigin + row;
	  var rollover = false;

	  if (colInt > Z) {
	    colInt = colInt - Z + A - 1;
	    rollover = true;
	  }

	  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
	    colInt++;
	  }

	  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
	    colInt++;

	    if (colInt === I) {
	      colInt++;
	    }
	  }

	  if (colInt > Z) {
	    colInt = colInt - Z + A - 1;
	  }

	  if (rowInt > V) {
	    rowInt = rowInt - V + A - 1;
	    rollover = true;
	  }
	  else {
	    rollover = false;
	  }

	  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
	    rowInt++;
	  }

	  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
	    rowInt++;

	    if (rowInt === I) {
	      rowInt++;
	    }
	  }

	  if (rowInt > V) {
	    rowInt = rowInt - V + A - 1;
	  }

	  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
	  return twoLetter;
	}

	/**
	 * Decode the UTM parameters from a MGRS string.
	 *
	 * @private
	 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
	 * @return {object} An object literal with easting, northing, zoneLetter,
	 *     zoneNumber and accuracy (in meters) properties.
	 */
	function decode(mgrsString) {

	  if (mgrsString && mgrsString.length === 0) {
	    throw ("MGRSPoint coverting from nothing");
	  }

	  var length = mgrsString.length;

	  var hunK = null;
	  var sb = "";
	  var testChar;
	  var i = 0;

	  // get Zone number
	  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
	    if (i >= 2) {
	      throw ("MGRSPoint bad conversion from: " + mgrsString);
	    }
	    sb += testChar;
	    i++;
	  }

	  var zoneNumber = parseInt(sb, 10);

	  if (i === 0 || i + 3 > length) {
	    // A good MGRS string has to be 4-5 digits long,
	    // ##AAA/#AAA at least.
	    throw ("MGRSPoint bad conversion from: " + mgrsString);
	  }

	  var zoneLetter = mgrsString.charAt(i++);

	  // Should we check the zone letter here? Why not.
	  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
	    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
	  }

	  hunK = mgrsString.substring(i, i += 2);

	  var set = get100kSetForZone(zoneNumber);

	  var east100k = getEastingFromChar(hunK.charAt(0), set);
	  var north100k = getNorthingFromChar(hunK.charAt(1), set);

	  // We have a bug where the northing may be 2000000 too low.
	  // How
	  // do we know when to roll over?

	  while (north100k < getMinNorthing(zoneLetter)) {
	    north100k += 2000000;
	  }

	  // calculate the char index for easting/northing separator
	  var remainder = length - i;

	  if (remainder % 2 !== 0) {
	    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
	  }

	  var sep = remainder / 2;

	  var sepEasting = 0.0;
	  var sepNorthing = 0.0;
	  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
	  if (sep > 0) {
	    accuracyBonus = 100000.0 / Math.pow(10, sep);
	    sepEastingString = mgrsString.substring(i, i + sep);
	    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
	    sepNorthingString = mgrsString.substring(i + sep);
	    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
	  }

	  easting = sepEasting + east100k;
	  northing = sepNorthing + north100k;

	  return {
	    easting: easting,
	    northing: northing,
	    zoneLetter: zoneLetter,
	    zoneNumber: zoneNumber,
	    accuracy: accuracyBonus
	  };
	}

	/**
	 * Given the first letter from a two-letter MGRS 100k zone, and given the
	 * MGRS table set for the zone number, figure out the easting value that
	 * should be added to the other, secondary easting value.
	 *
	 * @private
	 * @param {char} e The first letter from a two-letter MGRS 100k zone.
	 * @param {number} set The MGRS table set for the zone number.
	 * @return {number} The easting value for the given letter and set.
	 */
	function getEastingFromChar(e, set) {
	  // colOrigin is the letter at the origin of the set for the
	  // column
	  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
	  var eastingValue = 100000.0;
	  var rewindMarker = false;

	  while (curCol !== e.charCodeAt(0)) {
	    curCol++;
	    if (curCol === I) {
	      curCol++;
	    }
	    if (curCol === O) {
	      curCol++;
	    }
	    if (curCol > Z) {
	      if (rewindMarker) {
	        throw ("Bad character: " + e);
	      }
	      curCol = A;
	      rewindMarker = true;
	    }
	    eastingValue += 100000.0;
	  }

	  return eastingValue;
	}

	/**
	 * Given the second letter from a two-letter MGRS 100k zone, and given the
	 * MGRS table set for the zone number, figure out the northing value that
	 * should be added to the other, secondary northing value. You have to
	 * remember that Northings are determined from the equator, and the vertical
	 * cycle of letters mean a 2000000 additional northing meters. This happens
	 * approx. every 18 degrees of latitude. This method does *NOT* count any
	 * additional northings. You have to figure out how many 2000000 meters need
	 * to be added for the zone letter of the MGRS coordinate.
	 *
	 * @private
	 * @param {char} n Second letter of the MGRS 100k zone
	 * @param {number} set The MGRS table set number, which is dependent on the
	 *     UTM zone number.
	 * @return {number} The northing value for the given letter and set.
	 */
	function getNorthingFromChar(n, set) {

	  if (n > 'V') {
	    throw ("MGRSPoint given invalid Northing " + n);
	  }

	  // rowOrigin is the letter at the origin of the set for the
	  // column
	  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
	  var northingValue = 0.0;
	  var rewindMarker = false;

	  while (curRow !== n.charCodeAt(0)) {
	    curRow++;
	    if (curRow === I) {
	      curRow++;
	    }
	    if (curRow === O) {
	      curRow++;
	    }
	    // fixing a bug making whole application hang in this loop
	    // when 'n' is a wrong character
	    if (curRow > V) {
	      if (rewindMarker) { // making sure that this loop ends
	        throw ("Bad character: " + n);
	      }
	      curRow = A;
	      rewindMarker = true;
	    }
	    northingValue += 100000.0;
	  }

	  return northingValue;
	}

	/**
	 * The function getMinNorthing returns the minimum northing value of a MGRS
	 * zone.
	 *
	 * Ported from Geotrans' c Lattitude_Band_Value structure table.
	 *
	 * @private
	 * @param {char} zoneLetter The MGRS zone to get the min northing for.
	 * @return {number}
	 */
	function getMinNorthing(zoneLetter) {
	  var northing;
	  switch (zoneLetter) {
	  case 'C':
	    northing = 1100000.0;
	    break;
	  case 'D':
	    northing = 2000000.0;
	    break;
	  case 'E':
	    northing = 2800000.0;
	    break;
	  case 'F':
	    northing = 3700000.0;
	    break;
	  case 'G':
	    northing = 4600000.0;
	    break;
	  case 'H':
	    northing = 5500000.0;
	    break;
	  case 'J':
	    northing = 6400000.0;
	    break;
	  case 'K':
	    northing = 7300000.0;
	    break;
	  case 'L':
	    northing = 8200000.0;
	    break;
	  case 'M':
	    northing = 9100000.0;
	    break;
	  case 'N':
	    northing = 0.0;
	    break;
	  case 'P':
	    northing = 800000.0;
	    break;
	  case 'Q':
	    northing = 1700000.0;
	    break;
	  case 'R':
	    northing = 2600000.0;
	    break;
	  case 'S':
	    northing = 3500000.0;
	    break;
	  case 'T':
	    northing = 4400000.0;
	    break;
	  case 'U':
	    northing = 5300000.0;
	    break;
	  case 'V':
	    northing = 6200000.0;
	    break;
	  case 'W':
	    northing = 7000000.0;
	    break;
	  case 'X':
	    northing = 7900000.0;
	    break;
	  default:
	    northing = -1.0;
	  }
	  if (northing >= 0.0) {
	    return northing;
	  }
	  else {
	    throw ("Invalid zone letter: " + zoneLetter);
	  }

	}

	function Point(x, y, z) {
	  if (!(this instanceof Point)) {
	    return new Point(x, y, z);
	  }
	  if (Array.isArray(x)) {
	    this.x = x[0];
	    this.y = x[1];
	    this.z = x[2] || 0.0;
	  } else if(typeof x === 'object') {
	    this.x = x.x;
	    this.y = x.y;
	    this.z = x.z || 0.0;
	  } else if (typeof x === 'string' && typeof y === 'undefined') {
	    var coords = x.split(',');
	    this.x = parseFloat(coords[0], 10);
	    this.y = parseFloat(coords[1], 10);
	    this.z = parseFloat(coords[2], 10) || 0.0;
	  } else {
	    this.x = x;
	    this.y = y;
	    this.z = z || 0.0;
	  }
	  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
	}

	Point.fromMGRS = function(mgrsStr) {
	  return new Point(toPoint(mgrsStr));
	};
	Point.prototype.toMGRS = function(accuracy) {
	  return forward$1([this.x, this.y], accuracy);
	};

	var C00 = 1;
	var C02 = 0.25;
	var C04 = 0.046875;
	var C06 = 0.01953125;
	var C08 = 0.01068115234375;
	var C22 = 0.75;
	var C44 = 0.46875;
	var C46 = 0.01302083333333333333;
	var C48 = 0.00712076822916666666;
	var C66 = 0.36458333333333333333;
	var C68 = 0.00569661458333333333;
	var C88 = 0.3076171875;

	function pj_enfn(es) {
	  var en = [];
	  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
	  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
	  var t = es * es;
	  en[2] = t * (C44 - es * (C46 + es * C48));
	  t *= es;
	  en[3] = t * (C66 - es * C68);
	  en[4] = t * es * C88;
	  return en;
	}

	function pj_mlfn(phi, sphi, cphi, en) {
	  cphi *= sphi;
	  sphi *= sphi;
	  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
	}

	var MAX_ITER = 20;

	function pj_inv_mlfn(arg, es, en) {
	  var k = 1 / (1 - es);
	  var phi = arg;
	  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
	    var s = Math.sin(phi);
	    var t = 1 - es * s * s;
	    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
	    //phi -= t * (t * Math.sqrt(t)) * k;
	    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
	    phi -= t;
	    if (Math.abs(t) < EPSLN) {
	      return phi;
	    }
	  }
	  //..reportError("cass:pj_inv_mlfn: Convergence error");
	  return phi;
	}

	// Heavily based on this tmerc projection implementation

	function init$2() {
	  this.x0 = this.x0 !== undefined ? this.x0 : 0;
	  this.y0 = this.y0 !== undefined ? this.y0 : 0;
	  this.long0 = this.long0 !== undefined ? this.long0 : 0;
	  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

	  if (this.es) {
	    this.en = pj_enfn(this.es);
	    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
	  }
	}

	/**
	    Transverse Mercator Forward  - long/lat to x/y
	    long/lat in radians
	  */
	function forward$2(p) {
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lon = adjust_lon(lon - this.long0);
	  var con;
	  var x, y;
	  var sin_phi = Math.sin(lat);
	  var cos_phi = Math.cos(lat);

	  if (!this.es) {
	    var b = cos_phi * Math.sin(delta_lon);

	    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
	      return (93);
	    }
	    else {
	      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
	      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
	      b = Math.abs(y);

	      if (b >= 1) {
	        if ((b - 1) > EPSLN) {
	          return (93);
	        }
	        else {
	          y = 0;
	        }
	      }
	      else {
	        y = Math.acos(y);
	      }

	      if (lat < 0) {
	        y = -y;
	      }

	      y = this.a * this.k0 * (y - this.lat0) + this.y0;
	    }
	  }
	  else {
	    var al = cos_phi * delta_lon;
	    var als = Math.pow(al, 2);
	    var c = this.ep2 * Math.pow(cos_phi, 2);
	    var cs = Math.pow(c, 2);
	    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
	    var t = Math.pow(tq, 2);
	    var ts = Math.pow(t, 2);
	    con = 1 - this.es * Math.pow(sin_phi, 2);
	    al = al / Math.sqrt(con);
	    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

	    x = this.a * (this.k0 * al * (1 +
	      als / 6 * (1 - t + c +
	      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
	      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
	      this.x0;

	    y = this.a * (this.k0 * (ml - this.ml0 +
	      sin_phi * delta_lon * al / 2 * (1 +
	      als / 12 * (5 - t + 9 * c + 4 * cs +
	      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
	      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
	      this.y0;
	  }

	  p.x = x;
	  p.y = y;

	  return p;
	}

	/**
	    Transverse Mercator Inverse  -  x/y to long/lat
	  */
	function inverse$2(p) {
	  var con, phi;
	  var lat, lon;
	  var x = (p.x - this.x0) * (1 / this.a);
	  var y = (p.y - this.y0) * (1 / this.a);

	  if (!this.es) {
	    var f = Math.exp(x / this.k0);
	    var g = 0.5 * (f - 1 / f);
	    var temp = this.lat0 + y / this.k0;
	    var h = Math.cos(temp);
	    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
	    lat = Math.asin(con);

	    if (y < 0) {
	      lat = -lat;
	    }

	    if ((g === 0) && (h === 0)) {
	      lon = 0;
	    }
	    else {
	      lon = adjust_lon(Math.atan2(g, h) + this.long0);
	    }
	  }
	  else { // ellipsoidal form
	    con = this.ml0 + y / this.k0;
	    phi = pj_inv_mlfn(con, this.es, this.en);

	    if (Math.abs(phi) < HALF_PI) {
	      var sin_phi = Math.sin(phi);
	      var cos_phi = Math.cos(phi);
	      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
	      var c = this.ep2 * Math.pow(cos_phi, 2);
	      var cs = Math.pow(c, 2);
	      var t = Math.pow(tan_phi, 2);
	      var ts = Math.pow(t, 2);
	      con = 1 - this.es * Math.pow(sin_phi, 2);
	      var d = x * Math.sqrt(con) / this.k0;
	      var ds = Math.pow(d, 2);
	      con = con * tan_phi;

	      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
	        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
	        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
	        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

	      lon = adjust_lon(this.long0 + (d * (1 -
	        ds / 6 * (1 + 2 * t + c -
	        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
	        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
	    }
	    else {
	      lat = HALF_PI * sign(y);
	      lon = 0;
	    }
	  }

	  p.x = lon;
	  p.y = lat;

	  return p;
	}

	var names$3 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
	var tmerc = {
	  init: init$2,
	  forward: forward$2,
	  inverse: inverse$2,
	  names: names$3
	};

	function sinh(x) {
	  var r = Math.exp(x);
	  r = (r - 1 / r) / 2;
	  return r;
	}

	function hypot(x, y) {
	  x = Math.abs(x);
	  y = Math.abs(y);
	  var a = Math.max(x, y);
	  var b = Math.min(x, y) / (a ? a : 1);

	  return a * Math.sqrt(1 + Math.pow(b, 2));
	}

	function log1py(x) {
	  var y = 1 + x;
	  var z = y - 1;

	  return z === 0 ? x : x * Math.log(y) / z;
	}

	function asinhy(x) {
	  var y = Math.abs(x);
	  y = log1py(y * (1 + y / (hypot(1, y) + 1)));

	  return x < 0 ? -y : y;
	}

	function gatg(pp, B) {
	  var cos_2B = 2 * Math.cos(2 * B);
	  var i = pp.length - 1;
	  var h1 = pp[i];
	  var h2 = 0;
	  var h;

	  while (--i >= 0) {
	    h = -h2 + cos_2B * h1 + pp[i];
	    h2 = h1;
	    h1 = h;
	  }

	  return (B + h * Math.sin(2 * B));
	}

	function clens(pp, arg_r) {
	  var r = 2 * Math.cos(arg_r);
	  var i = pp.length - 1;
	  var hr1 = pp[i];
	  var hr2 = 0;
	  var hr;

	  while (--i >= 0) {
	    hr = -hr2 + r * hr1 + pp[i];
	    hr2 = hr1;
	    hr1 = hr;
	  }

	  return Math.sin(arg_r) * hr;
	}

	function cosh(x) {
	  var r = Math.exp(x);
	  r = (r + 1 / r) / 2;
	  return r;
	}

	function clens_cmplx(pp, arg_r, arg_i) {
	  var sin_arg_r = Math.sin(arg_r);
	  var cos_arg_r = Math.cos(arg_r);
	  var sinh_arg_i = sinh(arg_i);
	  var cosh_arg_i = cosh(arg_i);
	  var r = 2 * cos_arg_r * cosh_arg_i;
	  var i = -2 * sin_arg_r * sinh_arg_i;
	  var j = pp.length - 1;
	  var hr = pp[j];
	  var hi1 = 0;
	  var hr1 = 0;
	  var hi = 0;
	  var hr2;
	  var hi2;

	  while (--j >= 0) {
	    hr2 = hr1;
	    hi2 = hi1;
	    hr1 = hr;
	    hi1 = hi;
	    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
	    hi = -hi2 + i * hr1 + r * hi1;
	  }

	  r = sin_arg_r * cosh_arg_i;
	  i = cos_arg_r * sinh_arg_i;

	  return [r * hr - i * hi, r * hi + i * hr];
	}

	// Heavily based on this etmerc projection implementation

	function init$3() {
	  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
	    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
	  }
	  if (this.approx) {
	    // When '+approx' is set, use tmerc instead
	    tmerc.init.apply(this);
	    this.forward = tmerc.forward;
	    this.inverse = tmerc.inverse;
	  }

	  this.x0 = this.x0 !== undefined ? this.x0 : 0;
	  this.y0 = this.y0 !== undefined ? this.y0 : 0;
	  this.long0 = this.long0 !== undefined ? this.long0 : 0;
	  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

	  this.cgb = [];
	  this.cbg = [];
	  this.utg = [];
	  this.gtu = [];

	  var f = this.es / (1 + Math.sqrt(1 - this.es));
	  var n = f / (2 - f);
	  var np = n;

	  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
	  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

	  np = np * n;
	  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
	  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

	  np = np * n;
	  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
	  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

	  np = np * n;
	  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
	  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

	  np = np * n;
	  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
	  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

	  np = np * n;
	  this.cgb[5] = np * (601676 / 22275);
	  this.cbg[5] = np * (444337 / 155925);

	  np = Math.pow(n, 2);
	  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

	  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
	  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

	  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
	  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

	  np = np * n;
	  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
	  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

	  np = np * n;
	  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
	  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

	  np = np * n;
	  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
	  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

	  np = np * n;
	  this.utg[5] = np * (-20648693 / 638668800);
	  this.gtu[5] = np * (212378941 / 319334400);

	  var Z = gatg(this.cbg, this.lat0);
	  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
	}

	function forward$3(p) {
	  var Ce = adjust_lon(p.x - this.long0);
	  var Cn = p.y;

	  Cn = gatg(this.cbg, Cn);
	  var sin_Cn = Math.sin(Cn);
	  var cos_Cn = Math.cos(Cn);
	  var sin_Ce = Math.sin(Ce);
	  var cos_Ce = Math.cos(Ce);

	  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
	  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
	  Ce = asinhy(Math.tan(Ce));

	  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

	  Cn = Cn + tmp[0];
	  Ce = Ce + tmp[1];

	  var x;
	  var y;

	  if (Math.abs(Ce) <= 2.623395162778) {
	    x = this.a * (this.Qn * Ce) + this.x0;
	    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
	  }
	  else {
	    x = Infinity;
	    y = Infinity;
	  }

	  p.x = x;
	  p.y = y;

	  return p;
	}

	function inverse$3(p) {
	  var Ce = (p.x - this.x0) * (1 / this.a);
	  var Cn = (p.y - this.y0) * (1 / this.a);

	  Cn = (Cn - this.Zb) / this.Qn;
	  Ce = Ce / this.Qn;

	  var lon;
	  var lat;

	  if (Math.abs(Ce) <= 2.623395162778) {
	    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

	    Cn = Cn + tmp[0];
	    Ce = Ce + tmp[1];
	    Ce = Math.atan(sinh(Ce));

	    var sin_Cn = Math.sin(Cn);
	    var cos_Cn = Math.cos(Cn);
	    var sin_Ce = Math.sin(Ce);
	    var cos_Ce = Math.cos(Ce);

	    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
	    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

	    lon = adjust_lon(Ce + this.long0);
	    lat = gatg(this.cgb, Cn);
	  }
	  else {
	    lon = Infinity;
	    lat = Infinity;
	  }

	  p.x = lon;
	  p.y = lat;

	  return p;
	}

	var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
	var etmerc = {
	  init: init$3,
	  forward: forward$3,
	  inverse: inverse$3,
	  names: names$4
	};

	function adjust_zone(zone, lon) {
	  if (zone === undefined) {
	    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

	    if (zone < 0) {
	      return 0;
	    } else if (zone > 60) {
	      return 60;
	    }
	  }
	  return zone;
	}

	var dependsOn = 'etmerc';


	function init$4() {
	  var zone = adjust_zone(this.zone, this.long0);
	  if (zone === undefined) {
	    throw new Error('unknown utm zone');
	  }
	  this.lat0 = 0;
	  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
	  this.x0 = 500000;
	  this.y0 = this.utmSouth ? 10000000 : 0;
	  this.k0 = 0.9996;

	  etmerc.init.apply(this);
	  this.forward = etmerc.forward;
	  this.inverse = etmerc.inverse;
	}

	var names$5 = ["Universal Transverse Mercator System", "utm"];
	var utm = {
	  init: init$4,
	  names: names$5,
	  dependsOn: dependsOn
	};

	function srat(esinp, exp) {
	  return (Math.pow((1 - esinp) / (1 + esinp), exp));
	}

	var MAX_ITER$1 = 20;

	function init$5() {
	  var sphi = Math.sin(this.lat0);
	  var cphi = Math.cos(this.lat0);
	  cphi *= cphi;
	  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
	  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
	  this.phic0 = Math.asin(sphi / this.C);
	  this.ratexp = 0.5 * this.C * this.e;
	  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
	}

	function forward$4(p) {
	  var lon = p.x;
	  var lat = p.y;

	  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
	  p.x = this.C * lon;
	  return p;
	}

	function inverse$4(p) {
	  var DEL_TOL = 1e-14;
	  var lon = p.x / this.C;
	  var lat = p.y;
	  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
	  for (var i = MAX_ITER$1; i > 0; --i) {
	    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
	    if (Math.abs(lat - p.y) < DEL_TOL) {
	      break;
	    }
	    p.y = lat;
	  }
	  /* convergence failed */
	  if (!i) {
	    return null;
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$6 = ["gauss"];
	var gauss = {
	  init: init$5,
	  forward: forward$4,
	  inverse: inverse$4,
	  names: names$6
	};

	function init$6() {
	  gauss.init.apply(this);
	  if (!this.rc) {
	    return;
	  }
	  this.sinc0 = Math.sin(this.phic0);
	  this.cosc0 = Math.cos(this.phic0);
	  this.R2 = 2 * this.rc;
	  if (!this.title) {
	    this.title = "Oblique Stereographic Alternative";
	  }
	}

	function forward$5(p) {
	  var sinc, cosc, cosl, k;
	  p.x = adjust_lon(p.x - this.long0);
	  gauss.forward.apply(this, [p]);
	  sinc = Math.sin(p.y);
	  cosc = Math.cos(p.y);
	  cosl = Math.cos(p.x);
	  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
	  p.x = k * cosc * Math.sin(p.x);
	  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
	  p.x = this.a * p.x + this.x0;
	  p.y = this.a * p.y + this.y0;
	  return p;
	}

	function inverse$5(p) {
	  var sinc, cosc, lon, lat, rho;
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  p.x /= this.k0;
	  p.y /= this.k0;
	  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
	    var c = 2 * Math.atan2(rho, this.R2);
	    sinc = Math.sin(c);
	    cosc = Math.cos(c);
	    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
	    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
	  }
	  else {
	    lat = this.phic0;
	    lon = 0;
	  }

	  p.x = lon;
	  p.y = lat;
	  gauss.inverse.apply(this, [p]);
	  p.x = adjust_lon(p.x + this.long0);
	  return p;
	}

	var names$7 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
	var sterea = {
	  init: init$6,
	  forward: forward$5,
	  inverse: inverse$5,
	  names: names$7
	};

	function ssfn_(phit, sinphi, eccen) {
	  sinphi *= eccen;
	  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
	}

	function init$7() {
	  this.coslat0 = Math.cos(this.lat0);
	  this.sinlat0 = Math.sin(this.lat0);
	  if (this.sphere) {
	    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
	    }
	  }
	  else {
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      if (this.lat0 > 0) {
	        //North pole
	        //trace('stere:north pole');
	        this.con = 1;
	      }
	      else {
	        //South pole
	        //trace('stere:south pole');
	        this.con = -1;
	      }
	    }
	    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
	    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
	    }
	    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
	    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
	    this.cosX0 = Math.cos(this.X0);
	    this.sinX0 = Math.sin(this.X0);
	  }
	}

	// Stereographic forward equations--mapping lat,long to x,y
	function forward$6(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var sinlat = Math.sin(lat);
	  var coslat = Math.cos(lat);
	  var A, X, sinX, cosX, ts, rh;
	  var dlon = adjust_lon(lon - this.long0);

	  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
	    //case of the origine point
	    //trace('stere:this is the origin point');
	    p.x = NaN;
	    p.y = NaN;
	    return p;
	  }
	  if (this.sphere) {
	    //trace('stere:sphere case');
	    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
	    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
	    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
	    return p;
	  }
	  else {
	    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
	    cosX = Math.cos(X);
	    sinX = Math.sin(X);
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
	      rh = 2 * this.a * this.k0 * ts / this.cons;
	      p.x = this.x0 + rh * Math.sin(lon - this.long0);
	      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
	      //trace(p.toString());
	      return p;
	    }
	    else if (Math.abs(this.sinlat0) < EPSLN) {
	      //Eq
	      //trace('stere:equateur');
	      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
	      p.y = A * sinX;
	    }
	    else {
	      //other case
	      //trace('stere:normal case');
	      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
	      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
	    }
	    p.x = A * cosX * Math.sin(dlon) + this.x0;
	  }
	  //trace(p.toString());
	  return p;
	}

	//* Stereographic inverse equations--mapping x,y to lat/long
	function inverse$6(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var lon, lat, ts, ce, Chi;
	  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
	  if (this.sphere) {
	    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
	    lon = this.long0;
	    lat = this.lat0;
	    if (rh <= EPSLN) {
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
	    if (Math.abs(this.coslat0) < EPSLN) {
	      if (this.lat0 > 0) {
	        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	      }
	      else {
	        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	      }
	    }
	    else {
	      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
	    }
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      if (rh <= EPSLN) {
	        lat = this.lat0;
	        lon = this.long0;
	        p.x = lon;
	        p.y = lat;
	        //trace(p.toString());
	        return p;
	      }
	      p.x *= this.con;
	      p.y *= this.con;
	      ts = rh * this.cons / (2 * this.a * this.k0);
	      lat = this.con * phi2z(this.e, ts);
	      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
	    }
	    else {
	      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
	      lon = this.long0;
	      if (rh <= EPSLN) {
	        Chi = this.X0;
	      }
	      else {
	        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
	        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
	      }
	      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
	    }
	  }
	  p.x = lon;
	  p.y = lat;

	  //trace(p.toString());
	  return p;

	}

	var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
	var stere = {
	  init: init$7,
	  forward: forward$6,
	  inverse: inverse$6,
	  names: names$8,
	  ssfn_: ssfn_
	};

	/*
	  references:
	    Formules et constantes pour le Calcul pour la
	    projection cylindrique conforme  axe oblique et pour la transformation entre
	    des systmes de rfrence.
	    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
	  */

	function init$8() {
	  var phy0 = this.lat0;
	  this.lambda0 = this.long0;
	  var sinPhy0 = Math.sin(phy0);
	  var semiMajorAxis = this.a;
	  var invF = this.rf;
	  var flattening = 1 / invF;
	  var e2 = 2 * flattening - Math.pow(flattening, 2);
	  var e = this.e = Math.sqrt(e2);
	  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
	  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
	  this.b0 = Math.asin(sinPhy0 / this.alpha);
	  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
	  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
	  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
	  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
	}

	function forward$7(p) {
	  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
	  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
	  var S = -this.alpha * (Sa1 + Sa2) + this.K;

	  // spheric latitude
	  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

	  // spheric longitude
	  var I = this.alpha * (p.x - this.lambda0);

	  // psoeudo equatorial rotation
	  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

	  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

	  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
	  p.x = this.R * rotI + this.x0;
	  return p;
	}

	function inverse$7(p) {
	  var Y = p.x - this.x0;
	  var X = p.y - this.y0;

	  var rotI = Y / this.R;
	  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

	  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
	  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

	  var lambda = this.lambda0 + I / this.alpha;

	  var S = 0;
	  var phy = b;
	  var prevPhy = -1000;
	  var iteration = 0;
	  while (Math.abs(phy - prevPhy) > 0.0000001) {
	    if (++iteration > 20) {
	      //...reportError("omercFwdInfinity");
	      return;
	    }
	    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
	    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
	    prevPhy = phy;
	    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
	  }

	  p.x = lambda;
	  p.y = phy;
	  return p;
	}

	var names$9 = ["somerc"];
	var somerc = {
	  init: init$8,
	  forward: forward$7,
	  inverse: inverse$7,
	  names: names$9
	};

	/* Initialize the Oblique Mercator  projection
	    ------------------------------------------*/
	function init$9() {
	  this.no_off = this.no_off || false;
	  this.no_rot = this.no_rot || false;

	  if (isNaN(this.k0)) {
	    this.k0 = 1;
	  }
	  var sinlat = Math.sin(this.lat0);
	  var coslat = Math.cos(this.lat0);
	  var con = this.e * sinlat;

	  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
	  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
	  var t0 = tsfnz(this.e, this.lat0, sinlat);
	  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
	  if (dl * dl < 1) {
	    dl = 1;
	  }
	  var fl;
	  var gl;
	  if (!isNaN(this.longc)) {
	    //Central point and azimuth method

	    if (this.lat0 >= 0) {
	      fl = dl + Math.sqrt(dl * dl - 1);
	    }
	    else {
	      fl = dl - Math.sqrt(dl * dl - 1);
	    }
	    this.el = fl * Math.pow(t0, this.bl);
	    gl = 0.5 * (fl - 1 / fl);
	    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
	    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

	  }
	  else {
	    //2 points method
	    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
	    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
	    if (this.lat0 >= 0) {
	      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
	    }
	    else {
	      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
	    }
	    var hl = Math.pow(t1, this.bl);
	    var ll = Math.pow(t2, this.bl);
	    fl = this.el / hl;
	    gl = 0.5 * (fl - 1 / fl);
	    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
	    var pl = (ll - hl) / (ll + hl);
	    var dlon12 = adjust_lon(this.long1 - this.long2);
	    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
	    this.long0 = adjust_lon(this.long0);
	    var dlon10 = adjust_lon(this.long1 - this.long0);
	    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
	    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
	  }

	  if (this.no_off) {
	    this.uc = 0;
	  }
	  else {
	    if (this.lat0 >= 0) {
	      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
	    }
	    else {
	      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
	    }
	  }

	}

	/* Oblique Mercator forward equations--mapping lat,long to x,y
	    ----------------------------------------------------------*/
	function forward$8(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var dlon = adjust_lon(lon - this.long0);
	  var us, vs;
	  var con;
	  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	    if (lat > 0) {
	      con = -1;
	    }
	    else {
	      con = 1;
	    }
	    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
	    us = -1 * con * HALF_PI * this.al / this.bl;
	  }
	  else {
	    var t = tsfnz(this.e, lat, Math.sin(lat));
	    var ql = this.el / Math.pow(t, this.bl);
	    var sl = 0.5 * (ql - 1 / ql);
	    var tl = 0.5 * (ql + 1 / ql);
	    var vl = Math.sin(this.bl * (dlon));
	    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
	    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
	      vs = Number.POSITIVE_INFINITY;
	    }
	    else {
	      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
	    }
	    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
	      us = this.al * this.bl * (dlon);
	    }
	    else {
	      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
	    }
	  }

	  if (this.no_rot) {
	    p.x = this.x0 + us;
	    p.y = this.y0 + vs;
	  }
	  else {

	    us -= this.uc;
	    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
	    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
	  }
	  return p;
	}

	function inverse$8(p) {
	  var us, vs;
	  if (this.no_rot) {
	    vs = p.y - this.y0;
	    us = p.x - this.x0;
	  }
	  else {
	    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
	    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
	    us += this.uc;
	  }
	  var qp = Math.exp(-1 * this.bl * vs / this.al);
	  var sp = 0.5 * (qp - 1 / qp);
	  var tp = 0.5 * (qp + 1 / qp);
	  var vp = Math.sin(this.bl * us / this.al);
	  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
	  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
	  if (Math.abs(up - 1) < EPSLN) {
	    p.x = this.long0;
	    p.y = HALF_PI;
	  }
	  else if (Math.abs(up + 1) < EPSLN) {
	    p.x = this.long0;
	    p.y = -1 * HALF_PI;
	  }
	  else {
	    p.y = phi2z(this.e, ts);
	    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
	  }
	  return p;
	}

	var names$a = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
	var omerc = {
	  init: init$9,
	  forward: forward$8,
	  inverse: inverse$8,
	  names: names$a
	};

	function init$a() {

	  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
	  //double c_lat;                   /* center latitude                      */
	  //double c_lon;                   /* center longitude                     */
	  //double lat1;                    /* first standard parallel              */
	  //double lat2;                    /* second standard parallel             */
	  //double r_maj;                   /* major axis                           */
	  //double r_min;                   /* minor axis                           */
	  //double false_east;              /* x offset in meters                   */
	  //double false_north;             /* y offset in meters                   */

	  if (!this.lat2) {
	    this.lat2 = this.lat1;
	  } //if lat2 is not defined
	  if (!this.k0) {
	    this.k0 = 1;
	  }
	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  // Standard Parallels cannot be equal and on opposite sides of the equator
	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }

	  var temp = this.b / this.a;
	  this.e = Math.sqrt(1 - temp * temp);

	  var sin1 = Math.sin(this.lat1);
	  var cos1 = Math.cos(this.lat1);
	  var ms1 = msfnz(this.e, sin1, cos1);
	  var ts1 = tsfnz(this.e, this.lat1, sin1);

	  var sin2 = Math.sin(this.lat2);
	  var cos2 = Math.cos(this.lat2);
	  var ms2 = msfnz(this.e, sin2, cos2);
	  var ts2 = tsfnz(this.e, this.lat2, sin2);

	  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

	  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
	  }
	  else {
	    this.ns = sin1;
	  }
	  if (isNaN(this.ns)) {
	    this.ns = sin1;
	  }
	  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
	  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
	  if (!this.title) {
	    this.title = "Lambert Conformal Conic";
	  }
	}

	// Lambert Conformal conic forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	function forward$9(p) {

	  var lon = p.x;
	  var lat = p.y;

	  // singular cases :
	  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
	    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
	  }

	  var con = Math.abs(Math.abs(lat) - HALF_PI);
	  var ts, rh1;
	  if (con > EPSLN) {
	    ts = tsfnz(this.e, lat, Math.sin(lat));
	    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
	  }
	  else {
	    con = lat * this.ns;
	    if (con <= 0) {
	      return null;
	    }
	    rh1 = 0;
	  }
	  var theta = this.ns * adjust_lon(lon - this.long0);
	  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
	  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

	  return p;
	}

	// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	function inverse$9(p) {

	  var rh1, con, ts;
	  var lat, lon;
	  var x = (p.x - this.x0) / this.k0;
	  var y = (this.rh - (p.y - this.y0) / this.k0);
	  if (this.ns > 0) {
	    rh1 = Math.sqrt(x * x + y * y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(x * x + y * y);
	    con = -1;
	  }
	  var theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2((con * x), (con * y));
	  }
	  if ((rh1 !== 0) || (this.ns > 0)) {
	    con = 1 / this.ns;
	    ts = Math.pow((rh1 / (this.a * this.f0)), con);
	    lat = phi2z(this.e, ts);
	    if (lat === -9999) {
	      return null;
	    }
	  }
	  else {
	    lat = -HALF_PI;
	  }
	  lon = adjust_lon(theta / this.ns + this.long0);

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$b = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
	var lcc = {
	  init: init$a,
	  forward: forward$9,
	  inverse: inverse$9,
	  names: names$b
	};

	function init$b() {
	  this.a = 6377397.155;
	  this.es = 0.006674372230614;
	  this.e = Math.sqrt(this.es);
	  if (!this.lat0) {
	    this.lat0 = 0.863937979737193;
	  }
	  if (!this.long0) {
	    this.long0 = 0.7417649320975901 - 0.308341501185665;
	  }
	  /* if scale not set default to 0.9999 */
	  if (!this.k0) {
	    this.k0 = 0.9999;
	  }
	  this.s45 = 0.785398163397448; /* 45 */
	  this.s90 = 2 * this.s45;
	  this.fi0 = this.lat0;
	  this.e2 = this.es;
	  this.e = Math.sqrt(this.e2);
	  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
	  this.uq = 1.04216856380474;
	  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
	  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
	  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
	  this.k1 = this.k0;
	  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
	  this.s0 = 1.37008346281555;
	  this.n = Math.sin(this.s0);
	  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
	  this.ad = this.s90 - this.uq;
	}

	/* ellipsoid */
	/* calculate xy from lat/lon */
	/* Constants, identical to inverse transform function */
	function forward$a(p) {
	  var gfi, u, deltav, s, d, eps, ro;
	  var lon = p.x;
	  var lat = p.y;
	  var delta_lon = adjust_lon(lon - this.long0);
	  /* Transformation */
	  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
	  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
	  deltav = -delta_lon * this.alfa;
	  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
	  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
	  eps = this.n * d;
	  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
	  p.y = ro * Math.cos(eps) / 1;
	  p.x = ro * Math.sin(eps) / 1;

	  if (!this.czech) {
	    p.y *= -1;
	    p.x *= -1;
	  }
	  return (p);
	}

	/* calculate lat/lon from xy */
	function inverse$a(p) {
	  var u, deltav, s, d, eps, ro, fi1;
	  var ok;

	  /* Transformation */
	  /* revert y, x*/
	  var tmp = p.x;
	  p.x = p.y;
	  p.y = tmp;
	  if (!this.czech) {
	    p.y *= -1;
	    p.x *= -1;
	  }
	  ro = Math.sqrt(p.x * p.x + p.y * p.y);
	  eps = Math.atan2(p.y, p.x);
	  d = eps / Math.sin(this.s0);
	  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
	  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
	  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
	  p.x = this.long0 - deltav / this.alfa;
	  fi1 = u;
	  ok = 0;
	  var iter = 0;
	  do {
	    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
	    if (Math.abs(fi1 - p.y) < 0.0000000001) {
	      ok = 1;
	    }
	    fi1 = p.y;
	    iter += 1;
	  } while (ok === 0 && iter < 15);
	  if (iter >= 15) {
	    return null;
	  }

	  return (p);
	}

	var names$c = ["Krovak", "krovak"];
	var krovak = {
	  init: init$b,
	  forward: forward$a,
	  inverse: inverse$a,
	  names: names$c
	};

	function mlfn(e0, e1, e2, e3, phi) {
	  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
	}

	function e0fn(x) {
	  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
	}

	function e1fn(x) {
	  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
	}

	function e2fn(x) {
	  return (0.05859375 * x * x * (1 + 0.75 * x));
	}

	function e3fn(x) {
	  return (x * x * x * (35 / 3072));
	}

	function gN(a, e, sinphi) {
	  var temp = e * sinphi;
	  return a / Math.sqrt(1 - temp * temp);
	}

	function adjust_lat(x) {
	  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
	}

	function imlfn(ml, e0, e1, e2, e3) {
	  var phi;
	  var dphi;

	  phi = ml / e0;
	  for (var i = 0; i < 15; i++) {
	    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }

	  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
	  return NaN;
	}

	function init$c() {
	  if (!this.sphere) {
	    this.e0 = e0fn(this.es);
	    this.e1 = e1fn(this.es);
	    this.e2 = e2fn(this.es);
	    this.e3 = e3fn(this.es);
	    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	  }
	}

	/* Cassini forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------------------*/
	function forward$b(p) {

	  /* Forward equations
	      -----------------*/
	  var x, y;
	  var lam = p.x;
	  var phi = p.y;
	  lam = adjust_lon(lam - this.long0);

	  if (this.sphere) {
	    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
	    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
	  }
	  else {
	    //ellipsoid
	    var sinphi = Math.sin(phi);
	    var cosphi = Math.cos(phi);
	    var nl = gN(this.a, this.e, sinphi);
	    var tl = Math.tan(phi) * Math.tan(phi);
	    var al = lam * Math.cos(phi);
	    var asq = al * al;
	    var cl = this.es * cosphi * cosphi / (1 - this.es);
	    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

	    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
	    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


	  }

	  p.x = x + this.x0;
	  p.y = y + this.y0;
	  return p;
	}

	/* Inverse equations
	  -----------------*/
	function inverse$b(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var x = p.x / this.a;
	  var y = p.y / this.a;
	  var phi, lam;

	  if (this.sphere) {
	    var dd = y + this.lat0;
	    phi = Math.asin(Math.sin(dd) * Math.cos(x));
	    lam = Math.atan2(Math.tan(x), Math.cos(dd));
	  }
	  else {
	    /* ellipsoid */
	    var ml1 = this.ml0 / this.a + y;
	    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
	    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
	      p.x = this.long0;
	      p.y = HALF_PI;
	      if (y < 0) {
	        p.y *= -1;
	      }
	      return p;
	    }
	    var nl1 = gN(this.a, this.e, Math.sin(phi1));

	    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
	    var tl1 = Math.pow(Math.tan(phi1), 2);
	    var dl = x * this.a / nl1;
	    var dsq = dl * dl;
	    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
	    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

	  }

	  p.x = adjust_lon(lam + this.long0);
	  p.y = adjust_lat(phi);
	  return p;

	}

	var names$d = ["Cassini", "Cassini_Soldner", "cass"];
	var cass = {
	  init: init$c,
	  forward: forward$b,
	  inverse: inverse$b,
	  names: names$d
	};

	function qsfnz(eccent, sinphi) {
	  var con;
	  if (eccent > 1.0e-7) {
	    con = eccent * sinphi;
	    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
	  }
	  else {
	    return (2 * sinphi);
	  }
	}

	/*
	  reference
	    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	  */

	var S_POLE = 1;

	var N_POLE = 2;
	var EQUIT = 3;
	var OBLIQ = 4;

	/* Initialize the Lambert Azimuthal Equal Area projection
	  ------------------------------------------------------*/
	function init$d() {
	  var t = Math.abs(this.lat0);
	  if (Math.abs(t - HALF_PI) < EPSLN) {
	    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
	  }
	  else if (Math.abs(t) < EPSLN) {
	    this.mode = this.EQUIT;
	  }
	  else {
	    this.mode = this.OBLIQ;
	  }
	  if (this.es > 0) {
	    var sinphi;

	    this.qp = qsfnz(this.e, 1);
	    this.mmf = 0.5 / (1 - this.es);
	    this.apa = authset(this.es);
	    switch (this.mode) {
	    case this.N_POLE:
	      this.dd = 1;
	      break;
	    case this.S_POLE:
	      this.dd = 1;
	      break;
	    case this.EQUIT:
	      this.rq = Math.sqrt(0.5 * this.qp);
	      this.dd = 1 / this.rq;
	      this.xmf = 1;
	      this.ymf = 0.5 * this.qp;
	      break;
	    case this.OBLIQ:
	      this.rq = Math.sqrt(0.5 * this.qp);
	      sinphi = Math.sin(this.lat0);
	      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
	      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
	      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
	      this.ymf = (this.xmf = this.rq) / this.dd;
	      this.xmf *= this.dd;
	      break;
	    }
	  }
	  else {
	    if (this.mode === this.OBLIQ) {
	      this.sinph0 = Math.sin(this.lat0);
	      this.cosph0 = Math.cos(this.lat0);
	    }
	  }
	}

	/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------------------*/
	function forward$c(p) {

	  /* Forward equations
	      -----------------*/
	  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
	  var lam = p.x;
	  var phi = p.y;

	  lam = adjust_lon(lam - this.long0);
	  if (this.sphere) {
	    sinphi = Math.sin(phi);
	    cosphi = Math.cos(phi);
	    coslam = Math.cos(lam);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
	      if (y <= EPSLN) {
	        return null;
	      }
	      y = Math.sqrt(2 / y);
	      x = y * cosphi * Math.sin(lam);
	      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
	    }
	    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	      if (this.mode === this.N_POLE) {
	        coslam = -coslam;
	      }
	      if (Math.abs(phi + this.lat0) < EPSLN) {
	        return null;
	      }
	      y = FORTPI - phi * 0.5;
	      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
	      x = y * Math.sin(lam);
	      y *= coslam;
	    }
	  }
	  else {
	    sinb = 0;
	    cosb = 0;
	    b = 0;
	    coslam = Math.cos(lam);
	    sinlam = Math.sin(lam);
	    sinphi = Math.sin(phi);
	    q = qsfnz(this.e, sinphi);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      sinb = q / this.qp;
	      cosb = Math.sqrt(1 - sinb * sinb);
	    }
	    switch (this.mode) {
	    case this.OBLIQ:
	      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
	      break;
	    case this.EQUIT:
	      b = 1 + cosb * coslam;
	      break;
	    case this.N_POLE:
	      b = HALF_PI + phi;
	      q = this.qp - q;
	      break;
	    case this.S_POLE:
	      b = phi - HALF_PI;
	      q = this.qp + q;
	      break;
	    }
	    if (Math.abs(b) < EPSLN) {
	      return null;
	    }
	    switch (this.mode) {
	    case this.OBLIQ:
	    case this.EQUIT:
	      b = Math.sqrt(2 / b);
	      if (this.mode === this.OBLIQ) {
	        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
	      }
	      else {
	        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
	      }
	      x = this.xmf * b * cosb * sinlam;
	      break;
	    case this.N_POLE:
	    case this.S_POLE:
	      if (q >= 0) {
	        x = (b = Math.sqrt(q)) * sinlam;
	        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
	      }
	      else {
	        x = y = 0;
	      }
	      break;
	    }
	  }

	  p.x = this.a * x + this.x0;
	  p.y = this.a * y + this.y0;
	  return p;
	}

	/* Inverse equations
	  -----------------*/
	function inverse$c(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var x = p.x / this.a;
	  var y = p.y / this.a;
	  var lam, phi, cCe, sCe, q, rho, ab;
	  if (this.sphere) {
	    var cosz = 0,
	      rh, sinz = 0;

	    rh = Math.sqrt(x * x + y * y);
	    phi = rh * 0.5;
	    if (phi > 1) {
	      return null;
	    }
	    phi = 2 * Math.asin(phi);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      sinz = Math.sin(phi);
	      cosz = Math.cos(phi);
	    }
	    switch (this.mode) {
	    case this.EQUIT:
	      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
	      x *= sinz;
	      y = cosz * rh;
	      break;
	    case this.OBLIQ:
	      phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
	      x *= sinz * this.cosph0;
	      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
	      break;
	    case this.N_POLE:
	      y = -y;
	      phi = HALF_PI - phi;
	      break;
	    case this.S_POLE:
	      phi -= HALF_PI;
	      break;
	    }
	    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
	  }
	  else {
	    ab = 0;
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      x /= this.dd;
	      y *= this.dd;
	      rho = Math.sqrt(x * x + y * y);
	      if (rho < EPSLN) {
	        p.x = this.long0;
	        p.y = this.lat0;
	        return p;
	      }
	      sCe = 2 * Math.asin(0.5 * rho / this.rq);
	      cCe = Math.cos(sCe);
	      x *= (sCe = Math.sin(sCe));
	      if (this.mode === this.OBLIQ) {
	        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
	        q = this.qp * ab;
	        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
	      }
	      else {
	        ab = y * sCe / rho;
	        q = this.qp * ab;
	        y = rho * cCe;
	      }
	    }
	    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	      if (this.mode === this.N_POLE) {
	        y = -y;
	      }
	      q = (x * x + y * y);
	      if (!q) {
	        p.x = this.long0;
	        p.y = this.lat0;
	        return p;
	      }
	      ab = 1 - q / this.qp;
	      if (this.mode === this.S_POLE) {
	        ab = -ab;
	      }
	    }
	    lam = Math.atan2(x, y);
	    phi = authlat(Math.asin(ab), this.apa);
	  }

	  p.x = adjust_lon(this.long0 + lam);
	  p.y = phi;
	  return p;
	}

	/* determine latitude from authalic latitude */
	var P00 = 0.33333333333333333333;

	var P01 = 0.17222222222222222222;
	var P02 = 0.10257936507936507936;
	var P10 = 0.06388888888888888888;
	var P11 = 0.06640211640211640211;
	var P20 = 0.01641501294219154443;

	function authset(es) {
	  var t;
	  var APA = [];
	  APA[0] = es * P00;
	  t = es * es;
	  APA[0] += t * P01;
	  APA[1] = t * P10;
	  t *= es;
	  APA[0] += t * P02;
	  APA[1] += t * P11;
	  APA[2] = t * P20;
	  return APA;
	}

	function authlat(beta, APA) {
	  var t = beta + beta;
	  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
	}

	var names$e = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
	var laea = {
	  init: init$d,
	  forward: forward$c,
	  inverse: inverse$c,
	  names: names$e,
	  S_POLE: S_POLE,
	  N_POLE: N_POLE,
	  EQUIT: EQUIT,
	  OBLIQ: OBLIQ
	};

	function asinz(x) {
	  if (Math.abs(x) > 1) {
	    x = (x > 1) ? 1 : -1;
	  }
	  return Math.asin(x);
	}

	function init$e() {

	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2);
	  this.e3 = Math.sqrt(this.es);

	  this.sin_po = Math.sin(this.lat1);
	  this.cos_po = Math.cos(this.lat1);
	  this.t1 = this.sin_po;
	  this.con = this.sin_po;
	  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
	  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  this.sin_po = Math.sin(this.lat2);
	  this.cos_po = Math.cos(this.lat2);
	  this.t2 = this.sin_po;
	  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
	  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  this.sin_po = Math.sin(this.lat0);
	  this.cos_po = Math.cos(this.lat0);
	  this.t3 = this.sin_po;
	  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
	  }
	  else {
	    this.ns0 = this.con;
	  }
	  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
	  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
	}

	/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
	  -------------------------------------------------------------------*/
	function forward$d(p) {

	  var lon = p.x;
	  var lat = p.y;

	  this.sin_phi = Math.sin(lat);
	  this.cos_phi = Math.cos(lat);

	  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
	  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
	  var theta = this.ns0 * adjust_lon(lon - this.long0);
	  var x = rh1 * Math.sin(theta) + this.x0;
	  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$d(p) {
	  var rh1, qs, con, theta, lon, lat;

	  p.x -= this.x0;
	  p.y = this.rh - p.y + this.y0;
	  if (this.ns0 >= 0) {
	    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	    con = -1;
	  }
	  theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2(con * p.x, con * p.y);
	  }
	  con = rh1 * this.ns0 / this.a;
	  if (this.sphere) {
	    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
	  }
	  else {
	    qs = (this.c - con * con) / this.ns0;
	    lat = this.phi1z(this.e3, qs);
	  }

	  lon = adjust_lon(theta / this.ns0 + this.long0);
	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	/* Function to compute phi1, the latitude for the inverse of the
	   Albers Conical Equal-Area projection.
	-------------------------------------------*/
	function phi1z(eccent, qs) {
	  var sinphi, cosphi, con, com, dphi;
	  var phi = asinz(0.5 * qs);
	  if (eccent < EPSLN) {
	    return phi;
	  }

	  var eccnts = eccent * eccent;
	  for (var i = 1; i <= 25; i++) {
	    sinphi = Math.sin(phi);
	    cosphi = Math.cos(phi);
	    con = eccent * sinphi;
	    com = 1 - con * con;
	    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	    phi = phi + dphi;
	    if (Math.abs(dphi) <= 1e-7) {
	      return phi;
	    }
	  }
	  return null;
	}

	var names$f = ["Albers_Conic_Equal_Area", "Albers", "aea"];
	var aea = {
	  init: init$e,
	  forward: forward$d,
	  inverse: inverse$d,
	  names: names$f,
	  phi1z: phi1z
	};

	/*
	  reference:
	    Wolfram Mathworld "Gnomonic Projection"
	    http://mathworld.wolfram.com/GnomonicProjection.html
	    Accessed: 12th November 2009
	  */
	function init$f() {

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.sin_p14 = Math.sin(this.lat0);
	  this.cos_p14 = Math.cos(this.lat0);
	  // Approximation for projecting points to the horizon (infinity)
	  this.infinity_dist = 1000 * this.a;
	  this.rc = 1;
	}

	/* Gnomonic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	function forward$e(p) {
	  var sinphi, cosphi; /* sin and cos value        */
	  var dlon; /* delta longitude value      */
	  var coslon; /* cos of longitude        */
	  var ksp; /* scale factor          */
	  var g;
	  var x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  dlon = adjust_lon(lon - this.long0);

	  sinphi = Math.sin(lat);
	  cosphi = Math.cos(lat);

	  coslon = Math.cos(dlon);
	  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
	  ksp = 1;
	  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
	    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
	    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
	  }
	  else {

	    // Point is in the opposing hemisphere and is unprojectable
	    // We still need to return a reasonable point, so we project
	    // to infinity, on a bearing
	    // equivalent to the northern hemisphere equivalent
	    // This is a reasonable approximation for short shapes and lines that
	    // straddle the horizon.

	    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
	    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

	  }
	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$e(p) {
	  var rh; /* Rho */
	  var sinc, cosc;
	  var c;
	  var lon, lat;

	  /* Inverse equations
	      -----------------*/
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  p.x /= this.k0;
	  p.y /= this.k0;

	  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
	    c = Math.atan2(rh, this.rc);
	    sinc = Math.sin(c);
	    cosc = Math.cos(c);

	    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
	    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
	    lon = adjust_lon(this.long0 + lon);
	  }
	  else {
	    lat = this.phic0;
	    lon = 0;
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$g = ["gnom"];
	var gnom = {
	  init: init$f,
	  forward: forward$e,
	  inverse: inverse$e,
	  names: names$g
	};

	function iqsfnz(eccent, q) {
	  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
	  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
	    if (q < 0) {
	      return (-1 * HALF_PI);
	    }
	    else {
	      return HALF_PI;
	    }
	  }
	  //var phi = 0.5* q/(1-eccent*eccent);
	  var phi = Math.asin(0.5 * q);
	  var dphi;
	  var sin_phi;
	  var cos_phi;
	  var con;
	  for (var i = 0; i < 30; i++) {
	    sin_phi = Math.sin(phi);
	    cos_phi = Math.cos(phi);
	    con = eccent * sin_phi;
	    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }

	  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
	  return NaN;
	}

	/*
	  reference:
	    "Cartographic Projection Procedures for the UNIX Environment-
	    A User's Manual" by Gerald I. Evenden,
	    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
	*/
	function init$g() {
	  //no-op
	  if (!this.sphere) {
	    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	  }
	}

	/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
	    ------------------------------------------------------------*/
	function forward$f(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var x, y;
	  /* Forward equations
	      -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  if (this.sphere) {
	    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
	    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
	  }
	  else {
	    var qs = qsfnz(this.e, Math.sin(lat));
	    x = this.x0 + this.a * this.k0 * dlon;
	    y = this.y0 + this.a * qs * 0.5 / this.k0;
	  }

	  p.x = x;
	  p.y = y;
	  return p;
	}

	/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
	    ------------------------------------------------------------*/
	function inverse$f(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var lon, lat;

	  if (this.sphere) {
	    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
	    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
	  }
	  else {
	    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
	    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$h = ["cea"];
	var cea = {
	  init: init$g,
	  forward: forward$f,
	  inverse: inverse$f,
	  names: names$h
	};

	function init$h() {

	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  this.lat0 = this.lat0 || 0;
	  this.long0 = this.long0 || 0;
	  this.lat_ts = this.lat_ts || 0;
	  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

	  this.rc = Math.cos(this.lat_ts);
	}

	// forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	function forward$g(p) {

	  var lon = p.x;
	  var lat = p.y;

	  var dlon = adjust_lon(lon - this.long0);
	  var dlat = adjust_lat(lat - this.lat0);
	  p.x = this.x0 + (this.a * dlon * this.rc);
	  p.y = this.y0 + (this.a * dlat);
	  return p;
	}

	// inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	function inverse$g(p) {

	  var x = p.x;
	  var y = p.y;

	  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
	  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
	  return p;
	}

	var names$i = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
	var eqc = {
	  init: init$h,
	  forward: forward$g,
	  inverse: inverse$g,
	  names: names$i
	};

	var MAX_ITER$2 = 20;

	function init$i() {
	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
	  this.e = Math.sqrt(this.es);
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);
	  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
	}

	/* Polyconic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	function forward$h(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var x, y, el;
	  var dlon = adjust_lon(lon - this.long0);
	  el = dlon * Math.sin(lat);
	  if (this.sphere) {
	    if (Math.abs(lat) <= EPSLN) {
	      x = this.a * dlon;
	      y = -1 * this.a * this.lat0;
	    }
	    else {
	      x = this.a * Math.sin(el) / Math.tan(lat);
	      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
	    }
	  }
	  else {
	    if (Math.abs(lat) <= EPSLN) {
	      x = this.a * dlon;
	      y = -1 * this.ml0;
	    }
	    else {
	      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
	      x = nl * Math.sin(el);
	      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
	    }

	  }
	  p.x = x + this.x0;
	  p.y = y + this.y0;
	  return p;
	}

	/* Inverse equations
	  -----------------*/
	function inverse$h(p) {
	  var lon, lat, x, y, i;
	  var al, bl;
	  var phi, dphi;
	  x = p.x - this.x0;
	  y = p.y - this.y0;

	  if (this.sphere) {
	    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
	      lon = adjust_lon(x / this.a + this.long0);
	      lat = 0;
	    }
	    else {
	      al = this.lat0 + y / this.a;
	      bl = x * x / this.a / this.a + al * al;
	      phi = al;
	      var tanphi;
	      for (i = MAX_ITER$2; i; --i) {
	        tanphi = Math.tan(phi);
	        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
	        phi += dphi;
	        if (Math.abs(dphi) <= EPSLN) {
	          lat = phi;
	          break;
	        }
	      }
	      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
	    }
	  }
	  else {
	    if (Math.abs(y + this.ml0) <= EPSLN) {
	      lat = 0;
	      lon = adjust_lon(this.long0 + x / this.a);
	    }
	    else {

	      al = (this.ml0 + y) / this.a;
	      bl = x * x / this.a / this.a + al * al;
	      phi = al;
	      var cl, mln, mlnp, ma;
	      var con;
	      for (i = MAX_ITER$2; i; --i) {
	        con = this.e * Math.sin(phi);
	        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
	        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
	        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
	        ma = mln / this.a;
	        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
	        phi -= dphi;
	        if (Math.abs(dphi) <= EPSLN) {
	          lat = phi;
	          break;
	        }
	      }

	      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
	      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
	      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
	    }
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$j = ["Polyconic", "poly"];
	var poly = {
	  init: init$i,
	  forward: forward$h,
	  inverse: inverse$h,
	  names: names$j
	};

	function init$j() {
	  this.A = [];
	  this.A[1] = 0.6399175073;
	  this.A[2] = -0.1358797613;
	  this.A[3] = 0.063294409;
	  this.A[4] = -0.02526853;
	  this.A[5] = 0.0117879;
	  this.A[6] = -0.0055161;
	  this.A[7] = 0.0026906;
	  this.A[8] = -0.001333;
	  this.A[9] = 0.00067;
	  this.A[10] = -0.00034;

	  this.B_re = [];
	  this.B_im = [];
	  this.B_re[1] = 0.7557853228;
	  this.B_im[1] = 0;
	  this.B_re[2] = 0.249204646;
	  this.B_im[2] = 0.003371507;
	  this.B_re[3] = -0.001541739;
	  this.B_im[3] = 0.041058560;
	  this.B_re[4] = -0.10162907;
	  this.B_im[4] = 0.01727609;
	  this.B_re[5] = -0.26623489;
	  this.B_im[5] = -0.36249218;
	  this.B_re[6] = -0.6870983;
	  this.B_im[6] = -1.1651967;

	  this.C_re = [];
	  this.C_im = [];
	  this.C_re[1] = 1.3231270439;
	  this.C_im[1] = 0;
	  this.C_re[2] = -0.577245789;
	  this.C_im[2] = -0.007809598;
	  this.C_re[3] = 0.508307513;
	  this.C_im[3] = -0.112208952;
	  this.C_re[4] = -0.15094762;
	  this.C_im[4] = 0.18200602;
	  this.C_re[5] = 1.01418179;
	  this.C_im[5] = 1.64497696;
	  this.C_re[6] = 1.9660549;
	  this.C_im[6] = 2.5127645;

	  this.D = [];
	  this.D[1] = 1.5627014243;
	  this.D[2] = 0.5185406398;
	  this.D[3] = -0.03333098;
	  this.D[4] = -0.1052906;
	  this.D[5] = -0.0368594;
	  this.D[6] = 0.007317;
	  this.D[7] = 0.01220;
	  this.D[8] = 0.00394;
	  this.D[9] = -0.0013;
	}

	/**
	    New Zealand Map Grid Forward  - long/lat to x/y
	    long/lat in radians
	  */
	function forward$i(p) {
	  var n;
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lat = lat - this.lat0;
	  var delta_lon = lon - this.long0;

	  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
	  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
	  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
	  var d_lambda = delta_lon;
	  var d_phi_n = 1; // d_phi^0

	  var d_psi = 0;
	  for (n = 1; n <= 10; n++) {
	    d_phi_n = d_phi_n * d_phi;
	    d_psi = d_psi + this.A[n] * d_phi_n;
	  }

	  // 2. Calculate theta
	  var th_re = d_psi;
	  var th_im = d_lambda;

	  // 3. Calculate z
	  var th_n_re = 1;
	  var th_n_im = 0; // theta^0
	  var th_n_re1;
	  var th_n_im1;

	  var z_re = 0;
	  var z_im = 0;
	  for (n = 1; n <= 6; n++) {
	    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	    th_n_re = th_n_re1;
	    th_n_im = th_n_im1;
	    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
	    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
	  }

	  // 4. Calculate easting and northing
	  p.x = (z_im * this.a) + this.x0;
	  p.y = (z_re * this.a) + this.y0;

	  return p;
	}

	/**
	    New Zealand Map Grid Inverse  -  x/y to long/lat
	  */
	function inverse$i(p) {
	  var n;
	  var x = p.x;
	  var y = p.y;

	  var delta_x = x - this.x0;
	  var delta_y = y - this.y0;

	  // 1. Calculate z
	  var z_re = delta_y / this.a;
	  var z_im = delta_x / this.a;

	  // 2a. Calculate theta - first approximation gives km accuracy
	  var z_n_re = 1;
	  var z_n_im = 0; // z^0
	  var z_n_re1;
	  var z_n_im1;

	  var th_re = 0;
	  var th_im = 0;
	  for (n = 1; n <= 6; n++) {
	    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
	    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
	    z_n_re = z_n_re1;
	    z_n_im = z_n_im1;
	    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
	    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
	  }

	  // 2b. Iterate to refine the accuracy of the calculation
	  //        0 iterations gives km accuracy
	  //        1 iteration gives m accuracy -- good enough for most mapping applications
	  //        2 iterations bives mm accuracy
	  for (var i = 0; i < this.iterations; i++) {
	    var th_n_re = th_re;
	    var th_n_im = th_im;
	    var th_n_re1;
	    var th_n_im1;

	    var num_re = z_re;
	    var num_im = z_im;
	    for (n = 2; n <= 6; n++) {
	      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	      th_n_re = th_n_re1;
	      th_n_im = th_n_im1;
	      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	    }

	    th_n_re = 1;
	    th_n_im = 0;
	    var den_re = this.B_re[1];
	    var den_im = this.B_im[1];
	    for (n = 2; n <= 6; n++) {
	      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	      th_n_re = th_n_re1;
	      th_n_im = th_n_im1;
	      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	    }

	    // Complex division
	    var den2 = den_re * den_re + den_im * den_im;
	    th_re = (num_re * den_re + num_im * den_im) / den2;
	    th_im = (num_im * den_re - num_re * den_im) / den2;
	  }

	  // 3. Calculate d_phi              ...                                    // and d_lambda
	  var d_psi = th_re;
	  var d_lambda = th_im;
	  var d_psi_n = 1; // d_psi^0

	  var d_phi = 0;
	  for (n = 1; n <= 9; n++) {
	    d_psi_n = d_psi_n * d_psi;
	    d_phi = d_phi + this.D[n] * d_psi_n;
	  }

	  // 4. Calculate latitude and longitude
	  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
	  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
	  var lon = this.long0 + d_lambda;

	  p.x = lon;
	  p.y = lat;

	  return p;
	}

	var names$k = ["New_Zealand_Map_Grid", "nzmg"];
	var nzmg = {
	  init: init$j,
	  forward: forward$i,
	  inverse: inverse$i,
	  names: names$k
	};

	/*
	  reference
	    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	  */


	/* Initialize the Miller Cylindrical projection
	  -------------------------------------------*/
	function init$k() {
	  //no-op
	}

	/* Miller Cylindrical forward equations--mapping lat,long to x,y
	    ------------------------------------------------------------*/
	function forward$j(p) {
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  var x = this.x0 + this.a * dlon;
	  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

	  p.x = x;
	  p.y = y;
	  return p;
	}

	/* Miller Cylindrical inverse equations--mapping x,y to lat/long
	    ------------------------------------------------------------*/
	function inverse$j(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;

	  var lon = adjust_lon(this.long0 + p.x / this.a);
	  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$l = ["Miller_Cylindrical", "mill"];
	var mill = {
	  init: init$k,
	  forward: forward$j,
	  inverse: inverse$j,
	  names: names$l
	};

	var MAX_ITER$3 = 20;


	function init$l() {
	  /* Place parameters in static storage for common use
	    -------------------------------------------------*/


	  if (!this.sphere) {
	    this.en = pj_enfn(this.es);
	  }
	  else {
	    this.n = 1;
	    this.m = 0;
	    this.es = 0;
	    this.C_y = Math.sqrt((this.m + 1) / this.n);
	    this.C_x = this.C_y / (this.m + 1);
	  }

	}

	/* Sinusoidal forward equations--mapping lat,long to x,y
	  -----------------------------------------------------*/
	function forward$k(p) {
	  var x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	    -----------------*/
	  lon = adjust_lon(lon - this.long0);

	  if (this.sphere) {
	    if (!this.m) {
	      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
	    }
	    else {
	      var k = this.n * Math.sin(lat);
	      for (var i = MAX_ITER$3; i; --i) {
	        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
	        lat -= V;
	        if (Math.abs(V) < EPSLN) {
	          break;
	        }
	      }
	    }
	    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
	    y = this.a * this.C_y * lat;

	  }
	  else {

	    var s = Math.sin(lat);
	    var c = Math.cos(lat);
	    y = this.a * pj_mlfn(lat, s, c, this.en);
	    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
	  }

	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$k(p) {
	  var lat, temp, lon, s;

	  p.x -= this.x0;
	  lon = p.x / this.a;
	  p.y -= this.y0;
	  lat = p.y / this.a;

	  if (this.sphere) {
	    lat /= this.C_y;
	    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
	    if (this.m) {
	      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
	    }
	    else if (this.n !== 1) {
	      lat = asinz(Math.sin(lat) / this.n);
	    }
	    lon = adjust_lon(lon + this.long0);
	    lat = adjust_lat(lat);
	  }
	  else {
	    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
	    s = Math.abs(lat);
	    if (s < HALF_PI) {
	      s = Math.sin(lat);
	      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
	      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
	      lon = adjust_lon(temp);
	    }
	    else if ((s - EPSLN) < HALF_PI) {
	      lon = this.long0;
	    }
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$m = ["Sinusoidal", "sinu"];
	var sinu = {
	  init: init$l,
	  forward: forward$k,
	  inverse: inverse$k,
	  names: names$m
	};

	function init$m() {}
	/* Mollweide forward equations--mapping lat,long to x,y
	    ----------------------------------------------------*/
	function forward$l(p) {

	  /* Forward equations
	      -----------------*/
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lon = adjust_lon(lon - this.long0);
	  var theta = lat;
	  var con = Math.PI * Math.sin(lat);

	  /* Iterate using the Newton-Raphson method to find theta
	      -----------------------------------------------------*/
	  while (true) {
	    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
	    theta += delta_theta;
	    if (Math.abs(delta_theta) < EPSLN) {
	      break;
	    }
	  }
	  theta /= 2;

	  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
	       this is done here because of precision problems with "cos(theta)"
	       --------------------------------------------------------------------------*/
	  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
	    delta_lon = 0;
	  }
	  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
	  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$l(p) {
	  var theta;
	  var arg;

	  /* Inverse equations
	      -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  arg = p.y / (1.4142135623731 * this.a);

	  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
	       a number very close to one is used instead.
	       -------------------------------------------------------------------*/
	  if (Math.abs(arg) > 0.999999999999) {
	    arg = 0.999999999999;
	  }
	  theta = Math.asin(arg);
	  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
	  if (lon < (-Math.PI)) {
	    lon = -Math.PI;
	  }
	  if (lon > Math.PI) {
	    lon = Math.PI;
	  }
	  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
	  if (Math.abs(arg) > 1) {
	    arg = 1;
	  }
	  var lat = Math.asin(arg);

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$n = ["Mollweide", "moll"];
	var moll = {
	  init: init$m,
	  forward: forward$l,
	  inverse: inverse$l,
	  names: names$n
	};

	function init$n() {

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  // Standard Parallels cannot be equal and on opposite sides of the equator
	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }
	  this.lat2 = this.lat2 || this.lat1;
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2);
	  this.e = Math.sqrt(this.es);
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);

	  this.sinphi = Math.sin(this.lat1);
	  this.cosphi = Math.cos(this.lat1);

	  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
	  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

	  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
	    this.ns = this.sinphi;
	  }
	  else {
	    this.sinphi = Math.sin(this.lat2);
	    this.cosphi = Math.cos(this.lat2);
	    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
	    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
	    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
	  }
	  this.g = this.ml1 + this.ms1 / this.ns;
	  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	  this.rh = this.a * (this.g - this.ml0);
	}

	/* Equidistant Conic forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------*/
	function forward$m(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var rh1;

	  /* Forward equations
	      -----------------*/
	  if (this.sphere) {
	    rh1 = this.a * (this.g - lat);
	  }
	  else {
	    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
	    rh1 = this.a * (this.g - ml);
	  }
	  var theta = this.ns * adjust_lon(lon - this.long0);
	  var x = this.x0 + rh1 * Math.sin(theta);
	  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
	  p.x = x;
	  p.y = y;
	  return p;
	}

	/* Inverse equations
	  -----------------*/
	function inverse$m(p) {
	  p.x -= this.x0;
	  p.y = this.rh - p.y + this.y0;
	  var con, rh1, lat, lon;
	  if (this.ns >= 0) {
	    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	    con = -1;
	  }
	  var theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2(con * p.x, con * p.y);
	  }

	  if (this.sphere) {
	    lon = adjust_lon(this.long0 + theta / this.ns);
	    lat = adjust_lat(this.g - rh1 / this.a);
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    var ml = this.g - rh1 / this.a;
	    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
	    lon = adjust_lon(this.long0 + theta / this.ns);
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }

	}

	var names$o = ["Equidistant_Conic", "eqdc"];
	var eqdc = {
	  init: init$n,
	  forward: forward$m,
	  inverse: inverse$m,
	  names: names$o
	};

	/* Initialize the Van Der Grinten projection
	  ----------------------------------------*/
	function init$o() {
	  //this.R = 6370997; //Radius of earth
	  this.R = this.a;
	}

	function forward$n(p) {

	  var lon = p.x;
	  var lat = p.y;

	  /* Forward equations
	    -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  var x, y;

	  if (Math.abs(lat) <= EPSLN) {
	    x = this.x0 + this.R * dlon;
	    y = this.y0;
	  }
	  var theta = asinz(2 * Math.abs(lat / Math.PI));
	  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
	    x = this.x0;
	    if (lat >= 0) {
	      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
	    }
	    else {
	      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
	    }
	    //  return(OK);
	  }
	  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
	  var asq = al * al;
	  var sinth = Math.sin(theta);
	  var costh = Math.cos(theta);

	  var g = costh / (sinth + costh - 1);
	  var gsq = g * g;
	  var m = g * (2 / sinth - 1);
	  var msq = m * m;
	  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
	  if (dlon < 0) {
	    con = -con;
	  }
	  x = this.x0 + con;
	  //con = Math.abs(con / (Math.PI * this.R));
	  var q = asq + g;
	  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
	  if (lat >= 0) {
	    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	    y = this.y0 + con;
	  }
	  else {
	    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	    y = this.y0 - con;
	  }
	  p.x = x;
	  p.y = y;
	  return p;
	}

	/* Van Der Grinten inverse equations--mapping x,y to lat/long
	  ---------------------------------------------------------*/
	function inverse$n(p) {
	  var lon, lat;
	  var xx, yy, xys, c1, c2, c3;
	  var a1;
	  var m1;
	  var con;
	  var th1;
	  var d;

	  /* inverse equations
	    -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  con = Math.PI * this.R;
	  xx = p.x / con;
	  yy = p.y / con;
	  xys = xx * xx + yy * yy;
	  c1 = -Math.abs(yy) * (1 + xys);
	  c2 = c1 - 2 * yy * yy + xx * xx;
	  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
	  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
	  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
	  m1 = 2 * Math.sqrt(-a1 / 3);
	  con = ((3 * d) / a1) / m1;
	  if (Math.abs(con) > 1) {
	    if (con >= 0) {
	      con = 1;
	    }
	    else {
	      con = -1;
	    }
	  }
	  th1 = Math.acos(con) / 3;
	  if (p.y >= 0) {
	    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	  }
	  else {
	    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	  }

	  if (Math.abs(xx) < EPSLN) {
	    lon = this.long0;
	  }
	  else {
	    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$p = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
	var vandg = {
	  init: init$o,
	  forward: forward$n,
	  inverse: inverse$n,
	  names: names$p
	};

	function init$p() {
	  this.sin_p12 = Math.sin(this.lat0);
	  this.cos_p12 = Math.cos(this.lat0);
	}

	function forward$o(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var sinphi = Math.sin(p.y);
	  var cosphi = Math.cos(p.y);
	  var dlon = adjust_lon(lon - this.long0);
	  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
	  if (this.sphere) {
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North Pole case
	      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
	      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South Pole case
	      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
	      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
	      return p;
	    }
	    else {
	      //default case
	      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
	      c = Math.acos(cos_c);
	      kp = c ? c / Math.sin(c) : 1;
	      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
	      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
	      return p;
	    }
	  }
	  else {
	    e0 = e0fn(this.es);
	    e1 = e1fn(this.es);
	    e2 = e2fn(this.es);
	    e3 = e3fn(this.es);
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North Pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
	      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South Pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
	      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
	      return p;
	    }
	    else {
	      //Default case
	      tanphi = sinphi / cosphi;
	      Nl1 = gN(this.a, this.e, this.sin_p12);
	      Nl = gN(this.a, this.e, sinphi);
	      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
	      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
	      if (Az === 0) {
	        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	      }
	      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
	        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	      }
	      else {
	        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
	      }
	      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
	      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
	      GH = G * H;
	      Hs = H * H;
	      s2 = s * s;
	      s3 = s2 * s;
	      s4 = s3 * s;
	      s5 = s4 * s;
	      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
	      p.x = this.x0 + c * Math.sin(Az);
	      p.y = this.y0 + c * Math.cos(Az);
	      return p;
	    }
	  }


	}

	function inverse$o(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
	  if (this.sphere) {
	    rh = Math.sqrt(p.x * p.x + p.y * p.y);
	    if (rh > (2 * HALF_PI * this.a)) {
	      return;
	    }
	    z = rh / this.a;

	    sinz = Math.sin(z);
	    cosz = Math.cos(z);

	    lon = this.long0;
	    if (Math.abs(rh) <= EPSLN) {
	      lat = this.lat0;
	    }
	    else {
	      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
	      con = Math.abs(this.lat0) - HALF_PI;
	      if (Math.abs(con) <= EPSLN) {
	        if (this.lat0 >= 0) {
	          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
	        }
	        else {
	          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
	        }
	      }
	      else {
	        /*con = cosz - this.sin_p12 * Math.sin(lat);
	        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
	          //no-op, just keep the lon value as is
	        } else {
	          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
	          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
	        }*/
	        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
	      }
	    }

	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    e0 = e0fn(this.es);
	    e1 = e1fn(this.es);
	    e2 = e2fn(this.es);
	    e3 = e3fn(this.es);
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      M = Mlp - rh;
	      lat = imlfn(M / this.a, e0, e1, e2, e3);
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      M = rh - Mlp;

	      lat = imlfn(M / this.a, e0, e1, e2, e3);
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    else {
	      //default case
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      Az = Math.atan2(p.x, p.y);
	      N1 = gN(this.a, this.e, this.sin_p12);
	      cosAz = Math.cos(Az);
	      tmp = this.e * this.cos_p12 * cosAz;
	      A = -tmp * tmp / (1 - this.es);
	      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
	      D = rh / N1;
	      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
	      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
	      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
	      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
	      sinpsi = Math.sin(psi);
	      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	  }

	}

	var names$q = ["Azimuthal_Equidistant", "aeqd"];
	var aeqd = {
	  init: init$p,
	  forward: forward$o,
	  inverse: inverse$o,
	  names: names$q
	};

	function init$q() {
	  //double temp;      /* temporary variable    */

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.sin_p14 = Math.sin(this.lat0);
	  this.cos_p14 = Math.cos(this.lat0);
	}

	/* Orthographic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	function forward$p(p) {
	  var sinphi, cosphi; /* sin and cos value        */
	  var dlon; /* delta longitude value      */
	  var coslon; /* cos of longitude        */
	  var ksp; /* scale factor          */
	  var g, x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  dlon = adjust_lon(lon - this.long0);

	  sinphi = Math.sin(lat);
	  cosphi = Math.cos(lat);

	  coslon = Math.cos(dlon);
	  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
	  ksp = 1;
	  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
	    x = this.a * ksp * cosphi * Math.sin(dlon);
	    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
	  }
	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$p(p) {
	  var rh; /* height above ellipsoid      */
	  var z; /* angle          */
	  var sinz, cosz; /* sin of z and cos of z      */
	  var con;
	  var lon, lat;
	  /* Inverse equations
	      -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  rh = Math.sqrt(p.x * p.x + p.y * p.y);
	  z = asinz(rh / this.a);

	  sinz = Math.sin(z);
	  cosz = Math.cos(z);

	  lon = this.long0;
	  if (Math.abs(rh) <= EPSLN) {
	    lat = this.lat0;
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
	  con = Math.abs(this.lat0) - HALF_PI;
	  if (Math.abs(con) <= EPSLN) {
	    if (this.lat0 >= 0) {
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
	    }
	    else {
	      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
	    }
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$r = ["ortho"];
	var ortho = {
	  init: init$q,
	  forward: forward$p,
	  inverse: inverse$p,
	  names: names$r
	};

	// QSC projection rewritten from the original PROJ4

	/* constants */
	var FACE_ENUM = {
	    FRONT: 1,
	    RIGHT: 2,
	    BACK: 3,
	    LEFT: 4,
	    TOP: 5,
	    BOTTOM: 6
	};

	var AREA_ENUM = {
	    AREA_0: 1,
	    AREA_1: 2,
	    AREA_2: 3,
	    AREA_3: 4
	};

	function init$r() {

	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  this.lat0 = this.lat0 || 0;
	  this.long0 = this.long0 || 0;
	  this.lat_ts = this.lat_ts || 0;
	  this.title = this.title || "Quadrilateralized Spherical Cube";

	  /* Determine the cube face from the center of projection. */
	  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
	    this.face = FACE_ENUM.TOP;
	  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
	    this.face = FACE_ENUM.BOTTOM;
	  } else if (Math.abs(this.long0) <= FORTPI) {
	    this.face = FACE_ENUM.FRONT;
	  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
	    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
	  } else {
	    this.face = FACE_ENUM.BACK;
	  }

	  /* Fill in useful values for the ellipsoid <-> sphere shift
	   * described in [LK12]. */
	  if (this.es !== 0) {
	    this.one_minus_f = 1 - (this.a - this.b) / this.a;
	    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
	  }
	}

	// QSC forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	function forward$q(p) {
	  var xy = {x: 0, y: 0};
	  var lat, lon;
	  var theta, phi;
	  var t, mu;
	  /* nu; */
	  var area = {value: 0};

	  // move lon according to projection's lon
	  p.x -= this.long0;

	  /* Convert the geodetic latitude to a geocentric latitude.
	   * This corresponds to the shift from the ellipsoid to the sphere
	   * described in [LK12]. */
	  if (this.es !== 0) {//if (P->es != 0) {
	    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
	  } else {
	    lat = p.y;
	  }

	  /* Convert the input lat, lon into theta, phi as used by QSC.
	   * This depends on the cube face and the area on it.
	   * For the top and bottom face, we can compute theta and phi
	   * directly from phi, lam. For the other faces, we must use
	   * unit sphere cartesian coordinates as an intermediate step. */
	  lon = p.x; //lon = lp.lam;
	  if (this.face === FACE_ENUM.TOP) {
	    phi = HALF_PI - lat;
	    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
	      area.value = AREA_ENUM.AREA_0;
	      theta = lon - HALF_PI;
	    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
	      area.value = AREA_ENUM.AREA_1;
	      theta = (lon > 0.0 ? lon - SPI : lon + SPI);
	    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
	      area.value = AREA_ENUM.AREA_2;
	      theta = lon + HALF_PI;
	    } else {
	      area.value = AREA_ENUM.AREA_3;
	      theta = lon;
	    }
	  } else if (this.face === FACE_ENUM.BOTTOM) {
	    phi = HALF_PI + lat;
	    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
	      area.value = AREA_ENUM.AREA_0;
	      theta = -lon + HALF_PI;
	    } else if (lon < FORTPI && lon >= -FORTPI) {
	      area.value = AREA_ENUM.AREA_1;
	      theta = -lon;
	    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
	      area.value = AREA_ENUM.AREA_2;
	      theta = -lon - HALF_PI;
	    } else {
	      area.value = AREA_ENUM.AREA_3;
	      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
	    }
	  } else {
	    var q, r, s;
	    var sinlat, coslat;
	    var sinlon, coslon;

	    if (this.face === FACE_ENUM.RIGHT) {
	      lon = qsc_shift_lon_origin(lon, +HALF_PI);
	    } else if (this.face === FACE_ENUM.BACK) {
	      lon = qsc_shift_lon_origin(lon, +SPI);
	    } else if (this.face === FACE_ENUM.LEFT) {
	      lon = qsc_shift_lon_origin(lon, -HALF_PI);
	    }
	    sinlat = Math.sin(lat);
	    coslat = Math.cos(lat);
	    sinlon = Math.sin(lon);
	    coslon = Math.cos(lon);
	    q = coslat * coslon;
	    r = coslat * sinlon;
	    s = sinlat;

	    if (this.face === FACE_ENUM.FRONT) {
	      phi = Math.acos(q);
	      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
	    } else if (this.face === FACE_ENUM.RIGHT) {
	      phi = Math.acos(r);
	      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
	    } else if (this.face === FACE_ENUM.BACK) {
	      phi = Math.acos(-q);
	      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
	    } else if (this.face === FACE_ENUM.LEFT) {
	      phi = Math.acos(-r);
	      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
	    } else {
	      /* Impossible */
	      phi = theta = 0;
	      area.value = AREA_ENUM.AREA_0;
	    }
	  }

	  /* Compute mu and nu for the area of definition.
	   * For mu, see Eq. (3-21) in [OL76], but note the typos:
	   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
	  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
	  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

	  /* Apply the result to the real area. */
	  if (area.value === AREA_ENUM.AREA_1) {
	    mu += HALF_PI;
	  } else if (area.value === AREA_ENUM.AREA_2) {
	    mu += SPI;
	  } else if (area.value === AREA_ENUM.AREA_3) {
	    mu += 1.5 * SPI;
	  }

	  /* Now compute x, y from mu and nu */
	  xy.x = t * Math.cos(mu);
	  xy.y = t * Math.sin(mu);
	  xy.x = xy.x * this.a + this.x0;
	  xy.y = xy.y * this.a + this.y0;

	  p.x = xy.x;
	  p.y = xy.y;
	  return p;
	}

	// QSC inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	function inverse$q(p) {
	  var lp = {lam: 0, phi: 0};
	  var mu, nu, cosmu, tannu;
	  var tantheta, theta, cosphi, phi;
	  var t;
	  var area = {value: 0};

	  /* de-offset */
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  /* Convert the input x, y to the mu and nu angles as used by QSC.
	   * This depends on the area of the cube face. */
	  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
	  mu = Math.atan2(p.y, p.x);
	  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
	    area.value = AREA_ENUM.AREA_0;
	  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
	    area.value = AREA_ENUM.AREA_1;
	    mu -= HALF_PI;
	  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
	    area.value = AREA_ENUM.AREA_2;
	    mu = (mu < 0.0 ? mu + SPI : mu - SPI);
	  } else {
	    area.value = AREA_ENUM.AREA_3;
	    mu += HALF_PI;
	  }

	  /* Compute phi and theta for the area of definition.
	   * The inverse projection is not described in the original paper, but some
	   * good hints can be found here (as of 2011-12-14):
	   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
	   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
	  t = (SPI / 12) * Math.tan(mu);
	  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
	  theta = Math.atan(tantheta);
	  cosmu = Math.cos(mu);
	  tannu = Math.tan(nu);
	  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
	  if (cosphi < -1) {
	    cosphi = -1;
	  } else if (cosphi > +1) {
	    cosphi = +1;
	  }

	  /* Apply the result to the real area on the cube face.
	   * For the top and bottom face, we can compute phi and lam directly.
	   * For the other faces, we must use unit sphere cartesian coordinates
	   * as an intermediate step. */
	  if (this.face === FACE_ENUM.TOP) {
	    phi = Math.acos(cosphi);
	    lp.phi = HALF_PI - phi;
	    if (area.value === AREA_ENUM.AREA_0) {
	      lp.lam = theta + HALF_PI;
	    } else if (area.value === AREA_ENUM.AREA_1) {
	      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
	    } else if (area.value === AREA_ENUM.AREA_2) {
	      lp.lam = theta - HALF_PI;
	    } else /* area.value == AREA_ENUM.AREA_3 */ {
	      lp.lam = theta;
	    }
	  } else if (this.face === FACE_ENUM.BOTTOM) {
	    phi = Math.acos(cosphi);
	    lp.phi = phi - HALF_PI;
	    if (area.value === AREA_ENUM.AREA_0) {
	      lp.lam = -theta + HALF_PI;
	    } else if (area.value === AREA_ENUM.AREA_1) {
	      lp.lam = -theta;
	    } else if (area.value === AREA_ENUM.AREA_2) {
	      lp.lam = -theta - HALF_PI;
	    } else /* area.value == AREA_ENUM.AREA_3 */ {
	      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
	    }
	  } else {
	    /* Compute phi and lam via cartesian unit sphere coordinates. */
	    var q, r, s;
	    q = cosphi;
	    t = q * q;
	    if (t >= 1) {
	      s = 0;
	    } else {
	      s = Math.sqrt(1 - t) * Math.sin(theta);
	    }
	    t += s * s;
	    if (t >= 1) {
	      r = 0;
	    } else {
	      r = Math.sqrt(1 - t);
	    }
	    /* Rotate q,r,s into the correct area. */
	    if (area.value === AREA_ENUM.AREA_1) {
	      t = r;
	      r = -s;
	      s = t;
	    } else if (area.value === AREA_ENUM.AREA_2) {
	      r = -r;
	      s = -s;
	    } else if (area.value === AREA_ENUM.AREA_3) {
	      t = r;
	      r = s;
	      s = -t;
	    }
	    /* Rotate q,r,s into the correct cube face. */
	    if (this.face === FACE_ENUM.RIGHT) {
	      t = q;
	      q = -r;
	      r = t;
	    } else if (this.face === FACE_ENUM.BACK) {
	      q = -q;
	      r = -r;
	    } else if (this.face === FACE_ENUM.LEFT) {
	      t = q;
	      q = r;
	      r = -t;
	    }
	    /* Now compute phi and lam from the unit sphere coordinates. */
	    lp.phi = Math.acos(-s) - HALF_PI;
	    lp.lam = Math.atan2(r, q);
	    if (this.face === FACE_ENUM.RIGHT) {
	      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
	    } else if (this.face === FACE_ENUM.BACK) {
	      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
	    } else if (this.face === FACE_ENUM.LEFT) {
	      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
	    }
	  }

	  /* Apply the shift from the sphere to the ellipsoid as described
	   * in [LK12]. */
	  if (this.es !== 0) {
	    var invert_sign;
	    var tanphi, xa;
	    invert_sign = (lp.phi < 0 ? 1 : 0);
	    tanphi = Math.tan(lp.phi);
	    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
	    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
	    if (invert_sign) {
	      lp.phi = -lp.phi;
	    }
	  }

	  lp.lam += this.long0;
	  p.x = lp.lam;
	  p.y = lp.phi;
	  return p;
	}

	/* Helper function for forward projection: compute the theta angle
	 * and determine the area number. */
	function qsc_fwd_equat_face_theta(phi, y, x, area) {
	  var theta;
	  if (phi < EPSLN) {
	    area.value = AREA_ENUM.AREA_0;
	    theta = 0.0;
	  } else {
	    theta = Math.atan2(y, x);
	    if (Math.abs(theta) <= FORTPI) {
	      area.value = AREA_ENUM.AREA_0;
	    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
	      area.value = AREA_ENUM.AREA_1;
	      theta -= HALF_PI;
	    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
	      area.value = AREA_ENUM.AREA_2;
	      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
	    } else {
	      area.value = AREA_ENUM.AREA_3;
	      theta += HALF_PI;
	    }
	  }
	  return theta;
	}

	/* Helper function: shift the longitude. */
	function qsc_shift_lon_origin(lon, offset) {
	  var slon = lon + offset;
	  if (slon < -SPI) {
	    slon += TWO_PI;
	  } else if (slon > +SPI) {
	    slon -= TWO_PI;
	  }
	  return slon;
	}

	var names$s = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
	var qsc = {
	  init: init$r,
	  forward: forward$q,
	  inverse: inverse$q,
	  names: names$s
	};

	// Robinson projection

	var COEFS_X = [
	    [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
	    [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
	    [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
	    [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
	    [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
	    [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
	    [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
	    [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
	    [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
	    [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
	    [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
	    [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
	    [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
	    [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
	    [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
	    [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
	    [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
	    [0.5722, -0.00906601, 0.000182, 6.24051e-06],
	    [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
	];

	var COEFS_Y = [
	    [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
	    [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
	    [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
	    [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
	    [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
	    [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
	    [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
	    [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
	    [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
	    [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
	    [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
	    [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
	    [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
	    [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
	    [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
	    [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
	    [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
	    [0.9761, 0.00616527, -0.000256, -4.2106e-06],
	    [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
	];

	var FXC = 0.8487;
	var FYC = 1.3523;
	var C1 = R2D/5; // rad to 5-degree interval
	var RC1 = 1/C1;
	var NODES = 18;

	var poly3_val = function(coefs, x) {
	    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
	};

	var poly3_der = function(coefs, x) {
	    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
	};

	function newton_rapshon(f_df, start, max_err, iters) {
	    var x = start;
	    for (; iters; --iters) {
	        var upd = f_df(x);
	        x -= upd;
	        if (Math.abs(upd) < max_err) {
	            break;
	        }
	    }
	    return x;
	}

	function init$s() {
	    this.x0 = this.x0 || 0;
	    this.y0 = this.y0 || 0;
	    this.long0 = this.long0 || 0;
	    this.es = 0;
	    this.title = this.title || "Robinson";
	}

	function forward$r(ll) {
	    var lon = adjust_lon(ll.x - this.long0);

	    var dphi = Math.abs(ll.y);
	    var i = Math.floor(dphi * C1);
	    if (i < 0) {
	        i = 0;
	    } else if (i >= NODES) {
	        i = NODES - 1;
	    }
	    dphi = R2D * (dphi - RC1 * i);
	    var xy = {
	        x: poly3_val(COEFS_X[i], dphi) * lon,
	        y: poly3_val(COEFS_Y[i], dphi)
	    };
	    if (ll.y < 0) {
	        xy.y = -xy.y;
	    }

	    xy.x = xy.x * this.a * FXC + this.x0;
	    xy.y = xy.y * this.a * FYC + this.y0;
	    return xy;
	}

	function inverse$r(xy) {
	    var ll = {
	        x: (xy.x - this.x0) / (this.a * FXC),
	        y: Math.abs(xy.y - this.y0) / (this.a * FYC)
	    };

	    if (ll.y >= 1) { // pathologic case
	        ll.x /= COEFS_X[NODES][0];
	        ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
	    } else {
	        // find table interval
	        var i = Math.floor(ll.y * NODES);
	        if (i < 0) {
	            i = 0;
	        } else if (i >= NODES) {
	            i = NODES - 1;
	        }
	        for (;;) {
	            if (COEFS_Y[i][0] > ll.y) {
	                --i;
	            } else if (COEFS_Y[i+1][0] <= ll.y) {
	                ++i;
	            } else {
	                break;
	            }
	        }
	        // linear interpolation in 5 degree interval
	        var coefs = COEFS_Y[i];
	        var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
	        // find t so that poly3_val(coefs, t) = ll.y
	        t = newton_rapshon(function(x) {
	            return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
	        }, t, EPSLN, 100);

	        ll.x /= poly3_val(COEFS_X[i], t);
	        ll.y = (5 * i + t) * D2R;
	        if (xy.y < 0) {
	            ll.y = -ll.y;
	        }
	    }

	    ll.x = adjust_lon(ll.x + this.long0);
	    return ll;
	}

	var names$t = ["Robinson", "robin"];
	var robin = {
	  init: init$s,
	  forward: forward$r,
	  inverse: inverse$r,
	  names: names$t
	};

	function init$t() {
	    this.name = 'geocent';

	}

	function forward$s(p) {
	    var point = geodeticToGeocentric(p, this.es, this.a);
	    return point;
	}

	function inverse$s(p) {
	    var point = geocentricToGeodetic(p, this.es, this.a, this.b);
	    return point;
	}

	var names$u = ["Geocentric", 'geocentric', "geocent", "Geocent"];
	var geocent = {
	    init: init$t,
	    forward: forward$s,
	    inverse: inverse$s,
	    names: names$u
	};

	var mode = {
	  N_POLE: 0,
	  S_POLE: 1,
	  EQUIT: 2,
	  OBLIQ: 3
	};

	var params = {
	  h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
	  azi:   { def: 0, num: true, degrees: true }, // default is North
	  tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
	  long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
	  lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
	};

	function init$u() {
	  Object.keys(params).forEach(function (p) {
	    if (typeof this[p] === "undefined") {
	      this[p] = params[p].def;
	    } else if (params[p].num && isNaN(this[p])) {
	      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
	    } else if (params[p].num) {
	      this[p] = parseFloat(this[p]);
	    }
	    if (params[p].degrees) {
	      this[p] = this[p] * D2R;
	    }
	  }.bind(this));

	  if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
	    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
	  } else if (Math.abs(this.lat0) < EPSLN) {
	    this.mode = mode.EQUIT;
	  } else {
	    this.mode = mode.OBLIQ;
	    this.sinph0 = Math.sin(this.lat0);
	    this.cosph0 = Math.cos(this.lat0);
	  }

	  this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

	  if (this.pn1 <= 0 || this.pn1 > 1e10) {
	    throw new Error("Invalid height");
	  }
	  
	  this.p = 1 + this.pn1;
	  this.rp = 1 / this.p;
	  this.h1 = 1 / this.pn1;
	  this.pfact = (this.p + 1) * this.h1;
	  this.es = 0;

	  var omega = this.tilt;
	  var gamma = this.azi;
	  this.cg = Math.cos(gamma);
	  this.sg = Math.sin(gamma);
	  this.cw = Math.cos(omega);
	  this.sw = Math.sin(omega);
	}

	function forward$t(p) {
	  p.x -= this.long0;
	  var sinphi = Math.sin(p.y);
	  var cosphi = Math.cos(p.y);
	  var coslam = Math.cos(p.x);
	  var x, y;
	  switch (this.mode) {
	    case mode.OBLIQ:
	      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
	      break;
	    case mode.EQUIT:
	      y = cosphi * coslam;
	      break;
	    case mode.S_POLE:
	      y = -sinphi;
	      break;
	    case mode.N_POLE:
	      y = sinphi;
	      break;
	  }
	  y = this.pn1 / (this.p - y);
	  x = y * cosphi * Math.sin(p.x);

	  switch (this.mode) {
	    case mode.OBLIQ:
	      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
	      break;
	    case mode.EQUIT:
	      y *= sinphi;
	      break;
	    case mode.N_POLE:
	      y *= -(cosphi * coslam);
	      break;
	    case mode.S_POLE:
	      y *= cosphi * coslam;
	      break;
	  }

	  // Tilt 
	  var yt, ba;
	  yt = y * this.cg + x * this.sg;
	  ba = 1 / (yt * this.sw * this.h1 + this.cw);
	  x = (x * this.cg - y * this.sg) * this.cw * ba;
	  y = yt * ba;

	  p.x = x * this.a;
	  p.y = y * this.a;
	  return p;
	}

	function inverse$t(p) {
	  p.x /= this.a;
	  p.y /= this.a;
	  var r = { x: p.x, y: p.y };

	  // Un-Tilt
	  var bm, bq, yt;
	  yt = 1 / (this.pn1 - p.y * this.sw);
	  bm = this.pn1 * p.x * yt;
	  bq = this.pn1 * p.y * this.cw * yt;
	  p.x = bm * this.cg + bq * this.sg;
	  p.y = bq * this.cg - bm * this.sg;

	  var rh = hypot(p.x, p.y);
	  if (Math.abs(rh) < EPSLN) {
	    r.x = 0;
	    r.y = p.y;
	  } else {
	    var cosz, sinz;
	    sinz = 1 - rh * rh * this.pfact;
	    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
	    cosz = Math.sqrt(1 - sinz * sinz);
	    switch (this.mode) {
	      case mode.OBLIQ:
	        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
	        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
	        p.x *= sinz * this.cosph0;
	        break;
	      case mode.EQUIT:
	        r.y = Math.asin(p.y * sinz / rh);
	        p.y = cosz * rh;
	        p.x *= sinz;
	        break;
	      case mode.N_POLE:
	        r.y = Math.asin(cosz);
	        p.y = -p.y;
	        break;
	      case mode.S_POLE:
	        r.y = -Math.asin(cosz);
	        break;
	    }
	    r.x = Math.atan2(p.x, p.y);
	  }

	  p.x = r.x + this.long0;
	  p.y = r.y;
	  return p;
	}

	var names$v = ["Tilted_Perspective", "tpers"];
	var tpers = {
	  init: init$u,
	  forward: forward$t,
	  inverse: inverse$t,
	  names: names$v
	};

	function includedProjections(proj4){
	  proj4.Proj.projections.add(tmerc);
	  proj4.Proj.projections.add(etmerc);
	  proj4.Proj.projections.add(utm);
	  proj4.Proj.projections.add(sterea);
	  proj4.Proj.projections.add(stere);
	  proj4.Proj.projections.add(somerc);
	  proj4.Proj.projections.add(omerc);
	  proj4.Proj.projections.add(lcc);
	  proj4.Proj.projections.add(krovak);
	  proj4.Proj.projections.add(cass);
	  proj4.Proj.projections.add(laea);
	  proj4.Proj.projections.add(aea);
	  proj4.Proj.projections.add(gnom);
	  proj4.Proj.projections.add(cea);
	  proj4.Proj.projections.add(eqc);
	  proj4.Proj.projections.add(poly);
	  proj4.Proj.projections.add(nzmg);
	  proj4.Proj.projections.add(mill);
	  proj4.Proj.projections.add(sinu);
	  proj4.Proj.projections.add(moll);
	  proj4.Proj.projections.add(eqdc);
	  proj4.Proj.projections.add(vandg);
	  proj4.Proj.projections.add(aeqd);
	  proj4.Proj.projections.add(ortho);
	  proj4.Proj.projections.add(qsc);
	  proj4.Proj.projections.add(robin);
	  proj4.Proj.projections.add(geocent);
	  proj4.Proj.projections.add(tpers);
	}

	proj4.defaultDatum = 'WGS84'; //default datum
	proj4.Proj = Projection;
	proj4.WGS84 = new proj4.Proj('WGS84');
	proj4.Point = Point;
	proj4.toPoint = common$1;
	proj4.defs = defs;
	proj4.nadgrid = nadgrid;
	proj4.transform = transform;
	proj4.mgrs = mgrs;
	proj4.version = '__VERSION__';
	includedProjections(proj4);

	function Handler ( ctx ) {

		this.surveyTree = new Tree();
		this.limits     = new Box3();
		this.offsets    = new Vector3();
		this.allStations  = [];
		this.lineSegments = [];
		this.xGroups      = [];
		this.scraps     = [];
		this.terrains   = [];
		this.sourceCRS  = null;
		this.targetCRS  = 'EPSG:3857'; // "web mercator"
		this.displayCRS = null;
		this.projection = null;
		this.hasTerrain  = false;
		this.messages = [];
		this.metadata = null;
		this.fileCount = 0;
		this.ctx = ctx;

	}

	Handler.prototype.setCRS = function ( sourceCRS ) {

		if ( sourceCRS !== null ) {

			// work around lack of +init string support in proj4js

			const matches = sourceCRS.match( /\+init=(.*)\s/ );

			if ( matches && matches.length === 2 ) {

				const init = matches[ 1 ];
				var code;

				switch ( init ) {

				case 'epsg:27700' :

					sourceCRS = '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs';

					break;

				default:

					code = init.match( /epsg:([0-9]+)/ );

					if ( code != null ) {

						console.log( 'looking up CRS code EPSG:' + code [ 1 ] );

						return fetch( 'https://epsg.io/' + code[ 1 ] + '.proj4' )
							.then( response => {

								return response.text();

							} ).then(  text => {

								this._setCRS( text );

							} ).catch( function () { console.log( 'CRS lookup failed' ); } );

					} else {

						console.log( 'Unsupported projection:', sourceCRS );
						sourceCRS = null;

					}

				}

			}

		}

		this._setCRS( sourceCRS );

		return Promise.resolve( null );

	};

	Handler.prototype._setCRS = function ( sourceCRS ) {

		const cfg = this.ctx.cfg;
		const displayCRS = cfg.value( 'displayCRS', 'EPSG:3857' );

		if ( sourceCRS === null ) {

			sourceCRS = cfg.value( 'defaultCRS', null );

			if ( sourceCRS !== null ) console.log( 'Using default projection.' );

		}

		// FIXME use NAD grid corrections OSTM15 etc ( UK Centric )
		if ( sourceCRS !== null ) {

			this.sourceCRS = sourceCRS;

			if ( displayCRS === 'ORIGINAL' ) {

				this.displayCRS = 'ORIGINAL';

			} else {

				console.log( 'Reprojecting from', sourceCRS, 'to', this.targetCRS );

				this.projection = proj4( this.sourceCRS, this.targetCRS );
				this.displayCRS = this.targetCRS;

			}

		}

	};

	Handler.prototype.addStations = function ( stations ) {

		this.fileCount++;

		this.allStations.push( stations );

	};

	Handler.prototype.addLineSegments = function ( groups ) {

		const lineSegments = this.lineSegments;
		const l = groups.length;

		var i;

		for ( i = 0; i < l; i++ ) {

			const g = groups[ i ];
			const vMax = g.length - 1;

			let v;

			for ( v = 0; v < vMax; v++ ) {

				// create vertex pairs for each line segment.
				// all vertices except first and last are duplicated.
				const from = g[ v ];
				const to   = g[ v + 1 ];

				const fromCoords = from.coords;
				const toCoords = to.coords;

				lineSegments.push( { from: fromCoords, to: toCoords, type: to.type, survey: to.survey } );

			}

		}

	};

	Handler.prototype.addXsects = function ( xSects ) {

		const xGroups = [];
		const ends = [];

		var lastTo, xGroup, i;

		xSects.sort( function ( a, b ) { return a.m_from - b.m_from; } );

		for ( i = 0; i < xSects.length; i++ ) {

			const xSect = xSects[ i ];

			if ( xSect.m_from !== lastTo ) {

				xGroup = [];
				xGroups.push( xGroup );

			}

			lastTo = xSect.m_to;

			xGroup.push( xSect );

		}

		for ( i = 0; i < xGroups.length; i++ ) {

			const group = xGroups[ i ];

			const start = group[ 0 ].m_from;
			const end = group[ group.length - 1 ].m_to;

			// concatenate adjacent groups

			const prepend = ends.indexOf( start );

			if ( prepend !== -1 ) {

				// keep the new run in the same slot - thus end record remains correct
				xGroups[ i ] = xGroups[ prepend ].concat( group );

				// remove entry from moved group
				xGroups[ prepend ] = [];
				ends[ prepend ] = undefined;

			}

			ends.push( end );

		}

		for ( i = 0; i < xGroups.length; i++ ) {

			const group = xGroups[ i ];

			if ( group.length < 2 ) continue;

			const xSect = group[ 0 ];
			const xSectNext = group[ 1 ];

			if ( xSect === undefined ) continue; // groups that have been merged

			const start = xSectNext.start;
			const end = xSectNext.end;

			// fake approach vector for initial xSect ( mirrors first section vector )

			xSect.start = new Vector3().copy( start ).multiplyScalar( 2 ).sub( end );

			// add to model
			this.xGroups.push( group );

		}

	};

	Handler.prototype.getSurvey = function () {

		const limits = this.limits;

		if ( ! this.hasTerrain ) {

			const min = limits.min;
			const max = limits.max;

			// expand survey area by 10%

			limits.expandByVector(

				new Vector3(
					( max.x - min.x ) * 0.05,
					( max.y - min.y ) * 0.05,
					0
				)

			);

		}

		// convert to origin centered coordinates

		const offsets = limits.getCenter( this.offsets );
		const allStations = this.allStations;

		allStations.forEach( function ( all ) {

			all.forEach( function ( s ) { s.sub( offsets ); } );

		} );

		// convert scraps if present

		const scraps = this.scraps;

		var i, j;

		// covert scraps coordinates

		for ( i = 0; i < scraps.length; i++ ) {

			const vertices = scraps[ i ].vertices;

			for ( j = 0; j < vertices.length; j++ ) {

				vertices[ j ].sub( offsets );

			}

		}

		return {
			title: this.fileName,
			surveyTree: this.surveyTree,
			sourceCRS: this.sourceCRS,
			displayCRS: this.displayCRS,
			lineSegments: this.lineSegments,
			crossSections: this.xGroups,
			scraps: this.scraps,
			hasTerrain: this.hasTerrain,
			metadata: this.metadata,
			terrains: this.terrains,
			limits: this.limits,
			offsets: this.offsets
		};

	};

	function CaveLoader ( ctx, callback ) {

		if ( ! callback ) {

			alert( 'No callback specified' );

		}

		this.callback = callback;
		this.dataResponse = null;
		this.metadataResponse = null;
		this.requests = [];
		this.ctx = ctx;

		this.reset();

	}

	CaveLoader.prototype = Object.create( EventDispatcher.prototype );

	CaveLoader.prototype.constructor = CaveLoader;

	CaveLoader.prototype.reset = function () {

		this.files = null;
		this.handler = null;
		this.section = null;

		this.requests.forEach( function ( request ) { request.abort(); } );
		this.requests = [];
		this.models = new Handler( this.ctx );

	};

	CaveLoader.prototype.setHandler = function ( fileName ) {

		const extention = fileName.split( '.' ).reverse().shift().toLowerCase();

		switch ( extention ) {

		case '3d':

			this.handler = new Svx3dHandler( fileName );

			break;

		case 'lox':

			this.handler = new loxHandler( fileName );

			break;

		case 'plt':

			this.handler = new pltHandler( fileName );

			break;

		default:

			console.warn( 'CaveView: unknown file extension [', extention, ']' );
			return false;

		}

		return true;

	};

	CaveLoader.prototype.loadFile = function ( file, section ) {

		if ( file instanceof File ) {

			this.loadLocalFile( file, section );

		} else {

			this.loadURL( file, section );

		}

	};

	CaveLoader.prototype.loadFiles = function ( files ) {

		this.files = files;
		this.loadFile( files.pop() );

	};

	CaveLoader.prototype.loadURL = function ( fileName, section ) {

		const cfg = this.ctx.cfg;

		this.dispatchEvent( { type: 'progress', name: 'start' } );

		if ( section !== undefined ) this.section = section;

		const self = this;
		const prefix = cfg.value( 'surveyDirectory', '' );
		const loadMetadata = cfg.value( 'loadMetadata', false );

		// setup file handler
		if ( ! this.setHandler( fileName ) ) return false;

		const taskCount = loadMetadata ? 2 : 1;

		var doneCount = 0;

		const loader = new FileLoader().setPath( prefix );

		if ( loadMetadata ) {

			loader.setResponseType( 'json' );

			const req = loader.load( replaceExtension( fileName, 'json' ), _metadataLoaded, undefined, _metadataError );
			if ( req ) this.requests.push( req );

		}

		loader.setResponseType( this.handler.type );

		const req = loader.load( fileName, _dataLoaded, _progress, _dataError );
		if ( req ) this.requests.push( req );

		return true;

		function _dataLoaded ( result ) {

			self.dataResponse = result;

			if ( ++doneCount === taskCount ) self.callHandler();

		}

		function _metadataLoaded ( result ) {

			self.metadataResponse = result;

			if ( ++doneCount === taskCount ) self.callHandler();

		}

		function _progress ( event ) {

			if ( event.total > 0 ) self.dispatchEvent( { type: 'progress', name: 'set', progress: Math.round( 100 * event.loaded / event.total ) } );

		}

		function _dataError ( event ) {

			if ( event.type === 'abort' ) return;

			console.warn( 'error event', event );

			if ( ++doneCount === taskCount ) self.callHandler();

		}

		function _metadataError ( event ) {

			if ( event.type === 'abort' ) return;

			if ( ++doneCount === taskCount ) self.callHandler();

		}

	};

	CaveLoader.prototype.loadLocalFile = function ( file, section ) {

		this.dispatchEvent( { type: 'progress', name: 'start' } );

		if ( section !== undefined ) this.section = section;

		const self = this;
		const fileName = file.name;

		if ( ! this.setHandler( fileName ) ) return false;

		const fLoader = new FileReader();

		fLoader.addEventListener( 'load', _loaded );
		fLoader.addEventListener( 'progress', _progress );

		switch ( this.handler.type ) {

		case 'arraybuffer':

			fLoader.readAsArrayBuffer( file );

			break;

		case 'text':

			fLoader.readAsText( file );

			break;

		default:

			alert( 'unknown file data type' );
			return false;

		}

		return true;

		function _loaded () {

			self.dataResponse = fLoader.result;
			self.callHandler();

			fLoader.removeEventListener( 'load', _loaded );
			fLoader.removeEventListener( 'progress', _progress );

		}

		function _progress ( e ) {

			if ( e.total > 0 ) self.dispatchEvent( { type: 'progress', name: 'set', progress: Math.round( 100 * e.loaded / e.total ) } );

		}

	};

	CaveLoader.prototype.callHandler = function () {

		if ( this.dataResponse === null ) {

			this.callback( false );
			this.dispatchEvent( { type: 'progress', name: 'end' } );

			return;

		}

		const data = this.dataResponse;
		const metadata = this.metadataResponse;
		const section = this.section;
		const files = this.files;

		this.dataResponse = null;
		this.metadataResponse = null;

		const moreFiles = files !== null && files.length > 0;

		// start the next download to overlap parsing previous file
		const handler = this.handler;

		this.handler = null;

		if ( moreFiles ) this.loadFile( files.pop() );

		handler.parse( this.models, data, metadata, section ).then( models => {

			if ( ! moreFiles ) {

				this.callback( models );
				this.dispatchEvent( { type: 'progress', name: 'end' } );

			}

		} );

	};

	function Point$1 ( material, ctx ) {

		const materials = ctx.materials;

		if ( materials.pointGeometry === undefined ) {

			materials.pointGeometry = new BufferGeometry().setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0 ], 3 ) );

		}

		Points.call( this, materials.pointGeometry, material );

		this.type = 'Point';

		return this;

	}

	Point$1.prototype = Object.create( Points.prototype );

	function Marker( ctx, count ) {

		const materials = ctx.materials;

		Point$1.call( this, materials.getClusterMaterial( count ), ctx );
		this.renderOrder = 1;

		return this;

	}

	Marker.prototype = Object.create( Point$1.prototype );

	Marker.prototype.isMarker = true;

	Marker.prototype.adjustHeight = function ( func ) {

		this.position.setZ( func( this.position ) + 10 );

	};

	// preallocated objects for projected area calculation and cluster visibility checks

	const __a = new Vector3();
	const __b = new Vector3();
	const __c = new Vector3();
	const __d = new Vector3();

	const __t1 = new Triangle( __a, __b, __c );
	const __t2 = new Triangle( __a, __c, __d );

	const __plane = new Plane();

	const __v = new Vector3();

	function QuadTree ( ctx, xMin, xMax, yMin, yMax ) {

		this.nodes = new Array( 4 );
		this.count = 0;
		this.markers = [];
		this.quadMarker = null;
		this.centroid = new Vector3();
		this.ctx = ctx;

		this.xMin = xMin;
		this.xMax = xMax;

		this.yMin = yMin;
		this.yMax = yMax;

	}

	QuadTree.prototype.addNode = function ( marker, depth ) {

		// add marker into this quad and recurse to inner quads

		if ( depth-- === 0 ) return;

		const position = marker.position;
		const ctx = this.ctx;

		const xMid = ( this.xMin + this.xMax ) / 2;
		const yMid = ( this.yMin + this.yMax ) / 2;

		this.markers.push( marker );
		this.centroid.add( position );

		this.count++;

		var index = 0;

		if ( position.x > xMid ) index += 1;
		if ( position.y > yMid ) index += 2;

		var subQuad = this.nodes[ index ];

		if ( subQuad === undefined ) {

			switch ( index ) {

			case 0:

				subQuad = new QuadTree( ctx, this.xMin, xMid, this.yMin, yMid );
				break;

			case 1:

				subQuad = new QuadTree( ctx, xMid, this.xMax, this.yMin, yMid );
				break;

			case 2:

				subQuad = new QuadTree( ctx, this.xMin, xMid, yMid, this.yMax );
				break;

			case 3:

				subQuad = new QuadTree( ctx, xMid, this.xMax, yMid, this.yMax );
				break;

			}

			this.nodes[ index ] = subQuad;

		}

		subQuad.addNode( marker, depth );

	};

	QuadTree.prototype.check = function ( cluster, target, angleFactor, selection ) {

		var subQuad, i;

		for ( i = 0; i < 4; i++ ) {

			subQuad = this.nodes[ i ];

			if ( subQuad !== undefined ) {

				// prune quads that will never be clustered. will not be checked after first pass

				if ( subQuad.count < 2 ) {

					this.nodes[ i ] = undefined;

					continue;

				}

				// test for projected area for quad containing multiple markers

				const area = subQuad.projectedArea( cluster );

				// adjust for inclination to horizontal and distance from camera vs distance between camera and target

				__a.subVectors( cluster.camera.position, target );

				const d2Target = __a.length() * 2;

				__a.normalize();

				__plane.setFromNormalAndCoplanarPoint( __a, cluster.camera.position );

				if ( this.quadMarker === null ) {

					__b.copy( this.centroid.clone().divideScalar( this.count ) ).applyMatrix4( cluster.matrixWorld );

				} else {

					__b.copy( this.quadMarker.position ).applyMatrix4( cluster.matrixWorld );

				}

				const dCluster = Math.abs( __plane.distanceToPoint( __b ) );

				const depthRatio = ( d2Target - dCluster ) / d2Target;

				//console.log( area, 'dr', Math.round( depthRatio * 100 )/100, 'af', Math.round( angleFactor * 100 ) / 100 , '++', Math.round( depthRatio * angleFactor * 100 * 20 ) / 100);

				// cluster markers compensated for angle to the horizontal and distance from camera plane

				if ( area < 10 * depthRatio * ( angleFactor) ) { // FIXME calibrate by screen size ???

					subQuad.clusterMarkers( cluster );

				} else {

					subQuad.showMarkers( selection );
					subQuad.check( cluster, target, angleFactor, selection );

				}

			}

		}

	};

	QuadTree.prototype.showMarkers = function ( selection ) {

		// show the indiviual markers in this quad

		this.markers.forEach( function ( marker ) {

			marker.visible = selection.contains( marker.stationID );

		} );

		if ( this.quadMarker !== null ) this.quadMarker.visible = false;

	};

	QuadTree.prototype.hideMarkers = function () {

		// hide the indiviual markers in this quad

		this.markers.forEach( function ( marker ) {

			marker.visible = false;

		} );

		if ( this.quadMarker !== null ) this.quadMarker.visible = false;

	};

	QuadTree.prototype.clusterMarkers = function ( cluster ) {

		var i;

		// hide the indiviual markers in this quad

		this.hideMarkers();

		// hide quadMarkers for contained quads

		for ( i = 0; i < 4; i++ ) {

			const subQuad = this.nodes[ i ];

			if ( subQuad !== undefined ) subQuad.hideQuadMarkers();

		}

		if ( this.quadMarker === null ) {

			const quadMarker = new Marker( this.ctx, this.count );

			// set to center of distribution of markers in this quad.
			quadMarker.position.copy( this.centroid ).divideScalar( this.count );
			quadMarker.layers.set( CLUSTER_MARKERS );

			if ( cluster.heightProvider !== null ) {

				quadMarker.adjustHeight( cluster.heightProvider );

			}

			cluster.addStatic( quadMarker );

			this.quadMarker = quadMarker;

		}

		this.quadMarker.visible = true;

	};

	QuadTree.prototype.hideQuadMarkers = function () {

		var i;

		if ( this.quadMarker ) this.quadMarker.visible = false;

		for ( i = 0; i < 4; i++ ) {

			const subQuad = this.nodes[ i ];

			if ( subQuad !== undefined ) subQuad.hideQuadMarkers();

		}

	};

	QuadTree.prototype.projectedArea = function ( cluster ) {

		const camera = cluster.camera;
		const matrixWorld = cluster.matrixWorld;
		const zAverage = this.centroid.z / this.count;

		__a.set( this.xMin, this.yMin, zAverage ).applyMatrix4( matrixWorld ).project( camera );
		__b.set( this.xMin, this.yMax, zAverage ).applyMatrix4( matrixWorld ).project( camera );
		__c.set( this.xMax, this.yMax, zAverage ).applyMatrix4( matrixWorld ).project( camera );
		__d.set( this.xMax, this.yMin, zAverage ).applyMatrix4( matrixWorld ).project( camera );

		return __t1.getArea() + __t2.getArea();

	};

	function ClusterMarkers ( ctx, limits, maxDepth ) {

		Object3D.call( this );

		const min = limits.min;
		const max = limits.max;

		this.maxDepth = maxDepth;

		this.type = 'CV.ClusterMarker';

		this.quadTree = new QuadTree( ctx, min.x, max.x, min.y, max.y );
		this.heightProvider = null;
		this.labels = [];
		this.ctx = ctx;

		this.addEventListener( 'removed', this.onRemoved );

		return this;

	}

	ClusterMarkers.prototype = Object.create( Object3D.prototype );

	ClusterMarkers.prototype.addHeightProvider = function ( func ) {

		this.heightProvider = func;

		this.traverse( function _setHeight( obj ) {

			if ( obj.isMarker ) obj.adjustHeight( func );

		} );

	};

	ClusterMarkers.prototype.onRemoved = function () {

		this.traverse(

			function _traverse ( obj ) {

				if ( obj.type === 'GlyphString' ) { obj.geometry.dispose(); }

			}

		);

	};

	ClusterMarkers.prototype.addMarker = function ( node, label ) {

		const cfg = this.ctx.cfg;
		const materials = this.ctx.materials;

		// create marker
		const atlasSpec = {
			background: cfg.themeColorCSS( 'stations.entrances.background' ),
			color: cfg.themeColorCSS( 'stations.entrances.text' ),
			font: 'normal helvetica,sans-serif'
		};

		const material = materials.getGlyphMaterial( atlasSpec, Math.PI / 4 );

		material.depthTest = true;
		material.transparent = false;
		material.alphaTest = 0;

		const marker = new GlyphString( label, material, this.ctx );

		marker.layers.set( FEATURE_ENTRANCES );
		marker.position.copy( node.p );
		marker.stationID = node.id;

		this.labels.push( marker );
		this.quadTree.addNode( marker, this.maxDepth );

		this.addStatic( marker );

		return marker;

	};

	ClusterMarkers.prototype.cluster = function ( camera, target, selectedStationSet ) {

		// determine which labels are too close together to be usefully displayed as separate objects.

		// immediate exit if only a single label or none.

		if ( this.children.length < 2 ) return;

		this.camera = camera;

		const angle = this.camera.getWorldDirection( __v ).dot( Object3D.DefaultUp );

		this.quadTree.check( this, target, Math.max( 0.05, 1 - Math.cos( angle ) ), selectedStationSet );

		return;

	};

	function Entrances ( ctx, survey ) {

		ClusterMarkers.call( this, ctx, survey.modelLimits, 4 );

		const self = this;
		const surveyTree = survey.surveyTree;
		const entrances = survey.metadata.entrances;
		const vertices = [];
		const stations = [];

		const geometry = new BufferGeometry();

		const material = new PointsMaterial( {
			map: ctx.materials.textureCache.getTexture( 'disc-outlined' ),
			opacity: 1.0,
			alphaTest: 0.8,
			sizeAttenuation: false,
			transparent: true,
			size: Math.max( 10, Math.floor( ctx.container.clientWidth / 100 ) ),
			vertexColors: true
		});

		material.stencilWrite = true;
		material.stencilZPass = IncrementStencilOp;

		ctx.viewer.addEventListener( 'resized', ( e ) => {

			material.size = Math.max( 10, Math.floor( e.width / 100 ) );

		} );

		this.entranceColor = ctx.cfg.themeColor( 'stations.entrances.marker' );

		const markers = new Points( geometry, material );

		markers.layers.set( FEATURE_ENTRANCE_DOTS );

		// remove common elements from station names if no alternatives available

		var endNode = surveyTree;

		while ( endNode.children.length === 1 ) endNode = endNode.children [ 0 ];

		// find entrances and add Markers

		surveyTree.traverse( _addEntrance );

		const l = vertices.length * 3;

		if ( l > 0 ) {

			const positions = new Float32BufferAttribute( l, 3 );
			const colors = new Float32BufferAttribute( l, 3 );

			positions.copyVector3sArray( vertices );

			geometry.setAttribute( 'position', positions );
			geometry.setAttribute( 'color', colors );

		} else {

			this.visible = false;

		}

		this.markers = markers;
		this.stations = stations;
		this.metadata = survey.metadata;

		// set default colors - needs to be after markers property is set
		this.setSelection( null );

		this.addStatic( markers );

		return this;

		function _addEntrance( node ) {

			var name;

			if ( node.type !== STATION_ENTRANCE ) return;

			const entranceInfo = entrances[ node.getPath() ];

			if ( entranceInfo !== undefined && entranceInfo.name !== undefined ) {

				name = entranceInfo.name;

			} else if ( node.comment !== undefined ) {

				name = node.comment;

			} else {

				name = node.getPath( endNode );

			}

			vertices.push( node.p );
			stations.push( node );

			if ( name === '-skip' ) return;

			self.addMarker( node, ' ' + name + ' ' );

		}

	}

	Entrances.prototype = Object.create( ClusterMarkers.prototype );

	Entrances.prototype.getStation = function ( index ) {

		const station = this.stations[ index ];
		const stationName = station.getPath();

		return {
			station: station,
			name: stationName,
			info: this.metadata.entrances[ stationName ]
		};

	};

	Entrances.prototype.setStation = function ( station, info ) {

		const metadata = this.metadata;

		metadata.entrances[ station.getPath() ] = info;

		metadata.saveLocal();

	};

	Entrances.prototype.intersectLabels = function ( mouse, camera, scale ) {

		var labels = this.labels.filter( _filter ).sort( _sort );

		return ( labels.length === 0 ) ? null : labels[ 0 ];

		function _filter ( label ) {

			return label.intersects( mouse, camera, scale );

		}

		function _sort ( a, b ) {

			return a.depth - b.depth;

		}

	};

	Entrances.prototype.setSelection = function ( selection ) {

		const colors = this.markers.geometry.getAttribute( 'color' );
		const color = this.entranceColor;

		if ( colors === undefined ) return;

		if ( selection === null || selection.isEmpty() ) {

			const array = colors.array;
			const l = array.length;

			for ( let i = 0; i < l; i += 3 ) {

				color.toArray( array, i );

			}

		} else {

			const idSet = selection.getIds();

			this.stations.forEach( function ( node, i ) {

				if ( idSet.has( node.id ) ) {

					color.toArray( colors, i * 3 );

				} else {

					colors.setXYZ( i, 0.5, 0.5, 0.5 );

				}

			} );

		}

		colors.needsUpdate = true;

	};

	const img = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='36px' height='36px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z'/%3E%3C/svg%3E";

	function PointIndicator ( ctx, color ) {

		const materials = ctx.materials;

		if ( materials.pointerTexture === undefined ) {

			materials.pointerTexture = new TextureLoader().load( img );

		}

		const material = new PointsMaterial( { size: 32, map: materials.pointerTexture, transparent : true, sizeAttenuation: false, alphaTest: 0.8, color: color } );

		Point$1.call( this, material, ctx );

		return this;

	}

	PointIndicator.prototype = Object.create( Point$1.prototype );

	const __v$1 = new Vector3();

	function onUploadDropBuffer$2() {

		// call back from BufferAttribute to drop JS buffers after data has been transfered to GPU
		this.array = null;

	}

	function Stations ( ctx, selection ) {

		Points.call( this, new BufferGeometry, ctx.materials.getExtendedPointsMaterial() );

		this.type = 'CV.Stations';
		this.map = new Map();
		this.stationCount = 0;

		const cfg = ctx.cfg;

		this.baseColor     = cfg.themeColor( 'stations.default.marker' );
		this.junctionColor = cfg.themeColor( 'stations.junctions.marker' );
		this.entranceColor = cfg.themeColor( 'stations.entrances.marker' );

		this.pointSizes = [];
		this.vertices   = [];
		this.colors     = [];

		this.stations = [];

		this.selected = null;
		this.selectedSize = 0;
		this.selection = selection;
		this.splaysVisible = false;

		const point = new PointIndicator( ctx, 0xff0000 );

		point.visible = false;

		this.addStatic( point );
		this.highlightPoint = point;

	}

	Stations.prototype = Object.create ( Points.prototype );

	Stations.prototype.addStation = function ( node ) {

		const point = node.p;

		const seen = this.map.get( point );

		if ( seen !== undefined ) {

			// console.log( 'duplicate', node.getPath(), seen.getPath() );
			return;

		}

		const connections = point.connections;

		this.vertices.push( point );


		var pointSize = 0.0;

		if ( node.type === STATION_ENTRANCE ) {

			this.colors.push( this.entranceColor );

			pointSize = 12.0;

		} else {

			this.colors.push( connections > 2 ? this.junctionColor : this.baseColor );

			pointSize = 8.0;

		}

		this.pointSizes.push( pointSize );

		this.map.set( point, node );
		this.stations.push( node );

		node.stationVertexIndex = this.stationCount++;
		node.linkedSegments = [];
		node.legs = [];
		node.distance = Infinity;

	};

	Stations.prototype.getStation = function ( vertex ) {

		return this.map.get( vertex );

	};

	Stations.prototype.getVisibleStation = function ( vertex ) {

		const node = this.map.get( vertex );

		if ( this.selection.contains( node.id ) &&
			( node.p.connections > 0 || this.splaysVisible )
		) return node;

		if ( node.label !== undefined ) node.label.visible = false;

		return null;

	};

	Stations.prototype.getStationByIndex = function ( index ) {

		return this.stations[ index ];

	};

	Stations.prototype.clearSelected = function () {

		if ( this.selected !== null ) {

			const pSize = this.geometry.getAttribute( 'pSize' );

			pSize.setX( this.selected, this.selectedSize );
			pSize.needsUpdate = true;

			this.selected = null;

		}

	};

	Stations.prototype.highlightStation = function ( node ) {

		const highlightPoint = this.highlightPoint;

		highlightPoint.position.copy( node.p );
		highlightPoint.updateMatrix();

		highlightPoint.visible = true;

		return node;

	};

	Stations.prototype.clearHighlight = function () {

		this.highlightPoint.visible = false;

	};

	Stations.prototype.selectStation = function ( node ) {

		this.selectStationByIndex( node.stationVertexIndex );

	};

	Stations.prototype.selectStationByIndex = function ( index ) {

		const pSize = this.geometry.getAttribute( 'pSize' );

		if ( this.selected !== null ) {

			pSize.setX( this.selected, this.selectedSize );

		}

		this.selectedSize = pSize.getX( index );

		pSize.setX( index, this.selectedSize * 2 );

		pSize.needsUpdate = true;

		this.selected = index;

	};

	Stations.prototype.selectStations = function ( selection ) {

		const stations = this.stations;
		const l = stations.length;
		const pSize = this.geometry.getAttribute( 'pSize' );
		const splaySize = this.splaysVisible ? 6.0 : 0.0;
		const idSet = selection.getIds();
		const isEmpty = selection.isEmpty();

		var i;

		for ( i = 0; i < l; i++ ) {

			const node = stations[ i ];

			let size = 8;

			if ( isEmpty || idSet.has( node.id ) ) {

				if ( node.type === STATION_ENTRANCE ) {

					size = 12;

				} else if ( node.p.connections === 0 ) {

					size = splaySize;

				}

				pSize.setX( i , size );

			} else {

				pSize.setX( i, 0 );

				if ( node.label !== undefined ) node.label.visible = false;

			}

		}

		pSize.needsUpdate = true;

	};

	Stations.prototype.finalise = function () {

		const bufferGeometry = this.geometry;

		const positions = new Float32BufferAttribute(this.vertices.length * 3, 3 );
		const colors = new Float32BufferAttribute( this.colors.length * 3, 3 );

		bufferGeometry.setAttribute( 'pSize', new Float32BufferAttribute( this.pointSizes, 1 ) );
		bufferGeometry.setAttribute( 'position', positions.copyVector3sArray( this.vertices ) );
		bufferGeometry.setAttribute( 'color', colors.copyColorsArray( this.colors ) );

		bufferGeometry.getAttribute( 'color' ).onUpload( onUploadDropBuffer$2 );

		this.pointSizes = null;
		this.colors = null;

	};

	Stations.prototype.resetDistances = function () {

		this.stations.forEach( function _resetDistance( node ) { node.distance = Infinity; } );

	};

	Stations.prototype.getClosestVisibleStation = function ( camera, intersects ) {

		const splaysVisible = this.splaysVisible;
		const self = this;

		var minD2 = Infinity;
		var closestStation = null;

		intersects.forEach( function _checkIntersects( intersect ) {

			const station = self.getStationByIndex( intersect.index );

			// don't select spays unless visible

			if ( ! splaysVisible && station !== null && station.p.connections === 0 ) return;

			// station in screen NDC
			__v$1.copy( station.p ).applyMatrix4( self.matrixWorld ).project( camera );

			__v$1.sub( intersect.point.project( camera ) );

			const d2 = __v$1.x * __v$1.x + __v$1.y * __v$1.y;

			// choose closest of potential matches in screen x/y space

			if ( d2 < minD2 ) {

				minD2 = d2;
				closestStation = station;

			}

		} );

		return closestStation;

	};

	Stations.prototype.setSplaysVisibility = function ( visible ) {

		this.splaysVisible = visible;
		const splaySize = visible ? 6.0 : 0.0;

		const stations = this.stations;
		const pSize = this.geometry.getAttribute( 'pSize' );
		const l = stations.length;
		const selection = this.selection;

		var i;

		for ( i = 0; i < l; i++ ) {

			const node = stations[ i ];

			if ( node.p.connections === 0 && ( splaySize == 0 || selection.contains( node.id ) ) ) {

				pSize.setX( i, splaySize );

			}

		}

		pSize.needsUpdate = true;

	};

	const _tmpVector3 = new Vector3();

	function StationLabels ( ctx, stations, commentCount ) {

		Group.call( this );

		this.type = 'CV.StationLabels';
		this.stations = stations;
		this.commentCount = commentCount;
		this.ctx = ctx;

		const cfg = ctx.cfg;
		const materials = ctx.materials;

		const atlasSpecDefault = {
			color: cfg.themeColorCSS( 'stations.default.text' ),
			font: cfg.themeValue( 'stations.font' )
		};

		this.defaultLabelMaterial = materials.getGlyphMaterial( atlasSpecDefault, 0 );
		this.splayLabelMaterial = materials.getGlyphMaterial( atlasSpecDefault, 0 );

		const atlasSpecJunction = {
			color: cfg.themeColorCSS( 'stations.junctions.text' ),
			font: cfg.themeValue( 'stations.font' )
		};

		this.junctionLabelMaterial = materials.getGlyphMaterial( atlasSpecJunction, 0 );

	}

	StationLabels.prototype = Object.create ( Group.prototype );

	StationLabels.prototype.update = function ( camera, target, inverseWorld ) {

		const cameraPosition = _tmpVector3.copy( camera.position );

		if ( camera.isOrthographicCamera ) {

			// if orthographic, calculate 'virtual' camera position

			cameraPosition.sub( target ); // now vector from target

			cameraPosition.setLength( CAMERA_OFFSET / camera.zoom ); // scale for zoom factor
			cameraPosition.add( target ); // relocate in world space

		}

		// transform camera position into model coordinate system

		cameraPosition.applyMatrix4( inverseWorld );

		const stations = this.stations;
		const points = stations.vertices;
		const l = points.length;

		const showName = ( ( camera.layers.mask & 1 << LABEL_STATION ) !== 0 );
		const showComment = ( ( camera.layers.mask & 1 << LABEL_STATION_COMMENT ) !== 0 );
		const commentRatio = l / this.commentCount;

		for ( var i = 0; i < l; i++ ) {

			const position = points[ i ];

			const station = stations.getVisibleStation( position );

			if ( station !== null ) {

				const label = station.label;

				let d2 = 40000;

				if ( position.connections === 0 ) {

					d2 = 250;

				} else if ( position.connections < 3 ) {

					d2 = 5000;

				}

				// eager display of comments scaled by density of comments in survey
				if ( showComment && station.comment !== undefined ) d2 *= commentRatio;

				// show labels for network vertices at greater distance than intermediate stations
				const visible = ( position.distanceToSquared( cameraPosition ) < d2 );

				let name = '';

				if ( showName ) name += station.name;
				if ( showName && showComment && station.comment !== undefined ) name += ' ';
				if ( showComment && station.comment !== undefined ) name += station.comment;

				if ( ! label || label.name !== name ) {

					// remove label with the wrong text
					if ( label !== undefined ) {

						this.remove( label );
						station.label = null;

					}

					if ( visible ) this.addLabel( station, name );

				} else {

					label.visible = visible;

				}

			}

		}

	};

	StationLabels.prototype.addLabel = function ( station, name ) {

		var material;

		const position = station.p;
		const connections = position.connections;

		if ( connections === 0 ) {

			material = this.splayLabelMaterial;

		} else if ( connections < 3 ) {

			material = this.defaultLabelMaterial;

		} else {

			material = this.junctionLabelMaterial;

		}

		const label = new GlyphString( name, material, this.ctx );

		label.layers.mask = this.layers.mask;
		label.position.copy( position );

		station.label = label;

		this.addStatic( label );

	};

	function StationMarkers ( ctx, color ) {

		Group.call( this );

		this.markers = new Map();
		this.markerColor = color;
		this.ctx = ctx;

		return this;

	}

	StationMarkers.prototype = Object.create( Group.prototype );

	StationMarkers.prototype.mark = function ( node ) {

		const markers = this.markers;

		if ( markers.has( node ) ) return;

		const marker = new PointIndicator( this.ctx, this.markerColor );

		marker.position.copy( node.p );
		marker.station = node;
		marker.layers = this.layers;

		this.add( marker );

		markers.set( node, marker );

	};

	StationMarkers.prototype.unmark = function ( node ) {

		const markers = this.markers;

		const marker = markers.get( node );

		if ( marker === undefined ) return;

		this.remove( marker );

		markers.delete( node );

	};

	StationMarkers.prototype.clear = function () {

		const self = this;

		this.markers.forEach( function ( marker ) {

			self.remove( marker );

		} );

		this.markers.clear();

	};

	StationMarkers.prototype.getStations = function () {

		const list = [];

		this.markers.forEach( function ( value, key ) { list.push( key ); } );

		return list;

	};

	StationMarkers.prototype.setVisibility = function ( visible ) {

		this.markers.forEach( function ( marker ) { marker.visible = visible; } );

	};

	function Topology ( stations, legsObject ) {

		if ( stations.length === 0 || ! legsObject ) return;

		this.stations = stations;
		this.legsObject = legsObject;

		this.vertexPairToSegment = []; // maps vertex index to segment membership
		this.segmentMap = new Map(); // maps segments of survey between ends of passages and junctions.
		this.segmentToInfo = {};

		this.maxDistance = 0;
		this.zeroStation = null;

		// determine segments between junctions and entrances/passage ends and create mapping array.

		const legs = legsObject.legVertices;
		const segmentMap = this.segmentMap;
		const vertexPairToSegment = this.vertexPairToSegment;
		const segmentToInfo = this.segmentToInfo;
		const l = legs.length;

		var station;
		var newSegment = true;
		var segment = 0;
		var segmentInfo;
		var i;

		for ( i = 0; i < l; i = i + 2 ) {

			const v1 = legs[ i ];
			const v2 = legs[ i + 1 ];

			vertexPairToSegment.push( segment );

			station = stations.getStation( v1 );

			if ( station !== undefined ) {

				station.legs.push( i );
				station.linkedSegments.push( segment );

			}

			if ( newSegment ) {

				if ( station === undefined ) continue; // possible use of separator in station name.

				segmentInfo = {
					segment: segment,
					startStation: station,
					endStation: null,
				};

				newSegment = false;

			}

			station = stations.getStation( v2 );
			if ( station !== undefined ) station.legs.push( i );

			if ( station && ( v2.connections > 2 || ( i + 2 < l && ! v2.equals( legs[ i + 2 ] ) ) ) ) {

				// we have found a junction or a passage end
				segmentInfo.endStation = station;

				segmentMap.set( segmentInfo.startStation.id + ':' + station.id, segmentInfo );
				segmentToInfo[ segment ] = segmentInfo;

				station.linkedSegments.push( segment );

				segment++;

				newSegment = true;

			}

		}

		if ( ! newSegment ) {

			segmentInfo.endStation = station;

			segmentMap.set( segmentInfo.startStation.id + ':' + station.id, segmentInfo );

			station.linkedSegments.push( segment );

		}

		return this;

	}

	Topology.prototype.vertexSegment = function ( index ) {

		return this.vertexPairToSegment[ index / 2 ];

	};

	Topology.prototype.shortestPathSearch = function ( station ) {

		// queue of stations searched.
		const queue = [ station ];

		const legsObject = this.legsObject;
		const legs = legsObject.legVertices;
		const stations = this.stations;

		stations.resetDistances();

		var maxDistance = 0;

		station.distance = 0;

		while ( queue.length > 0 ) {

			const station = queue.shift();
			const currentDistance = station.distance;
			const stationLegs = station.legs;

			// console.log( 'station:', station.getPath(), currentDistance );

			maxDistance = Math.max( maxDistance, currentDistance );

			let i;

			// find stations connected to this station
			for ( i = 0; i < stationLegs.length; i++ ) {

				const leg = stationLegs[ i ];

				const v1 = legs[ leg ];
				const v2 = legs[ leg + 1 ];

				const nextVertex = ( v1 !== station.p ) ? v1 : v2;
				const nextStation = stations.getStation( nextVertex );
				const nextLength = legsObject.legLengths[ leg / 2 ];

				// label stations with distance of shortest path
				// add to search list

				if ( nextStation.distance > currentDistance + nextLength ) {

					nextStation.distance = currentDistance + nextLength;
					queue.push( nextStation );

					// console.log( 'new next', nextStation.distance, queue.length );

				}

			}

		}

		// console.log( 'max:', maxDistance );
		this.zeroStation = station;
		this.maxDistance = maxDistance;

	};

	Topology.prototype.getShortestPath = function ( startStation ) {

		const zeroStation = this.zeroStation;
		const path = new Set();

		if (
			this.zeroStation === null ||
			startStation.distance === Infinity ||
			this.zeroStation === startStation ||
			startStation.distance === 0
		) return path;

		const stations = this.stations;
		const legsObject = this.legsObject;
		const legs = legsObject.legVertices;

		var nextStation = startStation;
		var testNext = true;


		// for each station find station with shortest distance to zeroStation

		while ( testNext ) {

			const stationLegs = nextStation.legs;
			const l = stationLegs.length;

			let i;

			for ( i = 0; i < l; i++ ) {

				const leg = stationLegs[ i ];

				const v1 = legs[ leg ];
				const v2 = legs[ leg + 1 ];

				const nextVertex = ( v1 !== nextStation.p ) ? v1 : v2;
				const testStation = stations.getStation( nextVertex );

				if ( testStation.distance < nextStation.distance ) {

					nextStation = testStation;
					path.add( leg );

					if ( nextStation === zeroStation ) testNext = false;

				}

			}

		}

		return path;

	};

	function Routes ( survey ) {

		// determine segments between junctions and entrances/passage ends and create mapping array.

		this.metadata = survey.metadata;
		this.topology = survey.topology;
		this.surveyTree = survey.surveyTree;

		this.routes = new Map();
		this.routeNames = [];

		this.currentRoute = new Set();
		this.currentRouteName = null;
		this.adjacentSegments = new Set();

		Object.defineProperty( this, 'setRoute', {
			set: function ( x ) { this.loadRoute( x ); },
			get: function () { return this.currentRouteName; }
		} );

		const routes = this.metadata.getRoutes();
		const routeNames = this.routeNames;

		var routeName;

		for ( routeName in routes ) {

			const route = routes[ routeName ];

			routeNames.push( routeName );
			this.routes.set( routeName, route.segments );

		}

		routeNames.sort();

		this.dispatchEvent( { type: 'changed', name: 'download' } );

	}

	Object.assign( Routes.prototype, EventDispatcher.prototype );

	Routes.prototype.addRoute = function ( routeName ) {

		if ( routeName === this.currentRouteName || routeName === undefined ) return;

		if ( this.routeNames.indexOf( routeName ) < 0 ) {

			// create entry for empty route if a new name

			this.routeNames.push( routeName );
			this.routes.set( routeName, [] );

		}

		this.loadRoute( routeName );

	};

	Routes.prototype.loadRoute = function ( routeName ) {

		const self = this;

		const surveyTree = this.surveyTree;
		const currentRoute = this.currentRoute;
		const segmentMap = this.topology.segmentMap;
		const routeSegments = this.routes.get( routeName );

		var i;

		if ( ! routeSegments ) {

			alert( 'route ' + routeName + ' does not exist' );
			return false;

		}

		currentRoute.clear();

		for ( i = 0; i < routeSegments.length; i++ ) {

			const segment = routeSegments[ i ];

			const map = segmentMap.get( surveyTree.getIdByPath( segment.start ) + ':' + surveyTree.getIdByPath( segment.end ) );

			if ( map !== undefined ) currentRoute.add( map.segment );

		}

		this.currentRouteName = routeName;

		self.dispatchEvent( { type: 'changed', name: '' } );

		return true;

	};

	Routes.prototype.getCurrentRoute = function () {

		return this.currentRoute;

	};

	Routes.prototype.saveCurrent = function () {

		const routeName = this.currentRouteName;
		const segmentMap = this.topology.segmentMap;
		const route = this.currentRoute;

		if ( ! routeName ) return;

		const routeSegments = [];

		segmentMap.forEach( _addRoute );

		// update in memory route

		this.routes.set( routeName, routeSegments );

		// update persistant browser storage

		this.metadata.saveRoute( routeName, { segments: routeSegments } );

		function _addRoute ( value /*, key */ ) {

			if ( route.has( value.segment ) ) {

				routeSegments.push( {
					start: value.startStation.getPath(),
					end: value.endStation.getPath()
				} );

			}

		}

	};

	Routes.prototype.getRouteNames = function () {

		return this.routeNames;

	};

	Routes.prototype.toggleSegment = function ( index ) {

		const self = this;
		const route = this.currentRoute;
		const segment = this.topology.vertexSegment( index );

		this.adjacentSegments.clear();

		if ( route.has( segment ) ) {

			route.delete( segment );

		} else {

			route.add( segment );

			// handle adjacent segments to the latest segment toggled 'on'

			const segmentInfo = this.topology.segmentToInfo[ segment ];

			if ( segmentInfo !== undefined ) {

				segmentInfo.startStation.linkedSegments.forEach( _setAdjacentSegments );
				segmentInfo.endStation.linkedSegments.forEach( _setAdjacentSegments );

			}

		}

		return;

		function _setAdjacentSegments ( segment ) {

			if ( ! route.has( segment ) ) self.adjacentSegments.add( segment );

		}

	};

	Routes.prototype.inCurrentRoute = function ( index ) {

		return this.currentRoute.has( this.topology.vertexSegment( index ) );

	};

	Routes.prototype.adjacentToRoute = function ( index ) {

		return this.adjacentSegments.has( this.topology.vertexSegment( index ) );

	};

	var LineSegmentsGeometry = function () {

		InstancedBufferGeometry.call( this );

		this.type = 'LineSegmentsGeometry';

		var positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];
		var uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];
		var index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];

		this.setIndex( index );
		this.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	};

	LineSegmentsGeometry.prototype = Object.assign( Object.create( InstancedBufferGeometry.prototype ), {

		constructor: LineSegmentsGeometry,

		isLineSegmentsGeometry: true,

		applyMatrix4: function ( matrix ) {

			var start = this.attributes.instanceStart;
			var end = this.attributes.instanceEnd;

			if ( start !== undefined ) {

				start.applyMatrix4( matrix );

				end.applyMatrix4( matrix );

				start.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		setPositions: function ( array ) {

			var lineSegments;

			if ( array instanceof Float32Array ) {

				lineSegments = array;

			} else if ( Array.isArray( array ) ) {

				lineSegments = new Float32Array( array );

			}

			var instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz

			this.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz
			this.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz

			//

			this.computeBoundingBox();
			this.computeBoundingSphere();

			return this;

		},

		setColors: function ( array ) {

			var colors;

			if ( array instanceof Float32Array ) {

				colors = array;

			} else if ( Array.isArray( array ) ) {

				colors = new Float32Array( array );

			}

			var instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb

			this.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb
			this.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb

			return this;

		},

		computeBoundingBox: function () {

			var box = new Box3();

			return function computeBoundingBox() {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				var start = this.attributes.instanceStart;
				var end = this.attributes.instanceEnd;

				if ( start !== undefined && end !== undefined ) {

					this.boundingBox.setFromBufferAttribute( start );

					box.setFromBufferAttribute( end );

					this.boundingBox.union( box );

				}

			};

		}(),

		computeBoundingSphere: function () {

			var vector = new Vector3();

			return function computeBoundingSphere() {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				if ( this.boundingBox === null ) {

					this.computeBoundingBox();

				}

				var start = this.attributes.instanceStart;
				var end = this.attributes.instanceEnd;

				if ( start !== undefined && end !== undefined ) {

					var center = this.boundingSphere.center;

					this.boundingBox.getCenter( center );

					var maxRadiusSq = 0;

					for ( var i = 0, il = start.count; i < il; i ++ ) {

						vector.fromBufferAttribute( start, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

						vector.fromBufferAttribute( end, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );

					}

				}

			};

		}(),

	} );

	var LineSegments2 = function ( geometry, material ) {

		if ( geometry === undefined ) geometry = new LineSegmentsGeometry();
		if ( material === undefined ) material = new LineMaterial( { color: Math.random() * 0xffffff } );

		Mesh.call( this, geometry, material );

		this.type = 'LineSegments2';

	};

	LineSegments2.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: LineSegments2,

		isLineSegments2: true,

		computeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				var instanceStart = geometry.attributes.instanceStart;
				var instanceEnd = geometry.attributes.instanceEnd;
				var lineDistances = new Float32Array( 2 * instanceStart.data.count );

				for ( var i = 0, j = 0, l = instanceStart.data.count; i < l; i ++, j += 2 ) {

					start.fromBufferAttribute( instanceStart, i );
					end.fromBufferAttribute( instanceEnd, i );

					lineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];
					lineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );

				}

				var instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1

				geometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0
				geometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1

				return this;

			};

		}() ),

		raycast: ( function () {

			var start = new Vector4();
			var end = new Vector4();

			var ssOrigin = new Vector4();
			var ssOrigin3 = new Vector3();
			var mvMatrix = new Matrix4();
			var line = new Line3();
			var closestPoint = new Vector3();

			return function raycast( raycaster, intersects ) {

				if ( raycaster.camera === null ) {

					console.error( 'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.' );

				}

				var threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;

				var ray = raycaster.ray;
				var camera = raycaster.camera;
				var projectionMatrix = camera.projectionMatrix;

				var geometry = this.geometry;
				var material = this.material;
				var resolution = material.resolution;
				var lineWidth = material.linewidth + threshold;

				var instanceStart = geometry.attributes.instanceStart;
				var instanceEnd = geometry.attributes.instanceEnd;

				// pick a point 1 unit out along the ray to avoid the ray origin
				// sitting at the camera origin which will cause "w" to be 0 when
				// applying the projection matrix.
				ray.at( 1, ssOrigin );

				// ndc space [ - 1.0, 1.0 ]
				ssOrigin.w = 1;
				ssOrigin.applyMatrix4( camera.matrixWorldInverse );
				ssOrigin.applyMatrix4( projectionMatrix );
				ssOrigin.multiplyScalar( 1 / ssOrigin.w );

				// screen space
				ssOrigin.x *= resolution.x / 2;
				ssOrigin.y *= resolution.y / 2;
				ssOrigin.z = 0;

				ssOrigin3.copy( ssOrigin );

				var matrixWorld = this.matrixWorld;
				mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );

				for ( var i = 0, l = instanceStart.count; i < l; i ++ ) {

					start.fromBufferAttribute( instanceStart, i );
					end.fromBufferAttribute( instanceEnd, i );

					start.w = 1;
					end.w = 1;

					// camera space
					start.applyMatrix4( mvMatrix );
					end.applyMatrix4( mvMatrix );

					// clip space
					start.applyMatrix4( projectionMatrix );
					end.applyMatrix4( projectionMatrix );

					// ndc space [ - 1.0, 1.0 ]
					start.multiplyScalar( 1 / start.w );
					end.multiplyScalar( 1 / end.w );

					// skip the segment if it's outside the camera near and far planes
					var isBehindCameraNear = start.z < - 1 && end.z < - 1;
					var isPastCameraFar = start.z > 1 && end.z > 1;
					if ( isBehindCameraNear || isPastCameraFar ) {

						continue;

					}

					// screen space
					start.x *= resolution.x / 2;
					start.y *= resolution.y / 2;

					end.x *= resolution.x / 2;
					end.y *= resolution.y / 2;

					// create 2d segment
					line.start.copy( start );
					line.start.z = 0;

					line.end.copy( end );
					line.end.z = 0;

					// get closest point on ray to segment
					var param = line.closestPointToPointParameter( ssOrigin3, true );
					line.at( param, closestPoint );

					// check if the intersection point is within clip space
					var zPos = MathUtils.lerp( start.z, end.z, param );
					var isInClipSpace = zPos >= - 1 && zPos <= 1;

					var isInside = ssOrigin3.distanceTo( closestPoint ) < lineWidth * 0.5;

					if ( isInClipSpace && isInside ) {

						line.start.fromBufferAttribute( instanceStart, i );
						line.end.fromBufferAttribute( instanceEnd, i );

						line.start.applyMatrix4( matrixWorld );
						line.end.applyMatrix4( matrixWorld );

						var pointOnLine = new Vector3();
						var point = new Vector3();

						ray.distanceSqToSegment( line.start, line.end, point, pointOnLine );

						intersects.push( {

							point: point,
							pointOnLine: pointOnLine,
							distance: ray.origin.distanceTo( point ),

							object: this,
							face: null,
							faceIndex: i,
							uv: null,
							uv2: null,

						} );

					}

				}

			};

		}() )

	} );

	function Legs ( ctx ) {

		Group.call( this );

		this.ctx = ctx;
		this.legLengths = [];
		this.legVertices = [];
		this.colors = [];

		return this;

	}

	Legs.prototype = Object.create( Group.prototype );

	Legs.prototype.type = 'Legs';

	Legs.prototype.addLegs = function ( vertices, legRuns ) {

		const ctx = this.ctx;

		this.legVertices = vertices;
		this.legRuns = legRuns;

		var legs = null;

		if ( ctx.cfg.value( 'gl-lines', false ) ) {

			legs = new ThinLegs( ctx );

		} else {

			legs = new FatLegs( ctx );

		}

		// these buffers have the same layout independant of the rendering material
		// standard gl_LINES or fat lines.

		const positions = new Float32BufferAttribute( vertices.length * 3, 3 );
		const colors = new Float32BufferAttribute( vertices.length * 3, 3 );

		positions.copyVector3sArray( vertices );
		colors.array.fill( 1.0 );

		legs.addLegs( positions, colors );

		legs.setShading = function () {};
		legs.layers = this.layers;

		this.computeStats();
		this.addStatic( legs );

		this.colors = colors;
		this.legs = legs;

		return this;

	};

	Legs.prototype.computeStats = function () {

		const stats = { maxLegLength: -Infinity, minLegLength: Infinity, legCount: 0, legLength: 0 };
		const vertices = this.legVertices;
		const l = vertices.length;

		const n = l / 2;
		const legLengths = new Array( n );

		var i, s1 = 0, s2 = 0;

		for ( i = 0; i < l; i += 2 ) {

			const vertex1 = vertices[ i ];
			const vertex2 = vertices[ i + 1 ];

			const legLength = vertex1.correctedDistanceTo( vertex2 );

			legLengths[ i / 2 ] = legLength; // cache lengths to avoid recalc

			s1 += legLength;
			s2 += legLength * legLength;

			stats.maxLegLength = Math.max( stats.maxLegLength, legLength );
			stats.minLegLength = Math.min( stats.minLegLength, legLength );

		}

		stats.legLength = s1;
		stats.legLengthSD = Math.sqrt( s2 / n - Math.pow( s1 / n, 2 ) );
		stats.legLengthRange = stats.maxLegLength - stats.minLegLength;
		stats.legCount = n;

		this.legLengths = legLengths;
		this.stats = stats;

		return this;

	};

	Legs.prototype.cutRuns = function ( selection ) {

		const idSet = selection.getIds();
		const legRuns = this.legRuns;

		if ( ! legRuns ) return;

		const vertices = this.legVertices;

		const newVertices = [];
		const newLegRuns = [];

		const l = legRuns.length;

		var run;

		for ( run = 0; run < l; run++ ) {

			const legRun = legRuns[ run ];

			const survey = legRun.survey;
			const start  = legRun.start;
			const end    = legRun.end;

			let vp = 0;

			if ( idSet.has( survey ) ) {

				for ( var v = start; v < end; v++ ) {

					newVertices.push( vertices[ v ] );

				}

				// adjust vertex run for new vertices and color arrays

				legRun.start = vp;

				vp += end - start;

				legRun.end = vp;

				newLegRuns.push( legRun );

			}

		}

		if ( newVertices.length === 0 ) return false;

		this.legs.geometry.dispose();
		this.remove( this.legs );

		this.addLegs( newVertices, newLegRuns );

		return true;

	};

	Legs.prototype.setShading = function ( idSet, colourSegment, mode ) {

		this.legs.updateMaterial( this.ctx, mode );

		const legRuns = this.legRuns;
		const unselectedColor = this.ctx.cfg.themeColor( 'shading.unselected' );

		var l, run, v;

		const vertices = this.legVertices;
		const colors = this.colors.array;

		if ( idSet.size > 0 && legRuns ) {

			for ( run = 0, l = legRuns.length; run < l; run++ ) {

				const legRun = legRuns[ run ];

				const survey = legRun.survey;
				const start  = legRun.start;
				const end    = legRun.end;

				if ( idSet.has( survey ) ) {

					for ( v = start; v < end; v += 2 ) {

						colourSegment( vertices, colors, v, v + 1, survey );

					}

				} else {

					for ( v = start; v < end; v += 2 ) {

						unselectedColor.toArray( colors, v * 3 );
						unselectedColor.toArray( colors, ( v + 1 ) * 3 );

					}

				}

			}

		} else {

			for ( v = 0, l = vertices.length; v < l; v += 2 ) {

				colourSegment( vertices, colors, v, v + 1, null );

			}

		}

		this.legs.updateColors();

	};

	function ThinLegs ( ctx ) {

		const geometry = new BufferGeometry();

		LineSegments.call( this, geometry, ctx.materials.getUnselectedMaterial() );

		return this;

	}

	ThinLegs.prototype = Object.create( LineSegments.prototype );

	FatLegs.prototype.type = 'CV.FatLegs';

	ThinLegs.prototype.addLegs = function ( positions, colors ) {

		const geometry = this.geometry;

		geometry.setAttribute( 'position', positions );
		geometry.setAttribute( 'color', colors );

		geometry.computeBoundingBox();

		return this;

	};

	ThinLegs.prototype.updateColors = function () {

		this.geometry.getAttribute( 'color' ).needsUpdate = true;

	};

	ThinLegs.prototype.updateMaterial = function ( ctx, mode ) {

		const materials = ctx.materials;

		switch ( mode ) {

		case 'height':
			this.material = materials.getHeightMaterial( MATERIAL_LINE );
			break;

		case 'depth':
			this.material = materials.getDepthMaterial( MATERIAL_LINE );
			break;

		case 'depth-cursor':
			this.material = materials.getDepthCursorMaterial( MATERIAL_LINE );
			break;

		case 'cursor':
			this.material = materials.getCursorMaterial( MATERIAL_LINE );
			break;

		case 'basic':
			this.material = materials.getLineMaterial();
			break;

		}

		this.material.needsUpdate = true;

	};

	function FatLegs ( ctx ) {

		const geometry = new LineSegmentsGeometry();

		LineSegments2.call( this, geometry, ctx.materials.getUnselectedMaterial() );

		this.scale.set( 1, 1, 1 );

		return this;

	}

	FatLegs.prototype = Object.create( LineSegments2.prototype );

	FatLegs.prototype.type = 'CV.FatLegs';

	FatLegs.prototype.addLegs = function ( positions, colors ) {

		const geometry = this.geometry;

		geometry.setPositions( positions.array );
		geometry.setColors( colors.array );

		return this;

	};

	FatLegs.prototype.updateColors = function () {

		this.geometry.getAttribute( 'instanceColorStart' ).needsUpdate = true;
		this.geometry.getAttribute( 'instanceColorEnd' ).needsUpdate = true;

	};

	FatLegs.prototype.updateMaterial = function ( ctx, mode ) {

		this.material = ctx.materials.getLine2Material( mode );
		this.material.needsUpdate = true;

	};

	function WaterMaterial () {

		ShaderMaterial.call( this, {
			vertexShader: Shaders.waterVertexShader,
			fragmentShader: Shaders.waterFragmentShader,
			depthWrite: false,
			type: 'CV.WaterMaterial',
			uniforms: {
				offset: { value: 0 }
			},
			side: DoubleSide
		} );

		return this;

	}

	WaterMaterial.prototype = Object.create( ShaderMaterial.prototype );

	function beforeRender ( renderer, scene, camera, geometry, material ) {

		material.uniforms.offset.value += 0.1;

	}

	function DyeTraces ( survey ) {

		const geometry = new BufferGeometry();

		Mesh.call( this, geometry, new WaterMaterial() );

		this.metadata = survey.metadata;
		this.vertices = [];
		this.ends = [];
		this.selected = [];
		this.stations = [];

		this.onBeforeRender = beforeRender;
		this.layers.set( FEATURE_TRACES );
		this.visible = false;

		const traces = survey.metadata.traces;
		const l = traces.length;
		const surveyTree = survey.surveyTree;

		if ( l > 0 ) {

			let i;

			for ( i = 0; i < l; i++ ) {

				const trace = traces[ i ];

				const startStation = surveyTree.getByPath( trace.start );
				const endStation   = surveyTree.getByPath( trace.end );

				if ( endStation === undefined || startStation === undefined ) continue;

				this._addTrace( startStation, endStation );

			}

			this.finish();

		}

		return this;

	}

	DyeTraces.prototype = Object.create( Mesh.prototype );

	DyeTraces.prototype.finish = function () {

		const geometry = this.geometry;
		const vertices = this.vertices;
		const selected = this.selected;

		if ( vertices.length === 0 ) return;

		const ends = this.ends;

		const traceCount = vertices.length;

		const positions = new Float32BufferAttribute( traceCount * 3, 3 );
		const selection = new Float32BufferAttribute( traceCount * 3, 3 );
		const sinks = new Float32BufferAttribute( traceCount * 3, 3 );

		positions.copyVector3sArray( vertices );
		selection.copyArray( selected );
		sinks.copyVector3sArray( ends );

		if ( ! this.visible ) {

			geometry.setAttribute( 'position', positions );
			geometry.setAttribute( 'selection', selection );
			geometry.setAttribute( 'sinks', sinks );

		} else {

			geometry.getAttribute( 'position' ).copy( positions ).needsUpdate = true;
			geometry.getAttribute( 'selection' ).copy( selection ).needsUpdate = true;
			geometry.getAttribute( 'sinks' ).copy( sinks ).needsUpdate = true;

		}

		this.visible = true;

		// save to browser local storage
		this.metadata.traces = this.serialise();
		this.metadata.saveLocal();

		return this;

	};

	DyeTraces.prototype.getTraceStations = function ( hit ) {

		const stations = this.stations;

		return {
			start: stations[ hit * 2 ].getPath(),
			end: stations [ hit * 2 + 1 ].getPath()
		};

	};

	DyeTraces.prototype.deleteTrace = function ( hit ) {

		// remove from arrays

		this.stations.splice( hit * 2, 2 );

		this.vertices.splice( hit * 3, 3 );
		this.selected.splice( hit * 3, 3 );
		this.ends.splice( hit * 3, 3 );

		// rebuild geometry without deleted trace

		this.finish();

	};

	DyeTraces.prototype._addTrace = function ( startStation, endStation ) {

		const vertices = this.vertices;
		const selected = this.selected;
		const ends = this.ends;

		const end = new Vector3().copy( endStation.p );

		const v = new Vector3().subVectors( endStation.p, startStation.p ).cross( Object3D.DefaultUp ).setLength( 2 );

		const v1 = new Vector3().add( startStation.p ).add( v );
		const v2 = new Vector3().add( startStation.p ).sub( v );

		vertices.push( v1, v2, end );
		ends.push( end, end, end );
		selected.push( 0, 0, 0 );

		this.stations.push( startStation, endStation );

	};

	DyeTraces.prototype.addTrace = function ( startStation, endStation ) {

		this._addTrace( startStation, endStation );
		this.finish();

	};

	DyeTraces.prototype.outlineTrace = function ( hit ) {

		if ( ! this.visible ) return;

		const selection = this.geometry.getAttribute( 'selection' );
		const l = selection.count;

		for( var i = 0; i < l; i++ ) {

			selection.setX( i, 0 );

		}

		if ( hit !== null ) {

			let offset = hit * 3;

			selection.setX( offset++, 1 );
			selection.setX( offset++, 1 );
			selection.setX( offset++, 1 );

		}

		selection.needsUpdate = true;

		return;

	};

	DyeTraces.prototype.serialise = function () {

		const stations = this.stations;
		const traces = [];

		for ( var i = 0, l = stations.length; i < l; i += 2 ) {

			traces.push( {
				start: stations[ i ].getPath(),
				end: stations[ i + 1 ].getPath()
			} );

		}

		return traces;

	};

	function SurveyMetadata( name, metadata ) {

		this.name = name;

		var routes = {};
		var traces = [];
		var entrances = {};
		var annotations = {};

		if ( metadata !== null ) {

			if ( metadata.routes ) routes = metadata.routes;
			if ( metadata.traces ) traces = metadata.traces;
			if ( metadata.entrances ) entrances = metadata.entrances;
			if ( metadata.annotations ) annotations = metadata.annotations;

		}

		var localMetadata = window.localStorage.getItem( name );

		if ( localMetadata !== null ) {

			localMetadata = JSON.parse( localMetadata );

			const localRoutes = localMetadata.routes;

			// add local routes to any routes in metadata (if any)
			var routeName;

			for ( routeName in localRoutes ) {

				const route = localRoutes[ routeName ];
				route.local = true;

				routes[ routeName ] = route;

			}

			if ( localMetadata.traces !== undefined ) traces = localMetadata.traces; // FIXME - merge with preexisting
			if ( localMetadata.entrances !== undefined ) entrances = localMetadata.entrances;
			if ( localMetadata.annotations !== undefined ) annotations = localMetadata.annotations;

		}

		this.routes = routes;
		this.traces = traces;
		this.entrances = entrances;
		this.annotations = annotations;

	}

	SurveyMetadata.annotators = {};

	SurveyMetadata.addAnnotator = function ( annotator ) {

		console.log( annotator );
		SurveyMetadata.annotators[ annotator.name ] = annotator;

	};

	SurveyMetadata.prototype = Object.create( EventDispatcher.prototype );


	SurveyMetadata.prototype.getRoutes = function () {

		return this.routes;

	};

	SurveyMetadata.prototype.saveRoute = function ( routeName, route ) {

		this.routes[ routeName ] = route;

		this.saveLocal();
		this.dispatchEvent( { name: 'change', type: 'routes' } );

	};

	SurveyMetadata.prototype.saveLocal = function () {

		const localMetadata = {
			routes: this.routes,
			traces: this.traces,
			entrances: this.entrances,
			annotations: this.annotations
		};

		window.localStorage.setItem( this.name, JSON.stringify( localMetadata ) );

	};

	SurveyMetadata.prototype.getURL = function () {

		// dump of json top window for cut and paste capture

		return dataURL( {
			name: 'test',
			version: 1.0,
			routes: this.routes,
			traces: this.traces,
			entrances: this.entrances,
			annotations: this.annotations
		} );

	};

	// unpack GLSL created RGBA packed float values

	const unpackDownscale = 255 / ( 256 * 256 );

	const unpackFactor0 = unpackDownscale / ( 256 * 256 * 256 );
	const unpackFactor1 = unpackDownscale / ( 256 * 256 );
	const unpackFactor2 = unpackDownscale / 256;
	const unpackFactor3 = unpackDownscale / 1;

	function unpackRGBA( buffer ) {

		return unpackFactor0 * buffer[ 0 ] +
			unpackFactor1 * buffer[ 1 ] +
			unpackFactor2 * buffer[ 2 ] +
			unpackFactor3 * buffer[ 3 ];

	}

	function TerrainOverlayMaterial ( ctx ) {

		MeshLambertMaterial.call( this );

		this.transparent = true;

		this.onBeforeCompile = function ( shader ) {

			// some uniforms shared by all material instances
			Object.assign( shader.uniforms, ctx.materials.commonTerrainUniforms );

			var vertexShader = shader.vertexShader
				.replace( '#include <common>', '$&\nvarying vec2 vPosition;\n' )
				.replace( 'include <begin_vertex>', '$&\nvPosition = vec2( position.x, position.y );\n' );

			var fragmentShader = shader.fragmentShader
				.replace( '#include <common>', '$&\n' + Shaders.commonTerrainCodePars + '\n' )
				.replace( '#include <color_fragment>', Shaders.commonTerrainCodeColor );

			shader.vertexShader = vertexShader;
			shader.fragmentShader = fragmentShader;

		};

		Object.defineProperty( this, 'opacity', {
			get: function () { return ctx.materials.terrainOpacity; }
		} );

		return this;

	}

	TerrainOverlayMaterial.prototype = Object.create( MeshLambertMaterial.prototype );

	Object.assign( TerrainOverlayMaterial.prototype, CommonTerrainMaterial.prototype );

	function Overlay ( ctx, overlayProvider ) {

		this.provider = overlayProvider;
		this.active = false;
		this.hasCoverage = false;
		this.crsSupported = overlayProvider.crsSupported === undefined ? [ 'EPSG:3857', 'EPSG:4326', 'ORIGINAL' ] : overlayProvider.crsSupported;
		this.throughMode = TERRAIN_BLEND;
		this.ctx = ctx;

		const attribution = overlayProvider.getAttribution();

		if ( attribution ) {

			const c = new Color( ctx.cfg.themeValue( 'background' ) );
			const hsl = { h: 0, s: 0, l: 0 };

			c.getHSL( hsl );

			attribution.classList.add( 'overlay-branding' );
			attribution.style.color = hsl.l < 0.5 ? 'white' : 'black';

			this.attribution = attribution;

		}

		this.materialCache = {};
		this.missing = new Set();

		const coverage = overlayProvider.coverage;

		if ( coverage !== undefined ) {

			this.coverage = new Box2(
				new Vector2( coverage.minX, coverage.minY ),
				new Vector2( coverage.maxX, coverage.maxY )
			);

		}

	}

	Overlay.prototype.getMinZoom = function () {

		return this.provider.minZoom;

	};

	Overlay.prototype.checkCoverage = function ( limits, displayCRS, surveyCRS ) {

		const coverage = this.coverage;

		if ( this.crsSupported.indexOf( displayCRS ) === -1 ) return false;

		// transform survey limits to wgs84 for comparison with overlay limits

		const transform = proj4( ( displayCRS === 'ORIGINAL' ? surveyCRS : displayCRS ), 'WGS84' );
		const wgs84Limits = new Box2();

		wgs84Limits.expandByPoint( transform.forward( { x: limits.min.x, y: limits.min.y } ) );
		wgs84Limits.expandByPoint( transform.forward( { x: limits.min.x, y: limits.max.y } ) );
		wgs84Limits.expandByPoint( transform.forward( { x: limits.max.x, y: limits.min.y } ) );
		wgs84Limits.expandByPoint( transform.forward( { x: limits.max.x, y: limits.max.y } ) );

		this.provider.crs = displayCRS;
		this.hasCoverage = ( coverage === undefined ) ? true : coverage.intersectsBox( wgs84Limits );

		return this.hasCoverage;

	};

	Overlay.prototype.showAttribution = function () {

		const attribution = this.attribution;

		if ( attribution !== undefined ) this.ctx.container.appendChild( attribution );

	};

	Overlay.prototype.hideAttribution = function () {

		const attribution = this.attribution;
		const parent = attribution.parentNode;

		if ( parent !== null ) parent.removeChild( attribution );

	};

	Overlay.prototype.getTile = function ( x, y, z, overlayLoaded ) {

		const self = this;
		const key = x + ':' + y + ':' + z;
		const cfg = this.ctx.cfg;
		const materials = this.ctx.materials;

		const material = this.materialCache[ key ];
		const overlayMaxZoom = this.provider.maxZoom;

		var repeat = 1;
		var xOffset = 0;
		var yOffset = 0;

		if ( material !== undefined ) {

			overlayLoaded( this.active ? material : null );

			return;

		}

		const zoomDelta = z - overlayMaxZoom;

		if ( zoomDelta > 0 ) {

			const scale = Math.pow( 2, zoomDelta );

			repeat = 1 / scale;

			// get image for lower zoom
			const newX = Math.floor( x * repeat );
			const newY = Math.floor( y * repeat );

			xOffset = ( x - newX * scale ) / scale;
			yOffset = 1 - ( y - newY * scale ) / scale;
			yOffset -= repeat;

			x = newX;
			y = newY;
			z = overlayMaxZoom;

		}

		const url = this.provider.getUrl( x, y, z );

		if ( url === null || this.missing.has( url ) ) {

			overlayLoaded( materials.getMissingMaterial() );

			return;

		}

		new TextureLoader().setCrossOrigin( 'anonymous' ).load( url, _textureLoaded, undefined, _textureMissing );

		return;

		function _textureLoaded( texture ) {

			if ( ! self.active ) {

				texture.dispose();

				overlayLoaded( null );
				return;

			}

			const material = new TerrainOverlayMaterial( self.ctx );

			texture.anisotropy = cfg.value( 'anisotropy', 4 );

			texture.repeat.setScalar( repeat );
			texture.offset.set( xOffset, yOffset );

			material.map = texture;
			material.needsUpdate = true;

			self.materialCache[ key ] = material;

			overlayLoaded( material );

		}

		function _textureMissing( /* texture */ ) {

			self.missing.add( url );

			overlayLoaded( self.active ? materials.getMissingMaterial() : null );

		}

	};

	Overlay.prototype.setActive = function () {

		this.showAttribution();
		this.active = true;

	};

	Overlay.prototype.setInactive = function () {

		// flush cache

		const materialCache = this.materialCache;

		for ( var name in materialCache ) {

			const material = materialCache[ name ];

			material.map.dispose();
			material.dispose();

		}

		this.materialCache = {};

		this.hideAttribution();
		this.active = false;

	};

	Overlay.prototype.constructor = Overlay;

	var locationDefaultOverlay = null;

	// preallocated tmp objects

	const __vector3 = new Vector3();
	const __adjust = new Vector3();

	const __result = new Uint8Array( 4 );

	function CommonTerrain ( ctx ) {

		Group.call( this );

		this.hasOverlay = false;
		this.activeOverlay = null;
		this.depthTexture = null;
		this.renderer = null;
		this.renderTarget = null;
		this.datumShift = 0;
		this.activeDatumShift = 0;
		this.terrainBase = null;
		this.terrainRange = null;
		this.isFlat = false;
		this.screenAttribution = null;
		this.terrainShadingModes = {};
		this.throughMode = TERRAIN_STENCIL;
		this.commonUniforms = ctx.materials.commonTerrainUniforms;
		this.ctx = ctx;

		this.addEventListener( 'removed', function removeTerrain() { this.removed(); } );

	}

	CommonTerrain.addOverlay = function ( ctx, name, overlayProvider, locationDefault ) {

		if ( ctx.overlays === undefined ) ctx.overlays = {};

		ctx.overlays[ name ] = new Overlay( ctx, overlayProvider );

		if ( locationDefault ) locationDefaultOverlay = name;

	};

	CommonTerrain.prototype = Object.create( Group.prototype );

	CommonTerrain.prototype.shadingMode = SHADING_RELIEF;

	CommonTerrain.prototype.removed = function () {};

	CommonTerrain.prototype.getOpacity = function () {

		return this.ctx.materials.terrainOpacity;

	};

	CommonTerrain.prototype.setOpacity = function ( opacity ) {

		this.ctx.materials.terrainOpacity = opacity;

	};

	CommonTerrain.prototype.commonRemoved = function () {

		const activeOverlay = this.activeOverlay;

		if ( activeOverlay !== null ) activeOverlay.setInactive();

		if ( this.renderTarget !== null ) this.renderTarget.dispose();

	};

	CommonTerrain.prototype.checkTerrainShadingModes = function ( renderer ) {

		const overlays = this.ctx.overlays;
		const terrainShadingModes = {};

		terrainShadingModes[ 'terrain.shading.height' ] = SHADING_RELIEF;

		if ( renderer.capabilities.isWebGL2 || renderer.extensions.get( 'OES_standard_derivatives' ) !== null && ! this.isFlat ) {

			terrainShadingModes[ 'terrain.shading.contours' + ' (' + this.ctx.cfg.themeValue( 'shading.contours.interval' ) + '\u202fm)' ] = SHADING_CONTOURS;

		}

		if ( this.isTiled ) {

			var name;

			for ( name in overlays ) {

				const overlay = overlays[ name ];

				if ( overlay.checkCoverage( this.limits, this.displayCRS, this.surveyCRS ) ) {

					overlay.active = ( this.activeOverlay === overlay );
					terrainShadingModes[ name ] = name;

				}

			}

		} else if ( this.hasOverlay ) {

			terrainShadingModes[ 'terrain.shading.overlay' ] = SHADING_OVERLAY;

		}

		this.terrainShadingModes = terrainShadingModes;

		return terrainShadingModes;

	};

	CommonTerrain.prototype.setup = function ( renderer, scene, survey ) {

		this.computeBoundingBox();

		survey.addStatic( this );

		const dim = 1024;
		const materials = this.ctx.materials;

		// set camera frustrum to cover region/survey area
		const container = this.ctx.container;

		var width  = container.clientWidth;
		var height = container.clientHeight;

		const range = survey.combinedLimits.getSize( __vector3 );

		const scaleX = width / range.x;
		const scaleY = height / range.y;

		if ( scaleX < scaleY ) {

			height = height * scaleX / scaleY;

		} else {

			width = width * scaleY / scaleX;

		}

		// render the terrain to a new canvas square canvas and extract image data

		const rtCamera = new OrthographicCamera( -width / 2, width / 2, height / 2, -height / 2, -10000, 10000 );

		rtCamera.layers.set( FEATURE_TERRAIN ); // just render the terrain

		const renderTarget = new WebGLRenderTarget( dim, dim, { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat, stencilBuffer: true } );

		renderTarget.texture.generateMipmaps = false;
		renderTarget.texture.name = 'CV.DepthMapTexture';

		renderer.setSize( dim, dim );
		renderer.setPixelRatio( 1 );

		renderer.clear();

		renderer.setRenderTarget( renderTarget );

		scene.overrideMaterial = materials.getDepthMapMaterial( this );

		renderer.render( scene, rtCamera );

		scene.overrideMaterial = null;

		// correct height between entrances and terrain

		this.addHeightMap( renderer, renderTarget );

		this.checkTerrainShadingModes( renderer );

		// restore renderer to normal render size and target

		renderer.renderLists.dispose();

		// restore renderer to normal render size and target

		renderer.setRenderTarget( null );

		renderer.setSize( container.clientWidth, container.clientHeight );
		renderer.setPixelRatio( window.devicePixelRatio );

		survey.setupTerrain( this );
		materials.setTerrain( this );

	};

	CommonTerrain.prototype.setShadingMode = function ( mode, renderCallback ) {

		const activeOverlay = this.activeOverlay;
		const materials = this.ctx.materials;
		const overlays = this.ctx.overlays;

		var material;
		var hideAttribution = true;
		var overlay = null;

		switch ( mode ) {

		case SHADING_RELIEF:

			material = materials.getHypsometricMaterial();

			break;

		case SHADING_OVERLAY:

			this.setOverlay( renderCallback );
			hideAttribution = false;

			break;

		case SHADING_CONTOURS:

			material = materials.getContourMaterial();

			break;

		case SHADING_LOCATION:

			if ( locationDefaultOverlay === null ) {

				material = materials.getHypsometricMaterial();
				mode = SHADING_RELIEF;
				break;

			}

			mode = locationDefaultOverlay; // es-lint( no-fallthrough )

		default:

			overlay = overlays[ mode ];

			if ( overlay !== undefined ) {

				if ( this.isTiled && overlay.hasCoverage ) {

					overlay.throughMode = this.throughMode;

					this.setOverlay( overlay, renderCallback );
					hideAttribution = false;

				} else {

					// if initial setting is not valid, default to shaded relief
					material = materials.getHypsometricMaterial();
					mode = SHADING_RELIEF;

				}

			} else {

				console.warn( 'unknown mode', mode );
				return false;

			}

		}

		if ( hideAttribution && activeOverlay !== null ) {

			activeOverlay.setInactive();

			this.activeOverlay = null;

		}

		if ( material !== undefined ) {

			material.setThroughMode( this.throughMode );
			this.setMaterial( material );

		}

		this.shadingMode = mode;

		return true;

	};

	CommonTerrain.prototype.setThroughMode = function ( mode ) {

		this.throughMode = mode;

	};

	CommonTerrain.prototype.setVisibility = function ( mode ) {

		this.visible = mode;

		if ( mode ) {

			this.showAttribution();

		} else {

			this.hideAttribution();

		}

	};

	CommonTerrain.prototype.showAttribution = function () {

		const attribution = this.screenAttribution;

		if ( attribution !== null ) {

			this.ctx.container.appendChild( attribution );

		}

		if ( this.activeOverlay !== null ) this.activeOverlay.showAttribution();

	};

	CommonTerrain.prototype.hideAttribution = function () {

		const attribution = this.screenAttribution;

		if ( attribution !== null ) {

			const parent = attribution.parentNode;

			if ( parent !== null ) parent.removeChild( attribution );


		}

		if ( this.activeOverlay !== null ) this.activeOverlay.hideAttribution();

	};

	CommonTerrain.prototype.applyDatumShift = function ( mode ) {

		if ( mode && this.activeDatumShift === 0 ) {

			this.translateZ( this.datumShift );
			this.activeDatumShift = this.datumShift;

		} else if ( ! mode && this.activeDatumShift !== 0 ) {

			this.translateZ( - this.datumShift );
			this.activeDatumShift = 0;

		}

		this.updateMatrix();

		this.dispatchEvent( { type: 'datumShiftChange', value: this.activeDatumShift } );

	};

	CommonTerrain.prototype.computeBoundingBox = function () {

		const bb = new Box3();

		this.traverse( _getBoundingBox );

		this.boundingBox = bb;

		function _getBoundingBox( obj ) {

			if ( obj.isTile && obj.isMesh) bb.union( obj.geometry.boundingBox );

		}

		return bb;

	};

	CommonTerrain.prototype.addHeightMap = function ( renderer, renderTarget ) {

		this.depthTexture = renderTarget.texture;
		this.renderer = renderer;
		this.renderTarget = renderTarget;

	};

	CommonTerrain.prototype.getHeight = function ( point ) {

		const renderTarget = this.renderTarget;

		if ( this.terrainBase === null ) {

			if ( this.boundingBox === undefined ) this.computeBoundingBox();

			this.terrainBase = this.boundingBox.min;
			this.terrainRange = this.boundingBox.getSize( new Vector3() );

			// setup value cached

			__adjust.set( renderTarget.width, renderTarget.height, 1 ).divide( this.terrainRange );

		}

		const terrainBase = this.terrainBase;

		__vector3.copy( point ).sub( terrainBase ).multiply( __adjust ).round();

		this.renderer.readRenderTargetPixels( renderTarget, __vector3.x, __vector3.y, 1, 1, __result );

		// convert to survey units and return

		return unpackRGBA( __result ) * this.terrainRange.z + terrainBase.z;

	};

	CommonTerrain.prototype.setScale = function ( scale ) {

		this.commonUniforms.scale.value = scale;

	};

	CommonTerrain.prototype.setAccuracy = function ( accuracy ) {

		this.commonUniforms.accuracy.value = accuracy;
		this.commonUniforms.ringColor.value.g = 1 - ( accuracy / 1000 );

	};

	CommonTerrain.prototype.setTarget = function ( target ) {

		this.commonUniforms.target.value.copy( target );

	};

	CommonTerrain.prototype._fitSurface = function ( modelPoints /* , offsets */ ) {

		const self = this;
		const points = modelPoints;

		var n = 0, s1 = 0, s2 = 0;

		points.forEach( function ( point ) {

			const v = self.getHeight( point );
			s1 += v;
			s2 += v * v;
			n++;

		} );

		const sd = Math.sqrt( s2 / n - Math.pow( s1 / n, 2 ) );

		// simple average
		this.datumShift = s1 / n;

		console.log( 'Adjustmenting terrain height by:', this.datumShift, 'sd:', sd );

	};

	/**
	 * @author Angus Sawyer
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	function LoxTerrainGeometry( dtm, offsets ) {

		BufferGeometry.call( this );

		this.type = 'LoxTerrainGeometry';

		const heightData = dtm.data;

		const lines = dtm.lines;
		const samples = dtm.samples;
		const calib = dtm.calib;

		// buffers

		const indices = [];
		const vertices = [];

		// 2 x 2 scale & rotate callibration matrix

		const xx = calib.xx;
		const xy = calib.xy;
		const yx = calib.yx;
		const yy = calib.yy;

		// offsets from dtm -> survey -> model

		const xOffset = calib.xOrigin - offsets.x;
		const yOffset = calib.yOrigin - offsets.y;
		const zOffset = - offsets.z;

		const lx = samples - 1;
		const ly = lines - 1;

		var ix, iy;

		var minZ = Infinity;
		var maxZ = -Infinity;

		// setup vertices from height data (corrected by rotation matrix)
		// y coordinates inverted in .lox datm data

		for ( iy = 0; iy < lines; iy++ ) {

			const dstOffset = ( lines - 1 - iy ) * samples;

			for ( ix = 0; ix < samples; ix++ ) {

				const x = ix * xx + ( ly - iy ) * xy + xOffset;
				const y = ix * yx + ( ly - iy ) * yy + yOffset;

				const z = heightData[ dstOffset + ix ] + zOffset;

				vertices.push( x, y, z );

				if ( z < minZ ) minZ = z;
				if ( z > maxZ ) maxZ = z;

			}

		}

		const maxX = lx * xx + ly * xy + xOffset;
		const maxY = lx * yx + ly * yy + yOffset;

		this.boundingBox = new Box3( new Vector3( xOffset, yOffset, minZ ), new Vector3( maxX, maxY, maxZ ) );

		// indices

		for ( iy = 0; iy < ly; iy ++ ) {

			for ( ix = 0; ix < lx; ix ++ ) {

				const a = ix + samples * iy;
				const b = ix + samples * ( iy + 1 );
				const c = ( ix + 1 ) + samples * ( iy + 1 );
				const d = ( ix + 1 ) + samples * iy;

				// faces - render each quad such that the shared diagonal edge has the minimum length - gives a smother terrain surface
				// diagonals b - d, a - c

				const d1 = Math.abs( vertices[ a * 3 + 2 ] - vertices[ d * 3 + 2 ] ); // diff in Z values between diagonal vertices
				const d2 = Math.abs( vertices[ b * 3 + 2 ] - vertices[ c * 3 + 2 ] ); // diff in Z values between diagonal vertices

				if ( d1 < d2 ) {

					indices.push( a, b, d );
					indices.push( b, c, d );

				} else {

					indices.push( a, b, c );
					indices.push( c, d, a );

				}

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		// calibration data from terrain and local survey -> model - offsets

		this.computeVertexNormals();

	}

	LoxTerrainGeometry.prototype = Object.create( BufferGeometry.prototype );

	LoxTerrainGeometry.prototype.setupUVs = function ( bitmap, image, offsets ) {

		const calib = bitmap.calib;
		const det = calib.xx * calib.yy - calib.xy * calib.yx;

		if ( det === 0 ) return false;

		// rotation matrix of bitmap over CRS
		const xx =   calib.yy / det;
		const xy = - calib.xy / det;
		const yx = - calib.yx / det;
		const yy =   calib.xx / det;

		const vertices = this.getAttribute( 'position' ).array;

		const width  = image.naturalWidth;
		const height = image.naturalHeight;

		const xOffset = - ( xx * calib.xOrigin + xy * calib.yOrigin );
		const yOffset = - ( yx * calib.xOrigin + yy * calib.yOrigin );

		const uvs = [];

		for ( var i = 0; i < vertices.length; i += 3 ) {

			const x = vertices[ i ]     + offsets.x;
			const y = vertices[ i + 1 ] + offsets.y;

			const u = ( x * xx + y * xy + xOffset ) / width;
			const v = ( x * yx + y * yy + yOffset ) / height;

			uvs.push( u, v );

		}

		const uvAttribute = this.getAttribute( 'uv' );

		if ( uvAttribute !== undefined ) {

			console.alert( 'replacing attribute uv' );

		}

		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	};

	function LoxTile( ctx, terrain, offsets ) {

		Mesh.call( this, new LoxTerrainGeometry( terrain.dtm, offsets ), ctx.materials.getSurfaceMaterial() );

		this.type = 'CV.LoxTile';
		this.layers.set( FEATURE_TERRAIN );
		this.overlayMaterial = null;
		this.ctx = ctx;

		if ( terrain.bitmap === undefined ) {

			this.bitmap = null;

		} else {

			this.bitmap = terrain.bitmap;
			this.offsets = offsets;

		}

	}

	LoxTile.prototype = Object.create( Mesh.prototype );

	LoxTile.prototype.isTile = true;

	LoxTile.prototype.loadOverlay = function ( ctx, overlayLoadedCallback ) {

		if ( this.bitmap === null ) return;

		const texture = new TextureLoader().load( this.bitmap.image, _overlayLoaded );
		const self = this;

		texture.anisotropy = this.ctx.cfg.value( 'anisotropy', 4 );

		return;

		function _overlayLoaded () {

			const bitmap = self.bitmap;

			self.geometry.setupUVs( bitmap, texture.image, self.offsets );

			texture.onUpdate = function ( texture ) {

				// release info

				URL.revokeObjectURL( texture.image.src );
				texture.image = null;

			};

			self.overlayMaterial = new TerrainOverlayMaterial( ctx );

			self.overlayMaterial.map = texture;
			self.overlayMaterial.setThroughMode( self.parent.throughMode );

			bitmap.data = null;
			bitmap.image = null;

			self.material = self.overlayMaterial;

			overlayLoadedCallback();

		}

	};

	LoxTile.prototype.removed = function () {

		const material = this.overlayMaterial;

		if ( material !== null ) {

			material.map.dispose();
			material.dispose();

		}

		this.geometry.dispose();

	};

	function LoxTerrain ( ctx, terrains, offsets ) {

		CommonTerrain.call( this, ctx );

		this.type = 'CV.Terrain';
		this.overlayMaterial = null;
		this.attributions = [];

		const self = this;

		var bitmapCount = 0;

		terrains.forEach( function ( terrain ) {

			const tile = new LoxTile( ctx, terrain, offsets );

			if ( tile.bitmap !== null ) bitmapCount++;

			self.add( tile );

		} );

		this.overlayLoaded = false;
		this.hasOverlay = ( bitmapCount > 0 ) ? true : false;

	}

	LoxTerrain.prototype = Object.create( CommonTerrain.prototype );

	LoxTerrain.prototype.isTiled = false;

	LoxTerrain.prototype.isLoaded = true;

	LoxTerrain.prototype.setOverlay = function ( overlayLoadedCallback ) {

		if ( ! this.hasOverlay ) return;

		const self = this;

		if ( this.overlayLoaded ) {

			this.children.forEach( function ( tile ) {

				if ( tile.overlayMaterial !== null ) {

					tile.material = tile.overlayMaterial;
					tile.material.setThroughMode( self.throughMode );

				}

			} );

			overlayLoadedCallback();

			return;

		}

		this.children.forEach( function ( tile ) { tile.loadOverlay( self.ctx, overlayLoadedCallback ); } );

		this.overlayLoaded = true;

	};

	LoxTerrain.prototype.removed = function () {

		this.children.forEach( function ( tile ) { tile.removed(); } );

		this.commonRemoved();

	};

	LoxTerrain.prototype.setMaterial = function ( material ) {

		this.children.forEach( function ( tile ) { tile.material = material; } );

	};

	LoxTerrain.prototype.fitSurface = CommonTerrain.prototype._fitSurface;

	function Walls ( ctx ) {

		const geometry = new BufferGeometry();

		Mesh.call( this, geometry, ctx.materials.getUnselectedWallMaterial() );

		this.ctx = ctx;

		return this;

	}

	Walls.prototype = Object.create( Mesh.prototype );

	Walls.prototype.ready = true;
	Walls.prototype.type = 'Walls';
	Walls.prototype.flat = false;
	Walls.prototype.flatGeometry = null;
	Walls.prototype.indexedGeometry = null;

	Walls.prototype.addWalls = function ( vertices, indices, indexRuns ) {

		const geometry = this.geometry;
		const positions = new Float32BufferAttribute( vertices.length * 3, 3 );

		geometry.setAttribute( 'position', positions.copyVector3sArray( vertices ) );

		geometry.setIndex( indices );

		geometry.computeVertexNormals();
		geometry.computeBoundingBox();

		this.indexRuns = indexRuns;

		return this;

	};

	Walls.prototype.setShading = function ( idSet, selectedMaterial ) {

		const geometry = this.geometry;
		const indexRuns = this.indexRuns;
		const materials = this.ctx.materials;

		geometry.clearGroups();

		this.visible =  this.ready;

		if ( idSet.length > 0 && indexRuns ) {

			this.material = [ selectedMaterial, materials.getUnselectedWallMaterial() ];

			let indexRun = indexRuns[ 0 ];

			let start = indexRun.start;
			let count = indexRun.count;

			let currentMaterial;
			let lastMaterial = idSet.has( indexRun.survey ) ? 0 : 1;

			// merge adjacent runs with shared material.

			for ( var run = 1, l = indexRuns.length; run < l; run++ ) {

				indexRun = indexRuns[ run ];

				currentMaterial = idSet.has( indexRun.survey ) ? 0 : 1;

				if ( currentMaterial === lastMaterial && indexRun.start === start + count ) {

					count += indexRun.count;

				} else {

					geometry.addGroup( start, count, lastMaterial );

					start = indexRun.start;
					count = indexRun.count;

					lastMaterial = currentMaterial;

				}

			}

			geometry.addGroup( start, count, lastMaterial );

		} else {

			this.material = selectedMaterial;

		}

	};

	Walls.prototype.cutRuns = function ( selection ) {

		const wasFlat = this.flat;

		this.setFlat( false );

		if ( this.flatGeometry ) {

			this.flatGeometry.dispose();
			this.flatGeometry = null;

		}

		const geometry = this.geometry;

		const vertices = geometry.getAttribute( 'position' );
		const indices = geometry.index;

		const idSet = selection.getIds();
		const indexRuns = this.indexRuns;

		const newIndices = [];
		const newVertices = [];

		const newIndexRuns = [];

		// map old vertex index values to new index values
		const vMap = new Map();

		const l = indexRuns.length;

		var run, newVertexIndex = 0, fp = 0;

		for ( run = 0; run < l; run++ ) {

			const indexRun = indexRuns[ run ];
			let i;

			if ( idSet.has( indexRun.survey ) ) {

				const start = indexRun.start;
				const count = indexRun.count;

				const end = start + count;

				const itemSize = vertices.itemSize;
				const oldVertices = vertices.array;

				for ( i = start; i < end; i++ ) {

					const index = indices.getX( i );

					let newIndex = vMap.get( index );

					if ( newIndex === undefined ) {

						const offset = index * itemSize;

						newIndex = newVertexIndex++;

						vMap.set( index, newIndex );

						newVertices.push( oldVertices[ offset ], oldVertices[ offset + 1 ], oldVertices[ offset + 2 ] );

					}

					newIndices.push( newIndex );

				}

				indexRun.start = fp;

				fp += count;

				newIndexRuns.push( indexRun );

			}

		}

		if ( newIndices.length === 0 ) return false;

		// replace position and index attributes - dispose of old attributes
		geometry.index = new indices.constructor( newIndices );
		geometry.setAttribute( 'position', new Float32BufferAttribute( newVertices, 3 ) );

		geometry.computeVertexNormals();
		geometry.computeBoundingBox();

		this.indexRuns = newIndexRuns;

		this.setFlat( wasFlat );

		return true;

	};

	Walls.prototype.setFlat = function ( flat ) {

		if ( flat === this.flat ) return;


		console.log( flat, this.flatGeometry );
		const geometry = this.geometry;
		var flatGeometry = this.flatGeometry;

		if ( flat ) {

			if ( flatGeometry === null ) {

				flatGeometry = geometry.toNonIndexed();

				flatGeometry.computeVertexNormals();
				flatGeometry.computeBoundingBox();

			}

			this.indexedGeometry = geometry;
			this.geometry = flatGeometry;

		} else {

			this.flatGeometry = geometry;
			this.geometry = this.indexedGeometry;

		}

		this.flat = flat;

	};

	function buildScraps ( cave, survey ) {

		const scrapList = cave.scraps;
		const l = scrapList.length;

		if ( l === 0 ) return null;

		const mesh = survey.addFeature( new Walls( survey.ctx ), FACE_SCRAPS, 'Scraps' );

		const indices = [];
		const vertices = [];

		const indexRuns = [];

		var vertexOffset = 0;
		var i, lastEnd = 0;

		for ( i = 0; i < l; i++ ) {

			_loadScrap( scrapList[ i ] );

		}

		mesh.addWalls( vertices, indices, indexRuns );

		survey.addFeature( mesh, FACE_SCRAPS, 'CV.Survey:faces:scraps' );

		return;

		function _loadScrap ( scrap ) {

			var i, l;

			for ( i = 0, l = scrap.vertices.length; i < l; i++ ) {

				vertices.push( scrap.vertices[ i ] );

			}

			for ( i = 0, l = scrap.faces.length; i < l; i++ ) {

				const face = scrap.faces[ i ];

				indices.push( face[ 0 ] + vertexOffset, face[ 2 ] + vertexOffset, face[ 1 ] + vertexOffset );

			}

			const end = indices.length;

			indexRuns.push( { start: lastEnd, count: end - lastEnd, survey: scrap.survey } );
			lastEnd = end;

			vertexOffset += scrap.vertices.length;

		}

	}

	function buildCrossSections ( cave, survey ) {

		const crossSectionGroups = cave.crossSections;

		// handle no LRUD sections
		if ( crossSectionGroups.length === 0 ) return;

		const mesh = survey.addFeature( new Walls( survey.ctx ), FACE_WALLS, 'Walls' );

		const indices = [];
		const vertices = [];

		const l = crossSectionGroups.length;

		// survey to face index mapping
		const indexRuns = [];
		const upAxis = Object3D.DefaultUp;

		var currentSurvey;

		var v = 0;

		var lastEnd = 0;
		var l1, r1, u1, d1, l2, r2, u2, d2;
		var ul1, ur1, dl1, dr1, ul2, ur2, dl2, dr2;
		var i, j;

		const cross = new Vector3();
		const lastCross = new Vector3();
		const nextCross = new Vector3();

		var run = null;

		var vertexCount; // number of vertices per section

		if ( l === 0 ) return;

		for ( i = 0; i < l; i++ ) {

			const crossSectionGroup = crossSectionGroups[ i ];
			const m = crossSectionGroup.length;

			if ( m < 2 ) continue;

			// enter first station vertices
			vertexCount = _getLRUD( crossSectionGroup[ 0 ], crossSectionGroup[ 1 ] );

			for ( j = 1; j < m; j++ ) {

				const xSect = crossSectionGroup[ j ];
				const survey = xSect.survey;

				vertexCount = _getLRUD( xSect, crossSectionGroup[ j + 1 ] );

				if ( survey !== currentSurvey ) {

					currentSurvey = survey;

					if ( run !== null ) {

						_endCap();

						lastEnd = indices.length;

						run.count = lastEnd - run.start;

						indexRuns.push( run );

						run = null;

					}

				}

				// next station vertices

				// triangles to form passage box
				l1 = v++;
				r1 = v++;
				u1 = v++;
				d1 = v++;

				if ( vertexCount === 8 ) {

					ul1 = v++;
					dr1 = v++;
					ur1 = v++;
					dl1 = v++;

				} else {

					ul1 = l1;
					dr1 = r1;
					ur1 = r1;
					dl1 = l1;

				}

				l2 = v++;
				r2 = v++;
				u2 = v++;
				d2 = v++;

				if ( vertexCount === 8 ) {

					ul2 = v++;
					dr2 = v++;
					ur2 = v++;
					dl2 = v++;

				} else {

					ul2 = l1;
					dr2 = r1;
					ur2 = r1;
					dl2 = l1;

				}

				// all face vertices specified in CCW winding order to define front side.

				if ( vertexCount === 4 ) {

					// top faces
					indices.push( u1, r1, r2 );
					indices.push( u1, r2, u2 );
					indices.push( u1, u2, l2 );
					indices.push( u1, l2, l1 );

					// bottom faces
					indices.push( d1, r2, r1 );
					indices.push( d1, d2, r2 );
					indices.push( d1, l2, d2 );
					indices.push( d1, l1, l2 );

				} else {

					// top faces - top half
					indices.push( u1, ur1, ur2 );
					indices.push( u1, ur2, u2 );
					indices.push( u1, u2,  ul2 );
					indices.push( u1, ul2, ul1 );

					// top faces - bottom half
					indices.push( ur1, r1, r2 );
					indices.push( ur1, r2, ur2 );
					indices.push( ul1, ul2, l2 );
					indices.push( ul1, l2, l1 );

					// bottom faces - top half
					indices.push( dr1, r2,  r1 );
					indices.push( dr1, dr2, r2 );
					indices.push( dl1, l2, dl2 );
					indices.push( dl1, l1, l2 );

					// bottom faces - bottom half
					indices.push( d1, dr2, dr1 );
					indices.push( d1, d2,  dr2 );
					indices.push( d1, dl2, d2 );
					indices.push( d1, dl1, dl2 );

				}

				v = v - vertexCount; // rewind to allow current vertices to be start of next box section.

				if ( run === null ) {

					// handle first section of run

					run = { start: lastEnd, survey: survey };

					// start tube with two triangles to form cap
					indices.push( u1, d1, r1 );
					indices.push( u1, l1, d1 );

					if ( vertexCount === 8 ) {

						indices.push( u1, ul1, l1 );
						indices.push( u1, r1, ur1 );
						indices.push( d1, l1, dl1 );
						indices.push( d1, dr1, r1 );

					}

				}

			}

			currentSurvey = null;
			v = v + vertexCount; // advance because we are starting a new set of independant x-sections.

		}

		if ( run !== null ) {

			_endCap();

			run.count = indices.length - run.start;

			indexRuns.push( run );

		}

		if ( indices.length === 0 ) return;

		mesh.addWalls( vertices, indices, indexRuns );

		survey.addFeature( mesh, FACE_WALLS, 'CV.Survey:faces:walls' );

		return;

		function _endCap() {

			// close tube with two triangles
			indices.push( u2, r2, d2 );
			indices.push( u2, d2, l2 );

			if ( vertexCount === 8 ) {

				indices.push( u2, l2, ul2 );
				indices.push( u2, ur2, r2 );
				indices.push( d2, dl2, l2 );
				indices.push( d2, r2, dr2 );

			}

		}

		function _getLRUD ( crossSection, nextSection ) {

			const ovalFactor = 0.293;
			const station = crossSection.end;
			const lrud    = crossSection.lrud;

			var vertexCount;

			// cross product of leg + next leg vector and up AXIS to give direction of LR vector
			cross.subVectors( crossSection.start, crossSection.end ).normalize();

			const vertical = ( Math.abs( cross.dot( upAxis ) ) > 0.97 );

			if ( nextSection ) {

				nextCross.subVectors( nextSection.start, nextSection.end ).normalize();
				cross.add( nextCross );

			}

			cross.cross( upAxis );

			var L, R, U, D, UL, UR, DL, DR;

			if ( vertical && ( lrud.u + lrud.d < 5 ) ) {

				cross.copy( lastCross );
				const t = cross.clone().cross( upAxis );

				U = t.clone().setLength( -lrud.u ).add( station );
				D = t.clone().setLength( lrud.d ).add( station );

			} else {

				U = new Vector3( station.x, station.y, station.z + lrud.u );
				D = new Vector3( station.x, station.y, station.z - lrud.d );

			}

			L = cross.clone().setLength(  lrud.l ).add( station );
			R = cross.clone().setLength( -lrud.r ).add( station );

			lastCross.copy( cross );

			switch ( crossSection.type ) {

			case WALL_DIAMOND:

				vertices.push( L, R, U, D );

				vertexCount = 4; // number of vertices for this profile
				break;

			case WALL_SQUARE:

				UL = L.clone().setZ( U.z );
				UR = R.clone().setZ( U.z );
				DL = L.clone().setZ( D.z );
				DR = R.clone().setZ( D.z );

				vertices.push( UL, DR, UR, DL );

				vertexCount = 4; // number of vertices for this profile
				break;

			case WALL_OVAL:

				vertices.push( L, R, U, D );

				UL = L.clone().setZ( U.z ).lerp( station, ovalFactor );
				UR = R.clone().setZ( U.z ).lerp( station, ovalFactor );
				DL = L.clone().setZ( D.z ).lerp( station, ovalFactor );
				DR = R.clone().setZ( D.z ).lerp( station, ovalFactor );

				vertices.push( UL, DR, UR, DL );

				vertexCount = 8; // number of vertices for this profile
				break;

			default:

				console.error( 'unsupported lrud shape', crossSection.type );

			}

			return vertexCount;

		}

	}

	function buildWallsSync ( cave, survey ) {

		buildScraps( cave, survey );
		buildCrossSections( cave, survey );

	}

	function SurveyColourMapper ( ctx ) {

		var map = [];
		var selectedSection = 0;

		this.getColour = function ( surveyId ) {

			const surveyColours = ctx.materials.colourCache.getColors( 'survey' );

			return surveyColours[ surveyId % surveyColours.length ];

		};

		this.getColourMap = function ( newSelectedSection ) {

			if ( selectedSection === newSelectedSection && map.length > 0 ) {

				// use cached mapping
				return map;

			}

			map = [];
			selectedSection = newSelectedSection;

			// create mapping of survey id to colour
			// map each child id _and_ all its lower level survey ids to the same colour

			var subTree = selectedSection;

			var colour = this.getColour( selectedSection.id );

			_addMapping( subTree );

			var children = subTree.children;

			while ( children.length === 1 ) {

				subTree = children[ 0 ];
				_addMapping( subTree );
				children = subTree.children;

			}

			for ( var i = 0, l = children.length; i < l; i++ ) {

				const node = children[ i ];

				colour = this.getColour( node.id );

				node.traverse( _addMapping );

			}

			return map;

			function _addMapping ( node ) {

				// only add values for sections - not stations
				if ( ! node.isStation() ) map[ node.id ] = colour;

			}

		};

	}

	function SurveyBox( ctx, box3, color ) {

		this.box3 = box3;

		if ( color === undefined ) color = 0xffff00;

		const v0 = new Vector3(  0.5,  0.5,  0.5 );
		const v1 = new Vector3( -0.5,  0.5,  0.5 );
		const v2 = new Vector3( -0.5, -0.5,  0.5 );
		const v3 = new Vector3(  0.5, -0.5,  0.5 );
		const v4 = new Vector3(  0.5,  0.5, -0.5 );
		const v5 = new Vector3( -0.5,  0.5, -0.5 );
		const v6 = new Vector3( -0.5, -0.5, -0.5 );
		const v7 = new Vector3(  0.5, -0.5, -0.5 );

		const vertices = [
			v0, v1,
			v1, v2,
			v2, v3,
			v3, v0,
			v4, v5,
			v5, v6,
			v6, v7,
			v7, v4,
			v0, v4,
			v1, v5,
			v2, v6,
			v3, v7
		];

		const positions = new Float32BufferAttribute( vertices.length * 3, 3 );
		const geometry = new LineSegmentsGeometry();

		positions.copyVector3sArray( vertices );
		geometry.setPositions( positions.array );

		LineSegments2.call( this, geometry, ctx.materials.getLine2Material( 'basic' ) );

		this.material.vertexColors = false;
		this.material.color = new Color( color );

		if ( box3 ) this.update( box3 );

	}

	SurveyBox.prototype.type = 'SurveyBox';

	SurveyBox.prototype = Object.create( LineSegments2.prototype );

	SurveyBox.prototype.update = function ( box3 ) {

		box3.getSize( this.scale );
		box3.getCenter( this.position );
		this.updateMatrix();

		this.box3 = box3;
		this.geometry.computeBoundingSphere();

	};

	SurveyBox.prototype.removed = function () {

		if ( this.geometry ) this.geometry.dispose();

	};

	function Selection( ctx, color ) {

		const survey = ctx.survey;
		const worldBoundingBox = new Box3();
		var root = survey.surveyTree;
		var selectedNode = root;

		SurveyBox.call( this, ctx, root.boundingBox, color );

		const material = this.material;

		material.stencilWrite = true;
		material.stencilZPass = IncrementStencilOp;

		this.layers.set( FEATURE_SELECTED_BOX );

		survey.addStatic( this );

		const selectedSectionIds = new Set();

		this.setRoot = function ( rootNode ) {

			root = rootNode;

		};

		this.set = function ( node ) {

			selectedNode = node;
			selectedSectionIds.clear();

			if ( selectedNode === root ) {

				this.visible = false;

			} else {

				node.getSubtreeIds( selectedSectionIds );
				this.visible = true;

				if ( ! node.isStation() && node.boundingBox !== undefined ) {

					this.update( node.boundingBox );

				}

			}

		};

		this.getIds = function () {

			return selectedSectionIds;

		};

		this.isEmpty = function () {

			return ( selectedNode === root );

		};

		this.contains = function ( id ) {

			return ( selectedNode === root || selectedSectionIds.has( id ) );

		};

		this.getWorldBoundingBox = function () {

			if ( this.isEmpty() ) {

				return survey.getWorldBoundingBox();

			} else {

				return worldBoundingBox.copy( selectedNode.boundingBox ).applyMatrix4( survey.matrixWorld );

			}

		};

		this.getName = function () {

			return this.isEmpty() ? '' : selectedNode.getPath();

		};

		this.getNode = function () {

			return selectedNode;

		};

		this.isStation = function () {

			return selectedNode.isStation();

		};

	}

	Selection.prototype = Object.create( SurveyBox.prototype );

	const __set = new Set();

	function Survey ( ctx, cave ) {

		Object3D.call( this );

		this.highlightBox = null;
		this.highlightPath = null;
		this.lastMarkedStation = null;
		this.markers = new StationMarkers( ctx, 0x00ff00 );
		this.featureBox = null;
		this.surveyTree = null;
		this.projection = null;
		this.projectionWGS84 = null;
		this.worldBoundingBox = null;
		this.caveShading = SHADING_HEIGHT;
		this.surfaceShading = SHADING_SINGLE;
		this.wallsMode = false;
		this.ctx = ctx;

		// objects targeted by raycasters and objects with variable LOD

		this.pointTargets = [];
		this.legTargets = [];
		this.entranceTargets = [];

		this.type = 'CV.Survey';
		this.cutInProgress = false;
		this.features = new Map();
		this.routes = null;
		this.stations = null;
		this.terrain = null;
		this.topology = null;
		this.annotations = null;
		this.inverseWorld = new Matrix4();

		this.lightDirection = new Vector3( -1, -1, 2 ).normalize();

		const self = this;

		this.gradientName = ctx.cfg.value( 'saturatedGradient', false ) ? 'gradientHi' : 'gradientLow';

		ctx.surveyColourMapper = new SurveyColourMapper( ctx );
		ctx.survey = this;

		var survey = cave.getSurvey();

		this.name = survey.title;
		this.CRS = survey.sourceCRS;
		this.displayCRS = survey.displayCRS;

		this.limits = survey.limits;
		this.offsets = survey.offsets;
		this.messages = cave.messages;

		const modelLimits = new Box3().copy( this.limits );

		modelLimits.min.sub( this.offsets );
		modelLimits.max.sub( this.offsets );

		this.modelLimits = modelLimits;
		this.combinedLimits = modelLimits;

		// this needs to be defined before loading the leg data to
		// allow correct leg lengths to be calculated

		_setProjectionScale();

		this.loadCave( survey );

		this.loadWarnings();

		this.legTargets = [ this.features.get( LEG_CAVE ) ];

		this.loadEntrances();

		this.setFeatureBox();

		this.addStatic( this.markers );

		this.addEventListener( 'removed', this.onRemoved );

		var zScale = 0.5;

		survey = null;

		Object.defineProperty( this, 'zScale', {
			get: function () { return zScale; },
			set: function ( scale ) {

				// scale - in range 0 - 1

				const lastScale = Math.pow( 2, ( zScale - 0.5 ) * 4 );
				const newScale  = Math.pow( 2, ( scale - 0.5 ) * 4 );

				self.applyMatrix4( new Matrix4().makeScale( 1, 1, newScale / lastScale ) );
				self.updateMatrix();

				zScale = scale;

			}
		} );

		return;

		function _setProjectionScale () {

			// calculate scaling distortion if we have required CRS definitions
			const displayCRS = survey.displayCRS;

			if ( survey.sourceCRS === null || displayCRS === null || displayCRS === 'ORIGINAL' ) {

				self.scaleFactor = 1;

				if ( survey.sourceCRS !== null ) {

					self.projectionWGS84 = proj4( 'WGS84', survey.sourceCRS );

				}

				return;

			}

			const limits = self.limits;

			const p1 = limits.min.clone();
			const p2 = limits.max.clone();

			p1.z = 0;
			p2.z = 0;

			const l1 = p1.distanceTo( p2 );

			const transform = proj4( displayCRS, survey.sourceCRS );

			p1.copy( transform.forward( p1 ) );
			p2.copy( transform.forward( p2 ) );

			self.projection = transform;

			const l2 = p1.distanceTo( p2 );

			self.scaleFactor = l1 / l2;
			StationPosition.scaleFactor = 1 / self.scaleFactor;

			self.projectionWGS84 = proj4( 'WGS84', survey.displayCRS );

		}

	}

	Survey.prototype = Object.create( Object3D.prototype );

	Survey.prototype.onRemoved = function ( /* event */ ) {

		if ( this.cutInProgress ) {

			// avoid disposal phase when a cut operation is taking place.
			// this survey is being redisplayed.

			this.cutInProgress = false;

			return;

		}

		this.traverse( _dispose );

		while ( this.children.length > 0 ) { this.remove( this.children[ 0 ] ); }

		return;

		function _dispose ( object ) { if ( object.geometry ) object.geometry.dispose(); }

	};

	Survey.prototype.loadWarnings = function () {

		const surveyTree = this.surveyTree;
		const messages = this.messages;
		const selection = this.selection;

		if ( messages.length > 0 ) {

			const errorMarkers = new StationMarkers( this.ctx, 0xff00ff );

			messages.forEach( function ( message ) {

				const node = surveyTree.getByPath( message.station );

				if ( node !== undefined && selection.contains( node.id ) ) {

					errorMarkers.mark( node );
					node.messageText = message.text;

				}

			} );

			this.addFeature( errorMarkers, SURVEY_WARNINGS, 'CV.Survey:warnings' );

		}

	};

	Survey.prototype.refreshColors = function () {

		if ( this.hasFeature( FEATURE_ENTRANCES ) ) {

			const fe = this.getFeature( FEATURE_ENTRANCES );

			this.removeFeature( fe );
			this.remove( fe );
			this.entrances = null;

		}

		this.loadEntrances();

		if ( this.featureBox ) {

			const fb = this.getFeature( FEATURE_BOX );

			this.removeFeature( fb );
			this.remove( fb );
			this.featureBox = null;

		}

		this.setFeatureBox();

		this.setShadingMode( this.caveShading );
		this.setSurfaceShading( this.surfaceShading );

	};

	Survey.prototype.loadEntrances = function () {

		const entrances = new Entrances( this.ctx, this );

		this.addFeature( entrances, FEATURE_ENTRANCES, 'CV.Survey:entrances' );

		this.entranceTargets = [ entrances.markers ];
		this.entrances = entrances;

	};

	Survey.prototype.setupTerrain = function ( terrain ) {

		if ( terrain.isFlat ) return;

		// expand limits with terrain
		this.combinedLimits = new Box3().copy( terrain.boundingBox ).union( this.modelLimits );

		this.setFeatureBox();

		// find height difference between all entrance locations and terrain
		// find average differences and use to alter height of terrain

		const points = [];

		this.surveyTree.traverse( _getSurfacePoints );

		terrain.fitSurface( points, this.offsets );

		if ( this.terrain === null ) this.terrain = terrain;

		// if we have a terrain we can make sure cluster markers can adjust to avoid terrain

		const markers = this.getFeature( FEATURE_ENTRANCES );

		if ( markers !== undefined ) {

			markers.addHeightProvider( terrain.getHeight.bind( terrain ) );

		}

		return;

		function _getSurfacePoints( node ) {

			// FIXME to extend to surface points
			if ( node.type !== STATION_ENTRANCE) return;
			points.push( node.p );

		}

	};

	Survey.prototype.loadCave = function ( cave ) {

		const self = this;
		const ctx = this.ctx;

		const surveyTree = cave.surveyTree;

		this.surveyTree = surveyTree;

		this.selection = new Selection( ctx, this.ctx.cfg.themeValue( 'box.select' ) );

		_loadSegments( cave.lineSegments );

		this.loadStations( surveyTree );

		_loadTerrain( cave );

		this.computeBoundingBoxes( surveyTree );

		this.pointTargets.push( this.stations );

		const metadata = new SurveyMetadata( this.name, cave.metadata );

		this.metadata = metadata;

		this.loadDyeTraces();

		this.topology = new Topology( this.stations, this.getFeature( LEG_CAVE ) );

		this.routes = new Routes( this );

		buildWallsSync( cave, this );

		return;

		function _loadSegments ( srcSegments ) {

			const l = srcSegments.length;
			const typeLegs = [];

			typeLegs[ LEG_CAVE    ] = { vertices: [], runs: [] };
			typeLegs[ LEG_SURFACE ] = { vertices: [], runs: [] };
			typeLegs[ LEG_SPLAY   ] = { vertices: [], runs: [] };

			var legs, run, i;
			var currentType;
			var currentSurvey;

			if ( l === 0 ) return null;

			for ( i = 0; i < l; i++ ) {

				const leg = srcSegments[ i ];

				const type   = leg.type;
				const survey = leg.survey;

				legs = typeLegs[ type ];

				if ( leg === undefined ) {

					console.warn( 'unknown segment type: ', type );
					break;

				}

				if ( survey !== currentSurvey || type !== currentType ) {

					// complete last run data

					if ( run !== undefined ) {

						const lastLegs = typeLegs[ currentType ];

						run.end = lastLegs.vertices.length;
						lastLegs.runs.push( run );

					}

					// start new run

					run = {};

					run.survey = survey;
					run.start  = legs.vertices.length;

					currentSurvey = survey;
					currentType   = type;

				}

				legs.vertices.push( leg.from );
				legs.vertices.push( leg.to );

			}

			// add vertices run for last survey section encountered

			if ( run.end === undefined ) {

				run.end = legs.vertices.length;
				legs.runs.push( run );

			}

			_addModelSegments( LEG_CAVE, 'CV.Survey:cave:cave' );
			_addModelSegments( LEG_SURFACE, 'CV.Survey:surface:surface' );
			_addModelSegments( LEG_SPLAY, 'CV.Survey:cave:splay' );

			return;

			function _addModelSegments ( tag, name ) {

				const legs = typeLegs[ tag ];

				if ( legs.vertices.length === 0 ) return;

				// old code to allow combined surveys
				// const legObject = self.getFeature( tag, Legs );
				const legObject = new Legs( self.ctx );

				legObject.addLegs( legs.vertices, legs.runs );

				self.addFeature( legObject, tag, name + ':g' );

			}

		}

		function _loadTerrain ( cave ) {

			if ( cave.hasTerrain === false ) return;

			const terrain = new LoxTerrain( ctx, cave.terrains, self.offsets );


			self.terrain = terrain;

			return;

		}

	};

	Survey.prototype.getFeature = function ( tag, obj ) {

		var o = this.features.get( tag );

		if ( o === undefined && obj ) {

			o = new obj ();
			o.layers.set( tag );

		}

		return o;

	};

	Survey.prototype.update = function ( cameraManager, target, showClusterMarkers ) {

		const camera = cameraManager.activeCamera;

		const entrances = this.features.get( FEATURE_ENTRANCES );

		if ( entrances && cameraManager.testCameraLayer( FEATURE_ENTRANCES ) ) {

			cameraManager.setCameraLayer( CLUSTER_MARKERS, showClusterMarkers );
			entrances.cluster( camera, target, this.selection, showClusterMarkers );

		} else {

			cameraManager.setCameraLayer( CLUSTER_MARKERS, false );

		}

		const stationLabels = this.features.get( LABEL_STATION );

		if ( ( stationLabels && cameraManager.testCameraLayer( LABEL_STATION ) ) ||
			stationLabels.commentCount > 0 && cameraManager.testCameraLayer( LABEL_STATION_COMMENT ) ) {

			stationLabels.update( camera, target, this.inverseWorld );

		}

	};

	Survey.prototype.addFeature = function ( obj, tag, name ) {

		obj.name = name;
		obj.layers.set( tag );

		this.features.set( tag, obj );

		this.addStatic( obj );

		return obj;

	};

	Survey.prototype.removeFeature = function ( obj ) {

		this.layers.mask &= ~ obj.layers.mask;

		const features = this.features;

		features.forEach( function ( value, key ) {

			if ( value === obj ) features.delete( key );

		} );

	};

	Survey.prototype.hasFeature = function ( tag ) {

		return this.features.has( tag );

	};

	Survey.prototype.loadStations = function ( surveyTree ) {

		const stations = new Stations( this.ctx, this.selection );

		var commentCount = 0;

		surveyTree.traverse( _addStation );

		// we have finished adding stations.
		stations.finalise();

		const stationLabels = new StationLabels( this.ctx, stations, commentCount );

		this.addFeature( stations, FEATURE_STATIONS, 'CV.Stations' );
		this.addFeature( stationLabels, LABEL_STATION, 'CV.StationLabels' );

		if ( commentCount > 0 ) {

			this.features.set( LABEL_STATION_COMMENT, stationLabels );
			stationLabels.layers.enable( LABEL_STATION_COMMENT );

		}

		this.stations = stations;

		return;

		function _addStation ( node ) {

			if ( node.comment !== undefined ) commentCount++;
			if ( ! node.isStation() ) return;

			stations.addStation( node );

		}

	};

	Survey.prototype.computeBoundingBoxes = function ( surveyTree ) {

		surveyTree.traverseDepthFirst( _computeBoundingBox );

		return;

		function _computeBoundingBox ( node ) {

			const parent = node.parent;

			if ( parent && parent.boundingBox === undefined ) parent.boundingBox = new Box3();

			if ( node.isStation() ) {

				parent.boundingBox.expandByPoint( node.p );

			} else if ( parent ) {

				if ( node.children.length === 0 || ( node.boundingBox !== undefined && node.boundingBox.isEmpty() ) ) return;

				parent.boundingBox.expandByPoint( node.boundingBox.min );
				parent.boundingBox.expandByPoint( node.boundingBox.max );

			}

		}

	};

	Survey.prototype.loadDyeTraces = function () {

		const dyeTraces = new DyeTraces( this );

		this.addFeature( dyeTraces, FEATURE_TRACES, 'CV.DyeTraces' );

		this.dyeTraces = dyeTraces;

	};

	Survey.prototype.setScale = function ( hScale, vScale ) {

		this.scale.set( hScale, hScale, vScale );

		this.position.copy( this.combinedLimits.getCenter( new Vector3() ).multiply( this.scale ).negate() );

		this.updateMatrix();
		this.updateMatrixWorld();
		this.inverseWorld.copy( this.matrixWorld ).invert();

	};

	Survey.prototype.getLegs = function () {

		return this.getFeature( LEG_CAVE ).geometry.vertices;

	};

	Survey.prototype.getRoutes = function () {

		return this.routes;

	};

	Survey.prototype.getWorldPosition = function ( position ) {

		return position.applyMatrix4( this.matrixWorld );

	};

	Survey.prototype.getGeographicalPosition = function ( position ) {

		const offsets = this.offsets;
		const projection = this.projection;

		var originalPosition = { x: position.x + offsets.x, y: position.y + offsets.y, z: 0 };

		// convert to original survey CRS

		if ( projection !== null ) originalPosition = projection.forward( originalPosition );

		originalPosition.z = position.z + offsets.z;

		return originalPosition;

	};

	Survey.prototype.containsWGS84Position = function ( position ) {

		position.copy( this.projectionWGS84.forward( position ) );

		const min = this.limits.min;
		const max = this.limits.max;

		return ( position.x >= min.x && position.x <= max.x && position.y >= min.y && position.y <= max.y );

	};

	Survey.prototype.getModelSurfaceFromWGS84 = function ( position, callback ) {

		const self = this;

		position.copy( this.projectionWGS84.forward( position ) );

		this.terrain.getHeights( [ position ], _handleResult );

		return;

		function _handleResult ( points ) {

			position.z = points[ 0 ].z;
			position.sub( self.offsets );

			callback();

		}

	};

	Survey.prototype.shortestPathSearch = function ( station ) {

		this.highlightPath = null;

		this.markers.clear();

		this.topology.shortestPathSearch( station );

		this.markers.mark( station );

		this.setShadingMode( SHADING_DISTANCE );

	};

	Survey.prototype.showShortestPath = function ( station ) {

		this.highlightPath = this.topology.getShortestPath( station );

		if ( this.lastMarkedStation !== null ) this.markers.unmark( this.lastMarkedStation );

		this.markers.mark( station );

		this.lastMarkedStation = station;

		this.setLegShading( LEG_CAVE, SHADING_DISTANCE );

	};

	Survey.prototype.getMaxDistance = function () {

		return this.topology.maxDistance;

	};

	Survey.prototype.selectStation = function ( station ) {

		this.stations.selectStation( station );

	};

	Survey.prototype.highlightSelection = function ( node ) {

		if ( node.isStation() ) {

			this.stations.highlightStation( node );

		} else {

			let box = this.highlightBox;

			if ( box === null ) {

				box = new Selection( this.ctx,  this.ctx.cfg.themeValue( 'box.highlight' ) );
				this.highlightBox = box;

			}

			box.set( node );
			this.stations.clearHighlight();

			if ( node === this.surveyTree ) {

				this.entrances.setSelection( this.selection );

			} else {

				this.entrances.setSelection( box );

			}

		}

	};

	Survey.prototype.selectSection = function ( node ) {

		const selection = this.selection;

		this.highlightSelection( this.surveyTree );

		selection.set( node );

		this.stations.selectStations( selection );
		this.entrances.setSelection( selection );
		this.setShadingMode( this.caveShading );

		return node;

	};

	Survey.prototype.setFeatureBox = function () {

		if ( this.featureBox === null ) {

			const box = new SurveyBox( this.ctx, this.combinedLimits, this.ctx.cfg.themeColorCSS( 'box.bounding' ) );

			this.addFeature( box, FEATURE_BOX, 'survey-boundingbox' );
			this.featureBox = box;

		} else {

			this.featureBox.update( this.combinedLimits );

		}

	};

	Survey.prototype.getWorldBoundingBox = function () {

		if ( this.worldBoundingBox === null ) {

			this.worldBoundingBox = this.featureBox.box3.clone().applyMatrix4( this.matrixWorld );

		}

		return this.worldBoundingBox;

	};

	Survey.prototype.cutSection = function ( node ) {

		const selection = this.selection;
		const self = this;

		selection.set( node );

		if ( selection.isEmpty() ) return;

		// clear target lists

		this.pointTargets = [];
		this.legTargets   = [];
		this.entranceTargets = [];

		this.terrain = null;

		// iterate through objects replace geometries and remove bounding boxes;

		const cutList = []; // list of Object3D's to remove from survey - workaround for lack of traverseReverse

		this.traverse( _cutObject );

		cutList.forEach( function ( obj ) {

			const parent = obj.parent;

			if ( parent ) parent.remove( obj );

			// dispose of all geometry of this object and descendants

			if ( obj.geometry ) obj.geometry.dispose();

			self.removeFeature( obj );

		} );

		this.surveyTree = node;
		this.selection.setRoot( node );

		if ( this.highlightBox ) this.highlightBox.setRoot( node );

		this.loadStations( node );

		this.pointTargets.push( this.stations );

		// ordering is important here

		this.selectSection( node );

		this.modelLimits = this.getBounds();
		this.combinedLimits = this.modelLimits;

		this.limits.copy( this.modelLimits );

		this.limits.min.add( this.offsets );
		this.limits.max.add( this.offsets );

		this.setFeatureBox();

		this.worldBoundingBox = null;

		this.loadEntrances();

		// this.loadWarnings();
		// this.loadDyeTraces();

		this.topology = new Topology( this.stations, this.getFeature( LEG_CAVE ) );

		this.cutInProgress = true;

		return;

		function _cutObject ( obj ) {

			switch ( obj.type ) {

			case 'Legs':
			case 'Walls':

				if ( ! obj.cutRuns( selection ) ) cutList.push( obj );

				break;

			case 'SurveyBox':
			case 'CV.Stations':
			case 'CV.StationLabels':
			case 'CV.ClusterMarker':

				cutList.push( obj );

				break;

			}

		}

	};

	Survey.prototype.getBounds = function () {

		const box = new Box3();

		const min = box.min;
		const max = box.max;

		this.traverse( _addObjectBounds );

		return box;

		function _addObjectBounds ( obj ) {

			if ( obj.type === 'CV.Survey' || obj.type === 'CV.Box3' ) return;
			// skip survey which is positioned/scaled into world space

			const geometry = obj.geometry;

			if ( geometry && geometry.boundingBox ) {

				min.min( geometry.boundingBox.min );
				max.max( geometry.boundingBox.max );

			}

		}

	};

	Survey.prototype.setWallsMode = function ( mode ) {

		this.getFeature( FACE_WALLS ).setFlat( mode );
		// this.getFeature( FACE_SCRAPS ).setFlat( mode ); // FIXME
		this.wallsMode = mode;

	};

	Survey.prototype.setShadingMode = function ( mode ) {

		const materials = this.ctx.materials;

		var material;

		switch ( mode ) {

		case SHADING_HEIGHT:

			material = materials.getHeightMaterial( MATERIAL_SURFACE );

			break;

		case SHADING_CURSOR:

			material = materials.getCursorMaterial( MATERIAL_SURFACE );

			break;

		case SHADING_SINGLE:

			material = materials.getSurfaceMaterial();

			break;

		case SHADING_DEPTH:

			if ( this.terrain === null ) return false;

			material = materials.getDepthMaterial( MATERIAL_SURFACE );

			if ( ! material ) return false;

			break;

		case SHADING_DEPTH_CURSOR:

			if ( this.terrain === null ) return false;

			material = materials.getDepthCursorMaterial( MATERIAL_SURFACE );

			if ( ! material ) return false;

			break;

		case SHADING_DISTANCE:
		case SHADING_SURVEY:

			material = false;

			break;

		}

		this.markers.setVisibility( ( mode === SHADING_DISTANCE ) );

		if ( this.setLegShading( LEG_CAVE, mode ) ) {

			this.setWallShading( this.features.get( FACE_WALLS  ), material );
			this.setWallShading( this.features.get( FACE_SCRAPS ), material );

			this.caveShading = mode;

		}

		return this.caveShading;

	};

	Survey.prototype.setWallShading = function ( mesh, selectedMaterial ) {

		if ( ! mesh ) return;

		if ( selectedMaterial ) {

			mesh.setShading( this.selection, selectedMaterial );

		} else {

			mesh.visible = false;

		}

	};

	Survey.prototype.setSurfaceShading = function ( mode ) {

		if ( this.setLegShading( LEG_SURFACE, mode ) ) {

			this.surfaceShading = mode;

		}

		return this.surfaceShading;

	};

	Survey.prototype.setLegShading = function ( legType, legShadingMode ) {

		const mesh = this.features.get( legType );

		if ( mesh === undefined ) return false;

		switch ( legShadingMode ) {

		case SHADING_HEIGHT:

			this.setLegColourByMaterial( mesh, 'height' );

			break;

		case SHADING_LENGTH:

			this.setLegColourByLength( mesh );

			break;

		case SHADING_INCLINATION:

			this.setLegColourByInclination( mesh, Object3D.DefaultUp );

			break;

		case SHADING_CURSOR:

			this.setLegColourByMaterial( mesh, 'cursor' );

			break;

		case SHADING_DEPTH_CURSOR:

			this.setLegColourByMaterial( mesh, 'depth-cursor' );

			break;

		case SHADING_SINGLE:

			this.setLegColourByColour( mesh, this.ctx.cfg.themeColor( 'shading.single' ) );

			break;

		case SHADING_SURFACE:

			this.setLegColourByColour( mesh, this.ctx.cfg.themeColor( 'shading.surface' ) );

			break;

		case SHADING_SURVEY:

			this.setLegColourBySurvey( mesh );

			break;

		case SHADING_PATH:

			this.setLegColourByPath( mesh );

			break;

		case SHADING_OVERLAY:

			break;

		case SHADING_SHADED:

			break;

		case SHADING_DEPTH:

			this.setLegColourByMaterial( mesh, 'depth' );

			break;

		case SHADING_DISTANCE:

			if ( this.topology.maxDistance === 0 ) {

				this.setLegColourByColour( mesh, this.ctx.cfg.themeColor( 'shading.unconnected' ) );

			} else {

				this.setLegColourByDistance( mesh );

			}

			break;

		default:

			console.warn( 'invalid leg shading mode' );

			return false;

		}

		return true;

	};

	Survey.prototype.setLegColourByMaterial = function ( mesh, mode) {

		const colourCache = this.ctx.materials.colourCache;

		mesh.setShading( this.selection.getIds(), _colourSegment, mode );

		function _colourSegment ( vertices, colors, v1, v2 ) {

			colourCache.white.toArray( colors, v1 * 3 );
			colourCache.white.toArray( colors, v2 * 3 );

		}

	};

	Survey.prototype.setLegColourByColour = function ( mesh, colour ) {

		mesh.setShading( this.selection.getIds(), _colourSegment, 'basic');

		function _colourSegment ( vertices, colors, v1, v2 ) {

			colour.toArray( colors, v1 * 3 );
			colour.toArray( colors, v2 * 3 );

		}

	};

	Survey.prototype.setLegColourByLength = function ( mesh ) {

		const materials = this.ctx.materials;
		const colours = materials.colourCache.getColors( this.gradientName );
		const colourRange = colours.length - 1;
		const stats = mesh.stats;
		const legLengths = mesh.legLengths;

		mesh.setShading( this.selection.getIds(), _colourSegment, 'basic' );

		function _colourSegment ( vertices, colors, v1, v2 ) {

			const relLength = ( legLengths[ v1 / 2 ] - stats.minLegLength ) / stats.legLengthRange;
			const colour = colours[ Math.floor( relLength * colourRange ) ];

			colour.toArray( colors, v1 * 3 );
			colour.toArray( colors, v2 * 3 );

		}

	};

	Survey.prototype.setLegColourByDistance = function ( mesh ) {

		const cfg = this.ctx.cfg;
		const materials = this.ctx.materials;

		const colours = materials.colourCache.getColors( this.gradientName );
		const unconnected = cfg.themeColor( 'shading.unconnected' );
		const pathColor = cfg.themeColor( 'routes.active' );

		const stations = this.stations;
		const colourRange = colours.length - 1;
		const maxDistance = this.topology.maxDistance;
		const path = this.highlightPath;

		mesh.setShading( this.selection.getIds(), _colourSegment, 'basic' );

		function _colourSegment ( vertices, colors, v1, v2 ) {

			const onPath = ( path !== null && path.has( v1 ) );

			const c1 = onPath ? pathColor : _setDistanceColour( vertices, v1 );
			const c2 = onPath ? pathColor : _setDistanceColour( vertices, v2 );

			c1.toArray( colors, v1 * 3 );
			c2.toArray( colors, v2 * 3 );

		}

		function _setDistanceColour( vertices, vertexIndex ) {

			const vertex = vertices[ vertexIndex ];
			const distance = stations.getStation( vertex ).distance;

			return ( distance === Infinity ) ? unconnected : colours[ Math.floor( colourRange * distance / maxDistance ) ];

		}

	};

	Survey.prototype.setLegColourBySurvey = function ( mesh ) {

		var node = this.selection.getNode();

		while ( node.children.length === 1 ) node = node.children[ 0 ];

		__set.clear();
		node.getSubtreeIds( __set );

		const surveyToColourMap = this.ctx.surveyColourMapper.getColourMap( node );

		mesh.setShading( __set, _colourSegment, 'basic' );

		function _colourSegment ( vertices, colors, v1, v2, survey ) {

			const colour = surveyToColourMap[ survey ];

			colour.toArray( colors, v1 * 3 );
			colour.toArray( colors, v2 * 3 );

		}

	};

	Survey.prototype.setLegColourByPath = function ( mesh ) {

		const routes = this.routes;
		const cfg = this.ctx.cfg;

		const c1 = cfg.themeColor( 'routes.active' );
		const c2 = cfg.themeColor( 'routes.adjacent' );
		const c3 = cfg.themeColor( 'routes.default' );

		mesh.setShading( this.selection.getIds(), _colourSegment, 'basic');

		function _colourSegment ( vertices, colors, v1, v2 /*, survey */ ) {

			var colour;

			if ( routes.inCurrentRoute( v1 ) ) {

				colour = c1;

			} else if ( routes.adjacentToRoute( v1 ) ) {

				colour = c2;

			} else {

				colour = c3;
			}

			colour.toArray( colors, v1 * 3 );
			colour.toArray( colors, v2 * 3 );

		}

	};

	Survey.prototype.setLegColourByInclination = function ( mesh, pNormal ) {

		const colourCache = this.ctx.materials.colourCache;
		const colours = colourCache.getColors( 'inclination' );

		const colourRange = colours.length - 1;
		const hueFactor = colourRange * 2 / Math.PI;
		const legNormal = new Vector3();

		// pNormal = normal of reference plane in model space

		mesh.setShading( this.selection.getIds(), _colourSegment, 'basic' );

		function _colourSegment ( vertices, colors, v1, v2 ) {

			const vertex1 = vertices[ v1 ];
			const vertex2 = vertices[ v2 ];

			legNormal.subVectors( vertex1, vertex2 ).normalize();

			const dotProduct = legNormal.dot( pNormal );

			const hueIndex = Math.floor( hueFactor * Math.acos( Math.abs( dotProduct ) ) );
			const colour = colours[ hueIndex ];

			colour.toArray( colors, v1 * 3 );
			colour.toArray( colors, v2 * 3 );

		}

	};

	Survey.prototype.gltfExport = function ( selection, options, callback ) {

		const items = [];

		if ( selection.walls ) {

			items.push( this.getMesh( FACE_WALLS ) );

		}

		if ( selection.scraps ) {

			items.push( this.getMesh( FACE_SCRAPS ) );

		}

		if ( selection.legs ) {

			var legs = this.getFeature( LEG_CAVE );

			const geometry = legs.geometry;

			items.push( {
				type: 'lines',
				index: geometry.index,
				position: geometry.getAttribute( 'position' ),
				modelLimits: this.modelLimits
			} );

		}

		if ( items.length === 0 ) return;

		const worker = new Worker( this.ctx.cfg.value( 'home', '' ) + 'js/workers/gltfWorker.js' );

		worker.addEventListener( 'message', function( event ) {

			var mimeType;

			if ( options.binary) {

				mimeType = 'application/octet-stream';

			} else {

				mimeType = 'application/gltf+json';

			}

			callback( new Blob( [ event.data.gltf ], { type : mimeType } ), options.binary );

		} );

		worker.postMessage( { items: items, options: options } );

	};

	Survey.prototype.getMesh = function ( tag ) {

		var mesh = this.getFeature( tag );
		const geometry = mesh.geometry;

		return {
			type: 'walls',
			index: geometry.index,
			position: geometry.getAttribute( 'position' ),
			modelLimits: this.modelLimits
		};

	};

	function PopupMaterial ( container, popupImage, rotation, colour ) {

		const cos = Math.cos( rotation );
		const sin = Math.sin( rotation );
		const pixelRatio = window.devicePixelRatio || 1 ;
		const canvas = popupImage.image;
		const rotationMatrix = new Float32Array( [ cos, sin, -sin, cos ] );
		const scale = new Vector2( canvas.width * pixelRatio / container.clientWidth, canvas.height * pixelRatio / container.clientHeight );

		colour = colour || [ 1, 1, 1 ];

		ShaderMaterial.call( this, {
			vertexShader: Shaders.popupVertexShader,
			fragmentShader: Shaders.popupFragmentShader,
			type: 'CV.PopupMaterial',
			uniforms: {
				rotate: { value: rotationMatrix },
				popupImage: { value: popupImage },
				scale: { value: scale },
			},
			defines: {
				USE_COLOR: true
			}
		} );

		this.opacity = 1.0;
		this.alphaTest = 0.8;
		this.depthTest = false;
		this.transparent = true;

		this.texture = popupImage;

		this.defaultAttributeValues.color = colour;

		return this;

	}

	PopupMaterial.prototype = Object.create( ShaderMaterial.prototype );

	function PopupGeometry () {

		BufferGeometry.call( this );

		this.type = 'PopupGeometry';

		this.setIndex( CommonAttributes.index );
		this.setAttribute( 'position', CommonAttributes.position );

	}

	PopupGeometry.prototype = Object.create( BufferGeometry.prototype );

	var commonGeometry = null;

	function Popup( ctx ) {

		if ( commonGeometry === null ) commonGeometry = new PopupGeometry();

		Mesh.call( this, commonGeometry );

		this.layers.set( LEG_CAVE );
		this.type = 'Popup';
		this.renderOrder = Infinity;
		this.ctx = ctx;

		return this;

	}

	Popup.prototype = Object.create( Mesh.prototype );

	Popup.prototype.close = function () {

		if ( this.parent ) this.parent.remove( this );

		const material = this.materal;

		if ( ! material ) return;

		material.dispose();

		if ( material.texture) material.texture.dispose();


	};

	function CanvasPopup( ctx ) {

		Popup.call( this, ctx );

		this.lines = [];
		this.type = 'CanvasPopup';

		return this;

	}

	CanvasPopup.prototype = Object.create( Popup.prototype );

	CanvasPopup.prototype.addLine = function ( line ) {

		this.lines.push( line );

		return this;

	};

	CanvasPopup.prototype.finish = function () {

		const cfg = this.ctx.cfg;
		const container = this.ctx.container;
		const cellSize = 32;
		const fontSize = 20;

		const lines = this.lines;
		const lineCount = lines.length;

		const popupWidth = 256;
		const popupHeight = cellSize * lineCount;

		const canvas = document.createElement( 'canvas' );

		if ( ! canvas ) console.error( 'creating canvas for CanvasPopup failed' );

		canvas.width  = popupWidth;
		canvas.height = popupHeight;

		const ctx = canvas.getContext( '2d' );

		if ( ! ctx ) console.error( 'cannot obtain 2D canvas' );

		// set background

		ctx.fillStyle = cfg.themeColorCSS( 'popup.background' );
		ctx.fillRect( 0, 0, popupWidth, popupHeight );

		ctx.strokeStyle = cfg.themeColorCSS( 'popup.border' );
		ctx.lineWidth = 2.0;
		ctx.strokeRect( 0, 0, popupWidth, popupHeight );

		// write text contents

		ctx.textAlign = 'left';
		ctx.font = fontSize + 'px ' + 'normal helvetica,sans-serif';
		ctx.fillStyle = cfg.themeColorCSS( 'popup.text' );

		var i;

		for ( i = 0; i < lineCount; i++ ) {

			ctx.fillText( lines[ i ], 10 , cellSize * ( i + 1 ) - 6 );

		}

		const texture = new CanvasTexture( canvas );

		texture.onUpdate = function _dropCanvas ( texture ) { texture.image = null; };

		const material = new PopupMaterial( container, texture, 0 );

		this.material = material;
		this.material.needsUpdate = true;

		return this;

	};

	function StationPopup ( ctx, station, survey, depth, formatter, showDistance, warnings ) {

		CanvasPopup.call( this, ctx );

		const position = survey.getGeographicalPosition( station.p );

		var name = station.getPath();
		var long = false;
		var tmp;
		var lines = null;

		// reduce name length if too long

		while ( name.length > 20 ) {

			tmp = name.split( '.' );
			tmp.shift();

			name = tmp.join( '.' );
			long = true;

		}

		var distance;

		if ( showDistance ) {

			distance = station.distance !== Infinity ? Math.round( station.distance ) : 'unconnected';

		} else {

			distance = null;

		}

		if ( long ) name = '...' + name;

		this.addLine( name );

		if ( warnings && station.messageText !== undefined ) {

			this.addLine( station.messageText );

		} else {

			if ( formatter !== undefined ) {

				lines = formatter( survey.CRS, position, depth, distance );

			}

			if ( lines !== null ) {

				for ( let i = 0; i < lines.length; i++ ) {

					this.addLine( lines[ i ] );

				}

			} else {

				this.addLine( 'x: ' + Math.round( position.x ) + ' m, y: ' + Math.round( position.y ) + ' m' ).addLine( 'z: ' + Math.round( position.z ) + ' m' );

				if ( depth !== null ) this.addLine( 'depth from surface: ' + Math.round( depth ) + ' m' );

				if ( showDistance ) {

					this.addLine( 'distance: ' + distance + '\u202fm' );

				}

			}

		}

		this.finish();

		this.position.copy( station.p );

		return this;

	}

	StationPopup.prototype = Object.create( CanvasPopup.prototype );

	function ImagePopup( ctx, station, imageUrl, callback ) {

		Popup.call( this, ctx );

		this.type = 'ImagePopup';

		const texture = new TextureLoader().load( imageUrl, _textureLoaded );

		texture.onUpdate = function _dropCanvas ( texture ) { texture.image = null; };

		this.position.copy( station.p );

		const self = this;

		return this;

		function _textureLoaded( texture ) {

			self.material = new PopupMaterial( self.ctx.container, texture, 0 );
			self.material.needsUpdate = true;

			callback();

		}

	}

	ImagePopup.prototype = Object.create( Popup.prototype );

	// preallocated for projected area calculations

	const __a$1 = new Vector3();
	const __b$1 = new Vector3();
	const __c$1 = new Vector3();
	const __d$1 = new Vector3();

	const __t1$1 = new Triangle( __a$1, __b$1, __c$1 );
	const __t2$1 = new Triangle( __a$1, __c$1, __d$1 );

	function onUploadDropBuffer$3() {

		// call back from BufferAttribute to drop JS buffers after data has been transfered to GPU
		this.array = null;

	}

	function Tile ( ctx, x, y, zoom, tileSpec ) {

		this.x = x;
		this.y = y;

		this.zoom    = zoom;
		this.tileSet = tileSpec.tileSet;
		this.clip    = tileSpec.clip;
		this.clippedFraction = tileSpec.clippedFraction;

		this.canZoom  = ( zoom < tileSpec.tileSet.overlayMaxZoom );
		this.evicted  = false;
		this.replaced = false;
		this.evictionCount = 0;
		this.lastFrame = 0;
		this.childrenLoading = 0;
		this.childErrors = 0;
		this.area = 0;

		this.boundingBox = null;
		this.worldBoundingBox = null;

		Mesh.call( this, new BufferGeometry(), ctx.materials.getSurfaceMaterial() );

		this.type = 'Tile';
		this.isTile = false;

		return this;

	}

	Tile.liveTiles = 0;

	Tile.prototype = Object.create( Mesh.prototype );

	Tile.prototype.onBeforeRender = function ( renderer ) {

		this.lastFrame = renderer.info.render.frame;

	};

	Tile.prototype.createFromBufferAttributes = function ( index, attributes, boundingBox, material ) {

		var attributeName;
		var attribute;
		var bufferGeometry = this.geometry;

		// assemble BufferGeometry from binary buffer objects transfered from worker

		for ( attributeName in attributes ) {

			attribute = attributes[ attributeName ];
			bufferGeometry.setAttribute( attributeName, new Float32BufferAttribute( attribute.array, attribute.itemSize ) );

		}

		bufferGeometry.setIndex( new Uint16BufferAttribute( index, 1 ) );

		// use precalculated bounding box rather than recalculating it here.

		bufferGeometry.boundingBox = new Box3(
			new Vector3( boundingBox.min.x, boundingBox.min.y, boundingBox.min.z ),
			new Vector3( boundingBox.max.x, boundingBox.max.y, boundingBox.max.z )
		);

		this.boundingBox = bufferGeometry.boundingBox;

		// discard javascript attribute buffers after upload to GPU

		attributes = bufferGeometry.attributes;

		for ( var name in attributes ) attributes[ name ].onUpload( onUploadDropBuffer$3 );

		this.geometry.index.onUpload( onUploadDropBuffer$3 );

		this.layers.set( FEATURE_TERRAIN );

		this.material = material;
		this.isTile = true;

		return this;

	};

	Tile.prototype.getWorldBoundingBox = function () {

		// delay calculating this until the terrain is in the scene graph.
		if ( this.worldBoundingBox === null ) {

			this.updateWorldMatrix( true, false );

			this.worldBoundingBox = this.boundingBox.clone().applyMatrix4( this.matrixWorld );

		}

		return this.worldBoundingBox;

	};

	Tile.prototype.empty = function () {

		this.isMesh = false;

		if ( this.geometry ) {

			this.geometry.dispose();
			this.geometry = new BufferGeometry();

		}

		--Tile.liveTiles;

	};

	Tile.prototype.evict = function () {

		this.evicted = true;
		this.replaced = false;
		this.evictionCount = 0;

		this.empty();

	};

	Tile.prototype.setReplaced = function () {

		this.evicted = false;
		this.replaced = true;

		this.empty();

	};

	Tile.prototype.setSkipped = function () {

		this.parent.childrenLoading--;

		this.evicted = false;
		this.replaced = true;

	};

	Tile.prototype.setPending = function ( parentTile ) {

		if ( parentTile && this.parent === null ) {

			parentTile.addStatic( this );

		}

		this.parent.childrenLoading++;

		this.isMesh = false;
		this.evicted = false;
		this.replaced = false;
		this.evictionCount = 0;

	};

	Tile.prototype.setFailed = function () {

		const parent = this.parent;

		parent.childErrors++;
		parent.childrenLoading--;
		parent.canZoom = false;

		parent.remove( this );

	};

	Tile.prototype.setLoaded = function ( overlay, renderCallback ) {

		const parent = this.parent;

		var tilesWaiting = 0;

		if ( --parent.childrenLoading === 0 ) { // this tile and all siblings loaded

			if ( parent.childErrors === 0 ) { // all loaded without error

				if ( parent.isTile ) parent.setReplaced();

				parent.children.forEach( function ( sibling ) {

					if ( sibling.replaced || sibling.evicted ) return;

					if ( overlay === null ) {

						sibling.isMesh = true;
						Tile.liveTiles++;

					} else {

						// delay finalising until overlays loaded - avoids flash of raw surface
						sibling.setOverlay( overlay, _completed );
						tilesWaiting++;

					}

				} );

				if ( tilesWaiting === 0 ) renderCallback( parent.childErrors );

				return true;

			} else {

				parent.remove( this );

			}

		}

		return false;

		function _completed( tile ) {

			tile.isMesh = true;
			Tile.liveTiles++;

			if ( --tilesWaiting === 0 ) renderCallback( parent.childErrors );

		}

	};

	Tile.prototype.removed = function () {

		if ( this.geometry ) this.geometry.dispose();

	};

	Tile.prototype.setMaterial = function ( material ) {

		this.material = material;

	};

	Tile.prototype.setThroughMode = function ( mode ) {

		this.material.setThroughMode( mode );

	};

	Tile.prototype.setOverlay = function ( overlay, imageLoadedCallback ) {

		const self = this;

		overlay.getTile( this.x, this.y, this.zoom, _overlayLoaded );

		return;

		function _overlayLoaded ( material ) {

			if ( material !== null ) {

				self.material = material;
				material.setThroughMode( overlay.throughMode );

			}

			imageLoadedCallback( self );

		}

	};

	Tile.prototype.computeProjectedArea = function ( camera ) {

		const boundingBox = this.getWorldBoundingBox();
		const z = boundingBox.max.z;

		__a$1.copy( boundingBox.min ).setZ( z );
		__c$1.copy( boundingBox.max );

		__b$1.set( __a$1.x, __c$1.y, z );
		__d$1.set( __c$1.x, __a$1.y, z );

		// clamping reduces accuracy of area but stops offscreen area contributing to zoom pressure
		// .clampScalar( -1, 1 );

		__a$1.project( camera );
		__b$1.project( camera );
		__c$1.project( camera );
		__d$1.project( camera );

		this.area = ( __t1$1.getArea() + __t2$1.getArea() ) / this.clippedFraction;

		return this;

	};

	function EPSG4326TileSet( ctx, tileSetReady, crs ) {

		this.CRS = crs;
		this.transform = proj4( crs, 'EPSG:4326' );

		// survey limits

		this.transformedLimits = null;

		const self = this;

		const accessToken = ctx.cfg.value( 'cesiumAccessToken', 'no access token' );
		const url = 'https://api.cesium.com/v1/assets/1/endpoint?access_token=' + accessToken;

		new FileLoader().setResponseType( 'text' ).load( url, _getEndpoint, function () {}, _apiError );

		function _getEndpoint ( text ) {

			const endpoint = JSON.parse( text );

			self.url = endpoint.url;
			self.accessToken = endpoint.accessToken;
			self.attributions = endpoint.attributions;

			EPSG4326TileSet.defaultTileSet.valid = true;
			tileSetReady();

		}

		function _apiError ( ) {

			console.warn( 'cesium api error' );
			tileSetReady();

		}

	}

	EPSG4326TileSet.defaultTileSet = {
		title: 'Cesium',
		initialZoom: 12,
		overlayMaxZoom: 16,
		maxZoom: 17,
		minZoom: 10,
		divisions: 1,
		subdirectory: null,
		dtmScale: 64,
		minX: 0,
		maxX: 2048,
		minY: 0,
		maxY: 1023,
		attributions: [],
		log: true,
		valid: false
	};

	EPSG4326TileSet.prototype.workerScript = 'webMeshWorker.js';

	EPSG4326TileSet.prototype.getTileSets = function () {

		return [ EPSG4326TileSet.defaultTileSet ];

	};

	EPSG4326TileSet.prototype.getScreenAttribution = function () {

		const attributions = this.attributions;

		if ( attributions.length === 0 ) return null;

		const div = document.createElement( 'div' );

		div.classList.add( 'overlay-branding' );

		for ( var i = 0; i < attributions.length; i++ ) {

			const attribution = attributions[ i ];

			div.innerHTML = attribution.html;
			break;

		}

		return div;

	};

	EPSG4326TileSet.prototype.getCoverage = function ( limits, zoom ) {

		const coverage = { zoom: zoom };

		const S = - 90;
		const W = - 180;

		if ( this.transformedLimits === null ) {

			this.transformedLimits = new Box2();

		}

		const transformedLimits = this.transformedLimits;

		transformedLimits.expandByPoint( this.transform.forward( limits.min.clone() ) );
		transformedLimits.expandByPoint( this.transform.forward( limits.max.clone() ) );

		const min = transformedLimits.min;
		const max = transformedLimits.max;

		const tileCount = Math.pow( 2, zoom ) / 180; // tile count per degree

		coverage.minX = Math.floor( ( min.x - W ) * tileCount );
		coverage.maxX = Math.floor( ( max.x - W ) * tileCount );

		coverage.minY = Math.floor( ( min.y - S ) * tileCount );
		coverage.maxY = Math.floor( ( max.y - S ) * tileCount );

		coverage.count = ( coverage.maxX - coverage.minX + 1 ) * ( coverage.maxY - coverage.minY + 1 );

		return coverage;

	};


	EPSG4326TileSet.prototype.getTileSpec = function ( x, y, z, limits ) {

		const tileBox = new Box2();

		const S = - 90;
		const W = - 180;

		// ensure tile is within survey limits

		const tileSize = 180 / Math.pow( 2, z ); // tileSize

		tileBox.min.x = W + x * tileSize;
		tileBox.min.y = S + y * tileSize;

		tileBox.max.x = W + ( x + 1) * tileSize;
		tileBox.max.y = S + ( y + 1 ) * tileSize;

		if ( ! this.transformedLimits.intersectsBox( tileBox ) ) return null;

		const clippedSize = new Vector2();

		tileBox.clone().intersect( this.transformedLimits ).getSize( clippedSize );

		return {
			tileSet: this.tileSet,
			divisions: 1,
			resolution: tileSize,
			x: x,
			y: y,
			z: z,
			clip: limits,
			offsets: null,
			flatZ: null,
			displayCRS: this.CRS,
			url: this.url,
			accessToken: this.accessToken,
			clippedFraction: clippedSize.x * clippedSize.y / tileSize * tileSize,
			request: 'tile'
		};

	};

	const halfMapExtent = 6378137 * Math.PI; // from EPSG:3875 definition

	var tileSets;

	function EPSG3857TileSet( ctx, tileSetReady ) {

		new FileLoader().setResponseType( 'text' ).load( ctx.cfg.value( 'terrainDirectory', '' ) + '/' + 'tileSets.json', _tileSetLoaded, function () {}, _tileSetMissing );

		return;

		function _tileSetLoaded ( text ) {

			tileSets = JSON.parse( text );
			tileSets.push( EPSG3857TileSet.defaultTileSet );

			tileSetReady();

		}

		function _tileSetMissing ( ) {

			tileSets = [ EPSG3857TileSet.defaultTileSet ];

			tileSetReady();

		}

	}

	EPSG3857TileSet.defaultTileSet = {
		isFlat: true,
		title: 'flat',
		overlayMaxZoom: 18,
		maxZoom: 16,
		minZoom: 10,
		divisions: 128,
		subdirectory: null,
		dtmScale: 64,
		minX: 0,
		maxX: 1023,
		minY: 0,
		maxY: 1023,
		attributions: [],
		log: true
	};

	EPSG3857TileSet.prototype.workerScript = 'webTileWorker.js';

	EPSG3857TileSet.prototype.getTileSets = function () {

		return tileSets;

	};

	EPSG3857TileSet.prototype.getScreenAttribution = function () {

		return null;

	};

	EPSG3857TileSet.prototype.getCoverage = function ( limits, zoom ) {

		const coverage = { zoom: zoom };

		const N =  halfMapExtent;
		const W = -halfMapExtent;

		const tileCount = Math.pow( 2, zoom - 1 ) / halfMapExtent; // tile count per metre

		coverage.minX = Math.floor( ( limits.min.x - W ) * tileCount );
		coverage.maxX = Math.floor( ( limits.max.x - W ) * tileCount );

		coverage.maxY = Math.floor( ( N - limits.min.y ) * tileCount );
		coverage.minY = Math.floor( ( N - limits.max.y ) * tileCount );

		coverage.count = ( coverage.maxX - coverage.minX + 1 ) * ( coverage.maxY - coverage.minY + 1 );

		return coverage;

	};

	EPSG3857TileSet.prototype.getTileSpec = function ( x, y, z, limits ) {

		const tileSet = this.tileSet;
		const scale = ( z > tileSet.maxZoom ) ? Math.pow( 2, tileSet.maxZoom - z ) : 1;

		// don't zoom in with no overlay - no improvement of terrain rendering in this case

		if ( scale !== 1 && this.activeOverlay === null ) return null;

		if ( this.log ) console.log( 'load: [ ', z +'/' + x + '/' + y, ']' );

		const tileWidth = halfMapExtent / Math.pow( 2, z - 1 );

		const clip = { top: 0, bottom: 0, left: 0, right: 0 };

		const tileMinX = tileWidth * x - halfMapExtent;
		const tileMaxX = tileMinX + tileWidth;

		const tileMaxY = halfMapExtent - tileWidth * y;
		const tileMinY = tileMaxY - tileWidth;

		const divisions = ( tileSet.divisions ) * scale ;
		const resolution = tileWidth / divisions;

		// trim excess off sides of tile where overlapping with region

		if ( tileMaxY > limits.max.y ) clip.top = Math.floor( ( tileMaxY - limits.max.y ) / resolution );

		if ( tileMinY < limits.min.y ) clip.bottom = Math.floor( ( limits.min.y - tileMinY ) / resolution );

		if ( tileMinX < limits.min.x ) clip.left = Math.floor( ( limits.min.x - tileMinX ) / resolution );

		if ( tileMaxX > limits.max.x ) clip.right = Math.floor( ( tileMaxX - limits.max.x ) / resolution );

		if ( clip.top >= divisions || clip.bottom >= divisions || clip.left >= divisions || clip.right >= divisions ) return null;

		const clippedFraction = ( divisions - clip.top - clip.bottom ) * (divisions - clip.left - clip.right ) / ( divisions * divisions );

		return {
			tileSet: tileSet,
			divisions: divisions,
			resolution: resolution,
			x: x,
			y: y,
			z: z,
			clip: clip,
			offsets: null,
			flatZ: null,
			clippedFraction: clippedFraction,
			request: 'tile'
		};

	};

	EPSG3857TileSet.prototype.findTile = function ( point ) {

		const tileSet = this.tileSet;

		const tileWidth = halfMapExtent / Math.pow( 2, tileSet.maxZoom - 1 );

		const xTc = ( point.x + halfMapExtent ) / tileWidth;
		const yTc = ( halfMapExtent - point.y ) / tileWidth;

		const tileX = Math.floor( xTc );
		const tileY = Math.floor( yTc );
		const tileZ = tileSet.maxZoom;

		const offsetX = xTc - tileX;
		const offsetY = yTc - tileY;
		const samples = tileSet.divisions + 1;

		const dataOffset = Math.floor( samples * offsetX ) + samples * Math.floor( samples * offsetY );

		// construct a tileSpec for passing to web worker
		return {
			x: tileX,
			y: tileY,
			z: tileZ,
			tileSet: tileSet,
			dataOffsets: [ dataOffset ],
			points: [ point ],
			request: 'height',
			clip: {}
		};

	};

	const __frustum = new Frustum();
	const __matrix4 = new Matrix4();

	const __startEvent = { type: 'progress', name: 'start' };
	const __endEvent = { type: 'progress', name: 'end' };

	function WebTerrain ( ctx, survey, onLoaded ) {

		CommonTerrain.call( this, ctx );

		this.name = 'WebTerrain';
		this.type = 'CV.WebTerrain';
		this.attributions = [];
		this.log = false;
		this.ctx = ctx;

		this.displayCRS = survey.displayCRS;
		this.surveyCRS = survey.CRS;
		this.limits = survey.limits;
		this.flatZ = survey.modelLimits.max.z;
		this.offsets = survey.offsets;

		this.onLoaded        = onLoaded;
		this.childrenLoading = 0;
		this.childErrors     = 0;
		this.isLoaded        = false;
		this.material        = null;
		this.initialZoom     = null;
		this.dying = false;
		this.tilesLoading = 0;
		this.maxTilesLoading = 0;
		this.overlaysLoading = 0;
		this.debug = true;
		this.coverage = null;
		this.TS = null;
		this.maxTiles = ctx.cfg.value( 'maxTiles', 128 );

		// tile zoom properties
		this.retile_timeout = 80;
		this.retileScaler = 4;
		this.lastActivityTime = 0;
		this.timerId = null;

		this.material = ctx.materials.getCursorMaterial();
		this.canZoom = true;

		this.watcher = this.scheduleRetile.bind( this );
		this.updateFunc = WebTerrain.prototype.zoomCheck.bind( this );

		const self = this;

		switch ( this.displayCRS ) {

		case 'EPSG:3857':

			this.TS = new EPSG3857TileSet( ctx, _tileSetReady );

			break;

		case 'EPSG:4326':
		case 'ORIGINAL':

			this.TS = new EPSG4326TileSet( ctx, _tileSetReady, this.surveyCRS );

			break;

		default:

			onLoaded( this );
			return;

		}

		this.workerPool = this.ctx.workerPools.getPool( this.TS.workerScript );

		return;

		function _tileSetReady () {

			self.tileSets = self.TS.getTileSets();
			self.screenAttribution = self.TS.getScreenAttribution();

			if ( self.hasCoverage() ) {

				self.tileArea( self.limits );

			} else {

				console.log( 'no terrain found' );
				onLoaded( self );

			}

		}

	}

	WebTerrain.prototype = Object.create( CommonTerrain.prototype );

	WebTerrain.prototype.isTiled = true;

	WebTerrain.prototype.hasCoverage = function () {

		// iterate through available tileSets and pick the first match

		const limits = this.limits;
		const baseDirectory = this.ctx.cfg.value( 'terrainDirectory', '' );
		const tileSets = this.tileSets;
		const TS = this.TS;

		for ( var i = 0, l = tileSets.length; i < l; i++ ) {

			const tileSet = tileSets[ i ];

			if ( tileSet.valid === false ) continue;

			const coverage = TS.getCoverage( limits, tileSet.minZoom );

			if (
				coverage.minX >= tileSet.minX &&
				coverage.maxX <= tileSet.maxX &&
				coverage.minY >= tileSet.minY &&
				coverage.maxY <= tileSet.maxY
			) {

				tileSet.directory = baseDirectory + tileSet.subdirectory;

				TS.tileSet = tileSet;

				this.isFlat = tileSet.isFlat;
				this.log = tileSet.log === undefined ? false : tileSet.log;
				this.attributions = tileSet.attributions;

				console.log( 'selected tile set:', tileSet.title );

				return true;

			}

		}

		return false;

	};

	WebTerrain.prototype.pickCoverage = function ( limits ) {

		const tileSet = this.TS.tileSet;

		var zoom = tileSet.initialZoom || tileSet.overlayMaxZoom + 1;
		var coverage;

		do {

			coverage = this.TS.getCoverage( limits, --zoom );

		} while ( coverage.count > 4 && zoom > tileSet.minZoom );

		return coverage;

	};

	WebTerrain.prototype.loadTile = function ( x, y, z, parentTile, existingTile ) {

		if ( existingTile === undefined ) {

			existingTile = parentTile.children.find( function ( tile ) {
				return ( tile.x === x && tile.y === y && tile.zoom === z );
			} );

		}

		const self = this;
		const tileSpec = this.TS.getTileSpec( x, y, z, this.limits );

		if ( tileSpec === null ) return;

		tileSpec.offsets = this.offsets,
		tileSpec.flatZ = this.flatZ;

		this.maxTilesLoading = Math.max( this.maxTilesLoading, ++this.tilesLoading );

		if ( this.log ) console.log( 'load: [ ', z +'/' + x + '/' + y, ']', this.tilesLoading );

		// get Tile instance.

		const tile = existingTile ? existingTile : new Tile( this.ctx, x, y, z, tileSpec );

		tile.setPending( parentTile ); // tile load/reload pending

		this.workerPool.runWorker( tileSpec, _mapLoaded );

		return;

		function _mapLoaded ( event ) {

			const tileData = event.data;
			const worker = event.currentTarget;
			const overlay = self.activeOverlay;

			// return worker to pool

			self.workerPool.putWorker( worker );

			--self.tilesLoading;

			// the survey/region in the viewer may have changed while the height maps are being loaded.
			// bail out in this case to avoid errors

			if ( self.dying ) {

				self.dispatchEvent( __endEvent );
				return;

			}

			if ( tileData.status === 'zoom' ) {

				tile.setSkipped();
				self.zoomTile( tile );

				return;

			}

			// error out early if we or other tiles have failed to load.

			if ( tileData.status !== 'ok' || tile.parent.childErrors !== 0 ) {

				tile.setFailed();

				// signal error to caller
				if ( self.tilesLoading === 0 && ! self.isLoaded ) {

					self.onLoaded( self );

				}

				self.dispatchEvent( __endEvent );

				return;

			}

			tile.createFromBufferAttributes( tileData.index, tileData.attributes, tileData.boundingBox, self.material );
			tile.canZoom = tileData.canZoom;

			self.dispatchEvent( { type: 'progress', name: 'set', progress: 100 * ( self.maxTilesLoading - self.tilesLoading ) / self.maxTilesLoading } );

			if ( tile.setLoaded( overlay, _loaded ) ) {

				if ( overlay !== null && tile.zoom < overlay.getMinZoom() && tile.canZoom ) {

					self.zoomTile( tile );

				}

			}

		}

		function _loaded () {

			if ( self.tilesLoading !== 0 ) return;
			if ( self.tilesLoading === 0 ) self.dispatchEvent( __endEvent );

			if ( ! self.isLoaded ) {

				self.isLoaded = true;
				self.onLoaded( self );

			}

		}

	};

	WebTerrain.prototype.initProgress = function () {

		if ( this.tilesLoading > 0 ) {

			this.dispatchEvent( __startEvent );

		}

	};

	WebTerrain.prototype.tileArea = function ( limits ) {

		const coverage = this.pickCoverage( limits );
		const zoom = coverage.zoom;

		this.initialZoom = zoom;
		this.coverage = coverage;

		for ( var x = coverage.minX; x < coverage.maxX + 1; x++ ) {

			for ( var y = coverage.minY; y < coverage.maxY + 1; y++ ) {

				this.loadTile( x, y, zoom, this );

			}

		}

		this.initProgress();

		return;

	};

	WebTerrain.prototype.tileSet = function () {

		const tileSet = Object.assign( {}, EPSG3857TileSet.defaultTileSet );
		const coverage = this.coverage;

		delete tileSet.isFlat;
		delete tileSet.directory;

		tileSet.title = 'new tile set';
		tileSet.subdirectory = 'new_tile_set';

		tileSet.minZoom = coverage.zoom;

		tileSet.minX = coverage.minX;
		tileSet.maxX = coverage.maxX;
		tileSet.minY = coverage.minY;
		tileSet.maxY = coverage.maxY;

		return dataURL( tileSet );

	};

	WebTerrain.prototype.zoomTile = function ( tile ) {

		const zoom = tile.zoom + 1;
		const x = tile.x * 2;
		const y = tile.y * 2;

		this.loadTile( x,     y,     zoom, tile );
		this.loadTile( x + 1, y,     zoom, tile );
		this.loadTile( x,     y + 1, zoom, tile );
		this.loadTile( x + 1, y + 1, zoom, tile );

	};

	WebTerrain.prototype.setOverlay = function ( overlay, overlayLoadedCallback ) {

		if ( this.tilesLoading > 0 ) return;

		const self = this;
		const currentOverlay = this.activeOverlay;
		const throughMode = overlay.throughMode;

		if ( currentOverlay !== null ) {

			if ( currentOverlay === overlay ) {

				this.traverse( _setTileThroughMode );

				return;

			} else {

				currentOverlay.setInactive();

			}

		}

		overlay.setActive();

		this.activeOverlay = overlay;

		const overlayMinZoom = overlay.getMinZoom();

		this.traverse( _setTileOverlays );

		return;

		function _setTileOverlays ( tile ) {

			if ( ! tile.isTile || ! tile.isMesh ) return;

			if ( tile.zoom < overlayMinZoom ) {

				// no overlay for this zoom layer, zoom to next level
				self.zoomTile( tile );

			} else {

				tile.setOverlay( overlay, _overlayLoaded );
				self.overlaysLoading++;

			}

		}

		function _setTileThroughMode ( tile ) {

			if ( ! tile.isTile || ! tile.isMesh ) return;

			tile.setThroughMode( throughMode );

		}

		function _overlayLoaded () {

			if ( --self.overlaysLoading === 0 ) overlayLoadedCallback();

		}

	};

	WebTerrain.prototype.removed = function () {

		const self = this;

		this.dying = true;

		this.traverse( _disposeTileMesh );

		this.commonRemoved();

		return;

		function _disposeTileMesh ( obj ) {

			if ( obj !== self ) obj.removed( obj );

		}

	};

	WebTerrain.prototype.setMaterial = function ( material ) {

		if ( this.tilesLoading > 0 ) return;

		this.traverse( _setTileMeshMaterial );

		this.activeOverlay = null;

		material.needsUpdate = true;
		material.fog = false;

		this.material = material;

		return;

		function _setTileMeshMaterial ( obj ) {

			if ( ! obj.isTile ) return;

			obj.setMaterial( material );

		}

	};


	WebTerrain.prototype.zoomCheck = function ( cameraManager ) {

		if ( performance.now() - this.lastActivityTime < this.retile_timeout ) return;
		if ( this.tilesLoading > 0 ) return true;

		const self = this;
		const frustum = __frustum;
		const camera = cameraManager.activeCamera;
		const lastFrame = cameraManager.getLastFrame();

		const candidateTiles      = [];
		const candidateEvictTiles = [];
		const resurrectTiles      = [];

		var retry = false;
		var i;

		frustum.setFromProjectionMatrix( __matrix4.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse ) );

		// scan scene graph of terrain

		this.traverse( _scanTiles );

		const resurrectCount = resurrectTiles.length;
		const candidateCount = candidateTiles.length;

		_evictTiles();

		if ( resurrectCount !== 0 ) {

			for ( i = 0; i < resurrectCount; i++ ) {

				const tile = resurrectTiles[ i ];

				// reload tile (use exiting tile object to preserve canZoom).
				this.loadTile( tile.x, tile.y, tile.zoom, tile.parent, tile );

			}

			retry = true;

		} else if ( candidateCount !== 0 ) {

			for ( i = 0; i < candidateCount; i++ ) {

				this.zoomTile( candidateTiles[ i ] );

			}

			retry = true;

		}

		this.initProgress();

		if ( retry ) {

			this.timerId = setTimeout( this.updateFunc, this.retile_timeout * this.retileScaler, cameraManager );
			this.retileScaler *= 2;

		}

		return;

		function _scanTiles( tile ) {

			const parent = tile.parent;

			if ( ! tile.isTile || ! parent.canZoom ) return;

			if ( tile.isMesh && tile.canZoom && tile.lastFrame === lastFrame ) {

				// this tile intersects the screen

				// this tile is loaded, maybe increase resolution?
				// now safe if tile has evicted children or not

				tile.computeProjectedArea( camera );
				if ( tile.area / 4 > 0.81 ) candidateTiles.push( tile );

			} else if ( ! parent.isMesh && tile.evicted && frustum.intersectsBox( tile.getWorldBoundingBox() ) ) {

				// this tile is not loaded, but has been previously

				// flag subtiles to prevent premature resurrection
				// and indicate replaced by superior
				tile.traverse( function ( subtile ) {

					subtile.evicted = false;
					if ( subtile !== tile ) subtile.replaced = true;

				} );

				resurrectTiles.push( tile );

			} else {

				// off screen tile
				if ( tile.isMesh && tile.lastFrame !== lastFrame ) candidateEvictTiles.push( tile );

			}

		}

		function _evictTiles() {

			const candidateCount = candidateEvictTiles.length;
			const evictTarget = Tile.liveTiles - self.maxTiles;
			const evictCount = Math.min( candidateCount, evictTarget );

			if ( evictCount > 0 ) {

				candidateEvictTiles.sort( _sortByPressure );

				let i;
				const now = performance.now();

				for ( i = 0; i < evictCount; i++ ) {

					const tile = candidateEvictTiles[ i ];

					if ( tile.evictionCount === 0 ) {

						tile.evictionCount = now;

					} else if ( now - tile.evictionCount > 1000 ) {

						tile.evict();

					}

				}

			}

			function _sortByPressure( tileA, tileB ) {

				const zoomDiff = tileB.zoom - tileA.zoom;

				if ( zoomDiff !== 0 ) {

					return zoomDiff;

				}

				const frameDiff = tileA.lastFrame - tileB.lastFrame;

				if ( frameDiff !== 0 ) {

					return frameDiff;

				}

				const xDiff = tileA.x - tileB.x;

				if ( xDiff !== 0 ) {

					return xDiff;

				} else {

					return tileA.y - tileB.y;

				}

			}

		}

	};

	WebTerrain.prototype.getHeights = function ( points, callback ) {

		const tileSet = this.TS;
		const self = this;

		const tileSpecs = {};
		const results = [];

		// sort points in to requests per tile

		points.forEach( function ( point, i ) {

			const tileSpec = tileSet.findTile( point );
			const key = tileSpec.x + ':' + tileSpec.y + ':' + tileSpec.z;

			point.index = i;

			if ( tileSpecs[ key ] === undefined ) {

				// new tile query
				tileSpecs[ key ] = tileSpec;

			} else {

				// merge requested point with existing query
				tileSpecs[ key ].dataOffsets.push( tileSpec.dataOffsets[ 0 ] );
				tileSpecs[ key ].points.push( tileSpec.points[ 0 ] );

			}

		} );

		// dispatch requests

		let requestCount = 0;

		for ( var key in tileSpecs) {

			this.workerPool.runWorker( tileSpecs[ key ], _mapLoaded );
			requestCount++;

		}

		return;

		function _mapLoaded ( event ) {

			// return worker to pool

			self.workerPool.putWorker( event.currentTarget );

			const resultPoints = event.data.points;

			resultPoints.forEach( function ( point ) { results[ point.index ] = point; } );

			if ( --requestCount === 0 ) {

				callback( results );

			}

		}

	};

	WebTerrain.prototype.fitSurface = function ( modelPoints, offsets ) {

		if ( this.TS.findTile === undefined ) {

			this._fitSurface( modelPoints );
			return;

		}

		const self = this;

		// adjust to geographical values
		const points = modelPoints.map( function ( point ) { return point.clone().add( offsets); } );

		this.getHeights( points, _heightsReturned );

		function _heightsReturned ( ret ) {

			var n = 0, s1 = 0, s2 = 0;

			ret.forEach( function ( a ) {

				const v = points[ a.index ].z - a.z;
				s1 += v;
				s2 += v * v;
				n++;

			} );

			const sd = Math.sqrt( s2 / n - Math.pow( s1 / n, 2 ) );

			// simple average
			self.datumShift = s1 / n;

			console.log( 'Adjustmenting terrain height by:', self.datumShift, 'sd:',sd );

		}

	};

	WebTerrain.prototype.scheduleRetile = function ( event) {

		if ( ! this.visible ) return;

		if ( this.timerId !== null ) clearTimeout( this.timerId );

		this.retileScaler = 4;
		this.lastActivityTime = performance.now();
		this.timerId = setTimeout( this.updateFunc, this.retile_timeout, event.cameraManager );

	};


	WebTerrain.prototype.watch = function ( obj ) {

		obj.addEventListener( 'moved', this.watcher );

	};

	WebTerrain.prototype.unwatch = function ( obj ) {

		obj.removeEventListener( 'moved', this.watcher );

	};

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn) {
	  var module = { exports: {} };
		return fn(module, module.exports), module.exports;
	}

	var observable = createCommonjsModule(function (module, exports) {
	// Copyright (c) 2012-2016 Florian Hartmann, https://github.com/florian/observable
	(function() {
	  var Observable, isPlainObject, isType, toArray;

	  isType = function(type, value) {
	    return Object.prototype.toString.call(value).match(/\s(\w+)/)[1].toLowerCase() === type;
	  };

	  isPlainObject = function(value) {
	    return !!value && isType('object', value);
	  };

	  toArray = function(value) {
	    if (isType('array', value)) {
	      return value;
	    } else {
	      return [value];
	    }
	  };

	  Observable = (function() {
	    function Observable() {
	      this.__eventStore = {};
	      this.__asyncEvents = true;
	    }

	    Observable.mixin = function(host) {
	      var fn, key, ref, results;
	      host.__eventStore = {};
	      ref = Observable.prototype;
	      results = [];
	      for (key in ref) {
	        fn = ref[key];
	        results.push(host[key] = fn);
	      }
	      return results;
	    };

	    Observable.prototype.on = function(topics, fn, once) {
	      var base, i, len, ref, topic;
	      if (once == null) {
	        once = false;
	      }
	      if (isPlainObject(topics)) {
	        for (topic in topics) {
	          fn = topics[topic];
	          this.on(topic, fn);
	        }
	      } else {
	        ref = toArray(topics);
	        for (i = 0, len = ref.length; i < len; i++) {
	          topic = ref[i];
	          (base = this.__eventStore)[topic] || (base[topic] = []);
	          this.__eventStore[topic].push({
	            fn: fn,
	            once: once
	          });
	        }
	      }
	      return this;
	    };

	    Observable.prototype.once = function(topics, fn) {
	      if (fn) {
	        return this.on(topics, fn, true);
	      } else {
	        return this.on(topics, true);
	      }
	    };

	    Observable.prototype.off = function(topics, fn) {
	      var i, j, len, len1, ref, ref1, topic;
	      if (!fn) {
	        ref = toArray(topics);
	        for (i = 0, len = ref.length; i < len; i++) {
	          topic = ref[i];
	          this.__eventStore[topic] = [];
	        }
	      }
	      if (isPlainObject(topics)) {
	        for (topic in topics) {
	          fn = topics[topic];
	          this.off(topic, fn);
	        }
	      } else {
	        ref1 = toArray(topics);
	        for (j = 0, len1 = ref1.length; j < len1; j++) {
	          topic = ref1[j];
	          this.__eventStore[topic] = (this.__eventStore[topic] || []).filter(function(subscriber) {
	            return subscriber.fn !== fn;
	          });
	        }
	      }
	      return this;
	    };

	    Observable.prototype.trigger = function(topic, args) {
	      var ref;
	      args || (args = []);
	      if ((ref = this.__eventStore[topic]) != null) {
	        ref.forEach((function(_this) {
	          return function(arg) {
	            var fn, once;
	            fn = arg.fn, once = arg.once;
	            if (_this.__asyncEvents) {
	              setTimeout((function() {
	                return fn.apply(null, args);
	              }), 1);
	            } else {
	              fn.apply(null, args);
	            }
	            if (once) {
	              return _this.off(topic, fn);
	            }
	          };
	        })(this));
	      }
	      return this;
	    };

	    return Observable;

	  })();

	  {
	    module.exports = Observable;
	  }

	}).call(commonjsGlobal);
	});

	var x18n_build = createCommonjsModule(function (module, exports) {
	// Copyright (c) 2012-2016 Florian Hartmann, https://github.com/florian/x18n
	// Copyright (c) 2012-2016 Florian Hartmann, https://github.com/florian/observable
	(function() {
	  var Observable, isPlainObject, isType, toArray;

	  isType = function(type, value) {
	    return Object.prototype.toString.call(value).match(/\s(\w+)/)[1].toLowerCase() === type;
	  };

	  isPlainObject = function(value) {
	    return !!value && isType('object', value);
	  };

	  toArray = function(value) {
	    if (isType('array', value)) {
	      return value;
	    } else {
	      return [value];
	    }
	  };

	  Observable = (function() {
	    function Observable() {
	      this.__eventStore = {};
	      this.__asyncEvents = true;
	    }

	    Observable.mixin = function(host) {
	      var fn, key, ref, results;
	      host.__eventStore = {};
	      ref = Observable.prototype;
	      results = [];
	      for (key in ref) {
	        fn = ref[key];
	        results.push(host[key] = fn);
	      }
	      return results;
	    };

	    Observable.prototype.on = function(topics, fn, once) {
	      var base, i, len, ref, topic;
	      if (once == null) {
	        once = false;
	      }
	      if (isPlainObject(topics)) {
	        for (topic in topics) {
	          fn = topics[topic];
	          this.on(topic, fn);
	        }
	      } else {
	        ref = toArray(topics);
	        for (i = 0, len = ref.length; i < len; i++) {
	          topic = ref[i];
	          (base = this.__eventStore)[topic] || (base[topic] = []);
	          this.__eventStore[topic].push({
	            fn: fn,
	            once: once
	          });
	        }
	      }
	      return this;
	    };

	    Observable.prototype.once = function(topics, fn) {
	      if (fn) {
	        return this.on(topics, fn, true);
	      } else {
	        return this.on(topics, true);
	      }
	    };

	    Observable.prototype.off = function(topics, fn) {
	      var i, j, len, len1, ref, ref1, topic;
	      if (!fn) {
	        ref = toArray(topics);
	        for (i = 0, len = ref.length; i < len; i++) {
	          topic = ref[i];
	          this.__eventStore[topic] = [];
	        }
	      }
	      if (isPlainObject(topics)) {
	        for (topic in topics) {
	          fn = topics[topic];
	          this.off(topic, fn);
	        }
	      } else {
	        ref1 = toArray(topics);
	        for (j = 0, len1 = ref1.length; j < len1; j++) {
	          topic = ref1[j];
	          this.__eventStore[topic] = (this.__eventStore[topic] || []).filter(function(subscriber) {
	            return subscriber.fn !== fn;
	          });
	        }
	      }
	      return this;
	    };

	    Observable.prototype.trigger = function(topic, args) {
	      var ref;
	      args || (args = []);
	      if ((ref = this.__eventStore[topic]) != null) {
	        ref.forEach((function(_this) {
	          return function(arg) {
	            var fn, once;
	            fn = arg.fn, once = arg.once;
	            if (_this.__asyncEvents) {
	              setTimeout((function() {
	                return fn.apply(null, args);
	              }), 1);
	            } else {
	              fn.apply(null, args);
	            }
	            if (once) {
	              return _this.off(topic, fn);
	            }
	          };
	        })(this));
	      }
	      return this;
	    };

	    return Observable;

	  })();

	  {
	    module.exports = Observable;
	  }

	}).call(commonjsGlobal);

	(function() {
	  var Observable, base,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty,
	    slice = [].slice,
	    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	  base = function(Observable) {
	    var X18n;
	    X18n = (function(superClass) {
	      extend(X18n, superClass);

	      function X18n() {
	        this.t = bind(this.t, this);
	        X18n.__super__.constructor.call(this);
	        this.dict = {};
	        this.defaultlocal = 'en';
	        this.chosenLocal = void 0;
	        this.availableLocales = [];
	        this.locales = [];
	        this.missingTranslations = {};
	        this.on('dict:change', (function(_this) {
	          return function() {
	            return _this.sortLocales();
	          };
	        })(this));
	      }

	      X18n.prototype.utils = {
	        merge: function(one, two) {
	          var k, results, v;
	          results = [];
	          for (k in two) {
	            v = two[k];
	            if (typeof v === 'object' && typeof one[k] === 'object') {
	              results.push(this.merge(one[k], v));
	            } else {
	              results.push(one[k] = v);
	            }
	          }
	          return results;
	        },
	        filter: function(arr, fn) {
	          var i, len, results, v;
	          results = [];
	          for (i = 0, len = arr.length; i < len; i++) {
	            v = arr[i];
	            if (fn(v)) {
	              results.push(v);
	            }
	          }
	          return results;
	        },
	        unique: function(arr) {
	          var i, k, len, results, ret, v;
	          ret = {};
	          for (i = 0, len = arr.length; i < len; i++) {
	            v = arr[i];
	            ret[v] = v;
	          }
	          results = [];
	          for (k in ret) {
	            v = ret[k];
	            results.push(v);
	          }
	          return results;
	        },
	        getByDotNotation: function(obj, key) {
	          var keys;
	          keys = key.split('.');
	          while (!(keys.length === 0 || obj === void 0)) {
	            obj = obj[keys[0]];
	            keys.shift();
	          }
	          return obj;
	        },
	        isPlainObject: function(value) {
	          return !!value && Object.prototype.toString.call(value) === '[object Object]';
	        }
	      };

	      X18n.prototype.register = function(local, dict) {
	        if (!(local in this.dict)) {
	          this.dict[local] = {};
	          this.availableLocales.push(local);
	        }
	        this.utils.merge(this.dict[local], dict);
	        return this.trigger('dict:change', [local]);
	      };

	      X18n.prototype.set = function(local) {
	        this.chosenLocal = local;
	        return this.sortLocales();
	      };

	      X18n.prototype.setDefault = function(local) {
	        this.defaultLocal = local;
	        return this.sortLocales();
	      };

	      X18n.prototype.detectLocal = function() {
	        return navigator.userLanguage || navigator.language;
	      };

	      X18n.prototype.similiarLocales = function(local) {
	        local = String(local).slice(0, 2).toLowerCase();
	        return this.utils.filter(this.availableLocales, function(l) {
	          if (local === l) {
	            return false;
	          }
	          return l.toLowerCase().indexOf(local) === 0;
	        });
	      };

	      X18n.prototype.sortLocales = function() {
	        var _locales, i, len, local, locales, oldLocales;
	        oldLocales = this.locales.slice();
	        _locales = [this.chosenLocal].concat(slice.call(this.similiarLocales(this.chosenLocal)), [this.detectLocal()], slice.call(this.similiarLocales(this.detectLocal())), [this.defaultLocal], slice.call(this.similiarLocales(this.defaultlocal)), ['en'], slice.call(this.similiarLocales('en')));
	        locales = [];
	        for (i = 0, len = _locales.length; i < len; i++) {
	          local = _locales[i];
	          if (indexOf.call(this.availableLocales, local) >= 0) {
	            locales.push(local);
	          }
	        }
	        locales.push.apply(locales, this.availableLocales);
	        this.locales = this.utils.unique(locales);
	        if (oldLocales.join(',') !== this.locales.join(',')) {
	          return this.trigger('lang:change', [this.locales, oldLocales]);
	        }
	      };

	      X18n.prototype.interpolate = function() {
	        var interpolation, str;
	        str = arguments[0], interpolation = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	        if (this.utils.isPlainObject(interpolation[0])) {
	          str = str.replace(/%\{([^}]+)\}/g, function(_, key) {
	            return interpolation[0][key];
	          });
	        } else {
	          str = str.replace(/%(\d+)/g, function(_, n) {
	            return interpolation[Number(n) - 1];
	          });
	        }
	        return str;
	      };

	      X18n.prototype.t = function() {
	        var i, interpolation, key, len, local, ref, tr;
	        key = arguments[0], interpolation = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	        tr = void 0;
	        ref = this.locales;
	        for (i = 0, len = ref.length; i < len; i++) {
	          local = ref[i];
	          tr = this.utils.getByDotNotation(this.dict[local], key);
	          if (tr) {
	            break;
	          } else {
	            if (!(local in this.missingTranslations)) {
	              this.missingTranslations[local] = [];
	            }
	            this.missingTranslations[local].push(key);
	            this.missingTranslations[local] = this.utils.unique(this.missingTranslations[local]);
	            this.trigger('missing-translation', [local, key]);
	          }
	        }
	        if (typeof tr === 'string') {
	          tr = this.interpolate.apply(this, [tr].concat(slice.call(interpolation)));
	        } else if (tr !== void 0) {
	          tr.plural = (function(_this) {
	            return function(n) {
	              if (n in tr) {
	                return tr[n];
	              } else {
	                return _this.interpolate(tr.n, n);
	              }
	            };
	          })(this);
	        }
	        return tr;
	      };

	      return X18n;

	    })(Observable);
	    return new X18n();
	  };

	  if (( module !== null) && (module.exports != null)) {
	    Observable = observable;
	    module.exports = base(Observable);
	  } else {
	    window.x18n = base(window.Observable);
	  }

	}).call(commonjsGlobal);
	});

	const settings = {
		title: "Settings",
		survey: {
			header: "Survey",
			caption: "File"
		},
		view: {
			header: "View",
			camera: {
				caption: "Camera type",
				orthographic: "Orthographic",
				perspective: "Perspective",
				anaglyph: "Anaglyph"
			},
			viewpoints: {
				caption: "Viewpoint",
				none: "<select viewpoint>",
				plan: "Plan",
				elevation_n: "N Elevation",
				elevation_s: "S Elevation",
				elevation_e: "E Elevation",
				elevation_w: "W Elevation"
			},
			eye_separation: "Eye Separation",
			vertical_scaling: "Vertical Scaling",
			autorotate: "Auto Rotate",
			rotation_speed: "Rotation Speed"
		},
		shading: {
			header: "Shading",
			caption: "Underground legs",
			height: "by height",
			length: "by leg length",
			inclination: "by leg inclination",
			height_cursor: "height cursor",
			fixed: "fixed",
			survey: "survey",
			route: "route",
			depth: "depth",
			depth_cursor: "depth cursor",
			distance: "distance",
			beck: "beck"
		},
		selected_route: "Selected route",
		no_routes: "no routes defined",
		visibility: {
			header: "Visibility",
			legs: "Center lines",
			entrances: "Entrance labels",
			entrance_dots: "Entrance dots",
			stations: "Stations",
			labels: "Station Labels",
			comments: "Station Comments",
			walls: "Walls (LRUD)",
			scraps: "Scraps",
			splays: "Splay Legs",
			traces: "Dye Traces",
			warnings: "Warnings",
			box: "Bounding box",
			hud: "Indicators",
			fog: "Fog"
		},
		controls: {
			header: "Controls",
			svx_control_mode: "'Aven' controls",
			zoom_to_cursor: "Zoom to cursor",
			wheel_tilt: "Mouse wheel - tilt"
		},
		ui: {
			selection_tree: "Use tree selection"
		},
		colors: {
			header: "Colours",
			background_color: "Background",
			entrance_text: "Entrance text",
			entrance_background: "Entrance background",
			entrance_marker: "Entrance marker",
			bounding_box: "Bounding box",
			legs_fixed: "Passage lines (fixed)",
			surface_fixed: "Surface lines (fixed)",
			hud_text: "Scale text",
			defaults: "Restore default colours"
		}
	};
	const surface = {
		title: "Surface",
		surface: {
			header: "Surface Features",
			legs: "Surface Legs",
			shading: {
				caption: "Shading",
				height: "by height",
				inclination: "by inclination",
				height_cursor: "height cursor",
				fixed: "fixed"
			}
		},
		terrain: {
			header: "Terrain",
			terrain: "Terrain visible",
			shading: {
				caption: "Shading",
				relief: "relief shading",
				height: "by height",
				overlay: "map overlay",
				contours: "contours"
			},
			overlay: {
				caption: "Overlay"
			},
			opacity: "Opacity",
			datum_shift: "Vertical datum shift",
			lighting: "Directional Lighting",
			downloadTileSet: "download tile set spec"
		}
	};
	const selection = {
		title: "Selection",
		header: "Selection"
	};
	const edit = {
		title: "Edit",
		mode: "edit mode",
		modes: {
			none: "- none -",
			route: "Routes",
			trace: "Traces",
			entrances: "Entrances"
		},
		entrance: {
			header: "Entrances"
		},
		route: {
			header: "Routes",
			current: "Current route",
			save: "Save",
			"new": "New route",
			add: "Add",
			download: "Download"
		},
		trace: {
			header: "Traces"
		}
	};
	const info = {
		title: "Information",
		header: "Information",
		stats: {
			header: "Survey Stats",
			legs: "Leg count",
			totalLength: "Total length",
			minLength: "Shortest leg",
			maxLength: "Longest leg"
		}
	};
	const help = {
		title: "Help",
		header_svx: "Key commands (survex)",
		header_native: "Key commands (native)",
		shading: {
			header: "Shading",
			height: "height",
			inclination: "leg inclination",
			length: "leg length",
			height_cursor: "height cursor",
			single: "single colour",
			survey: "survey section",
			route: "route",
			depth: "depth below surface",
			depth_cursor: "depth cursor",
			cursor_up: "move cursor up",
			cursor_down: "move cursor down",
			distance: "distance"
		},
		view: {
			header: "View",
			full_screen: "toggle full screen",
			orthogonal: "orthogonal view",
			perspective: "perspective view",
			reset: "reset to inital view",
			center: "center on selected feature",
			next: "next cave",
			plan: "plan",
			elevation: "elevation",
			north: "face north",
			east: "face east",
			south: "face south",
			west: "face west",
			rotate_clockwise: "rotate clockwise",
			rotate_anticlockwise: "rotate anticlockwise",
			zoom_in: "zoom in",
			zoom_out: "zoom out",
			auto_rotate: "rotate continuosly",
			rotate_speed_up: "increase speed of rotation",
			rotate_speed_down: "decrease speed of rotation",
			reverse_rotation: "reverse direction of rotation",
			zoom_to_cursor: "toggle zoom to cursor mode",
			control_mode: "toggle control mode",
			decrease_focal_length: "decrease focal length",
			increase_focal_length: "increase focal length"
		},
		visibility: {
			header: "Visibility",
			scraps: "scraps on/off [lox only]",
			station_labels: "station labels on/off",
			entrance_labels: "entrancel abels on/off",
			splays: "splay legs on/off",
			survey: "underground legs on/off",
			surface: "surface legs on/off",
			terrain: "terrain on/off",
			walls: "LRUD walls on/off",
			stations: "station markers on/off",
			opacity_down: "decrease terrain opacity",
			opacity_up: "increase terrain opacity"
		},
		selection: {
			header: "Selection",
			remove: "remove all except selected section"
		}
	};
	const exports$4 = {
		title: "Exports",
		gltf_export: {
			header: "glTF Export",
			walls: "include LRUD walls",
			scraps: "include scraps",
			legs: "include centre lines",
			rotate_axes: "rotate axes",
			"export": "Download"
		},
		png_export: {
			header: "Image (PNG) Export",
			"export": "Snapshot",
			size: "Size (px)",
			line_scale: "Line scale"
		}
	};
	const hud = {
		height: "height",
		leg_length: "leg length",
		depth: "depth",
		inclination: "inclination"
	};
	const dnd = {
		splash_text: "Drag&nbsp;and&nbsp;drop a .3d or .lox model here to&nbsp;load"
	};
	var lang_en = {
		settings: settings,
		surface: surface,
		selection: selection,
		edit: edit,
		info: info,
		help: help,
		exports: exports$4,
		hud: hud,
		dnd: dnd
	};

	const defaultTheme = {
		fieldOfView: 50,
		background: 'black',
		sky: 0x106f8d,
		maxPolarAngle: 180,
		saturatedGradient: false,
		lighting: {
			azimuth: 315,
			inclination: 45
		},
		hud: {
			font: 'normal Arial, sans-serif',
			text: 'white',
			progress: 'green',
			progressBackground: 'dimgray',
			bezel: 'gray',
			widgetSize: 40,
			scale: {
				bar1: 'white',
				bar2: 'red',
			},
			compass: {
				top1: 0xb03a14,
				top2: 0x1ab4e5,
				bottom1: 0x581d0a,
				bottom2: 0x0c536a
			},
			ahi: {
				sky: 0x106f8d,
				earth: 0x802100,
				bar: 'yellow',
				marks: 'white'
			},
			cursor: 'yellow'
		},
		box: {
			bounding: 'white',
			select: 'blue',
			highlight: 'red'
		},
		routes: {
			active: 'yellow',
			adjacent: 'red',
			default: 'gray'
		},
		stations: {
			font: 'normal Arial, sans-serif',
			entrances: {
				text: 'white',
				background: 'darkred',
				marker: 'white'
			},
			junctions: {
				text: 'yellow',
				marker: 'yellow'
			},
			default: {
				text: 'white',
				marker: 'red'
			}
		},
		shading: {
			single: 'red',
			surface: 'yellow',
			cursor: 'yellow',
			cursorBase: 'gray',
			unselected: 'gray',
			contours: {
				line: 0xe1bba2,
				line10: 0xf29d62,
				interval: 10,
				base: 'white'
			},
			/*
			hypsometric: {
				min: 0,
				max: 400
			},
			*/
			unconnected: 'gray'
		},
		popup: {
			text: 'white',
			border: 'white',
			background: 0x111111
		}
	};

	// setup default language

	x18n_build.register( 'en', lang_en );
	x18n_build.set( 'en' );

	function Cfg ( envs ) {

		this.environment = new Map();
		this.themeColors = new Map();
		this.i18n = x18n_build.t;

		if ( envs === undefined ) return;

		var pName;

		for ( pName in envs ) {

			this.environment.set ( pName , envs[ pName ] );

		}

		if ( Cfg.home !== undefined ) this.environment.set( 'home', Cfg.home );

		this.setLanguage( this.value( 'language', navigator.language.slice( 0, 2 ) ) );

	}

	if ( document.currentScript !== undefined ) {

		Cfg.home = document.currentScript.src.match( /^(.*\/)js\// )[ 1 ];

	}

	Cfg.prototype = Object.create( EventDispatcher.prototype );

	Cfg.prototype.setLanguage = function ( lang ) {

		console.log( 'home:', Cfg.home );

		if ( lang === 'en' ) {

			x18n_build.set( 'en' );

		} else {

			// attempt to register non-default language

			console.log( 'loading language file for:', lang );

			const loader = new FileLoader().setPath( this.value( 'home' ) + 'lib/' );

			loader.load( 'lang-' + lang + '.json', _languageLoaded, null, _languageError );

		}

		const self = this;

		x18n_build.on( [ 'lang:change' ], function () { self.dispatchEvent( { type: 'change', name: 'language' } ); } );

		return;

		function _languageLoaded ( response ) {

			console.log( 'loaded language [' + lang + ']' );

			x18n_build.register( lang, JSON.parse( response ) );
			x18n_build.set( lang );

		}

		function _languageError () {

			console.log( 'error loading language file', lang );

		}

	};

	Cfg.prototype.value = function ( item, defaultValue ) {

		if ( this.environment.has( item ) ) {

			return this.environment.get( item );

		} else {

			return defaultValue;

		}

	};

	Cfg.prototype.setPropertyValue = function ( item, defaultValue ) {

		// set to defined value or default
		this.environment.set ( item, this.value( item, defaultValue ) );

		Object.defineProperty( this, item, {

			set: function ( value ) {

				this.environment.set ( item, value );
				this.dispatchEvent( { type: 'change', name: item } );

			},
			get: function () {
				return this.environment.get( item ); }
		} );

	};


	Cfg.prototype.themeValue = function ( name ) {

		const theme = this.environment.get( 'theme' );

		const parts = name.split( '.' );
		var value;

		if ( theme !== undefined ) {

			value = this.treeValue( theme, parts );

		}

		if ( value === undefined ) {

			value = this.treeValue( defaultTheme, parts);

		}

		return value;


	};

	Cfg.prototype.themeAngle = function ( name ) {

		return MathUtils.degToRad( this.themeValue ( name ) );

	};

	Cfg.prototype.treeValue = function ( theme, parts ) {

		var i;
		var top = theme;
		var part;

		for ( i = 0; i < parts.length; i++ ) {

			part = parts[ i ];

			if ( top[ part ] === undefined ) return undefined;

			top = top[ part ];

		}

		return top;

	};

	Cfg.prototype.themeColorCSS = function ( name ) {

		return this.themeColor( name ).getStyle();

	};

	Cfg.prototype.themeColor = function ( name ) {

		var color = this.themeColors.get( name );

		if ( color === undefined ) {

			var savedColorName = window.localStorage.getItem( 'cv-color:' + name );

			color = new Color( savedColorName ? savedColorName : this.themeValue( name ) );
			this.themeColors.set( name, color );

		}

		return color;

	};

	Cfg.prototype.themeColorHex = function ( name ) {

		return '#' + this.themeColor( name ).getHexString();

	};

	Cfg.prototype.setThemeColorCSS = function ( name, color ) {

		const ls = window.localStorage;
		const c = new Color( color );

		this.themeColors.set( name, c );
		ls.setItem( 'cv-color:' + name, '#' + c.getHexString() );

		this.dispatchEvent( { type: 'colors', name: name } );

	};

	Cfg.prototype.resetColors = function () {

		this.themeColors.clear();
		window.localStorage.clear();

		this.dispatchEvent( { type: 'colors', name: 'all' } );

	};

	function WorkerPool ( script ) {

		this.script = script;
		this.workers = [];
		this.activeWorkers = new Set();

	}

	const cpuCount = window.navigator.hardwareConcurrency;

	WorkerPool.maxActive = cpuCount === undefined ? 4 : cpuCount;

	WorkerPool.pendingWork = [];
	WorkerPool.activeWorkers = 0;

	WorkerPool.prototype.terminateActive = function () {

		const activeWorkers = this.activeWorkers;

		activeWorkers.forEach( function ( worker ) { worker.terminate(); } );
		activeWorkers.clear();

		// FIXME clear all pending work for this pool

	};

	WorkerPool.prototype.getWorker = function () {

		var worker;

		if ( this.workers.length === 0 ) {

			worker = new Worker( this.script );

		} else {

			worker = this.workers.pop();

		}

		this.activeWorkers.add( worker );

		return worker;

	};

	WorkerPool.prototype.putWorker = function ( worker ) {

		this.activeWorkers.delete( worker );

		if ( this.workers.length < 4 ) {

			this.workers.push( worker );

		} else {

			worker.terminate();

		}

		const pendingWork = WorkerPool.pendingWork;

		if ( pendingWork.length > 0 ) {

			const pending = pendingWork.shift();

			// resubit to orginal pool

			pending.pool.queueWork( pending.message, pending.callback );

		}

	};

	WorkerPool.prototype.runWorker = function ( message, callback ) {

		WorkerPool.activeWorkers++;

		const worker = this.getWorker();

		worker.onmessage = callback;
		worker.postMessage( message );

		return worker;

	};

	WorkerPool.prototype.queueWork = function ( message, callback ) {

		if ( WorkerPool.activeWorkers === WorkerPool.maxActive ) {

			WorkerPool.pendingWork.push( { pool: this, message: message, callback: callback } );
			return;

		}

		this.runWorker( message, callback );

	};

	WorkerPool.prototype.dispose = function () {

		this.workers.forEach( function ( worker) {

			worker.terminate();

		} );

		this.workers = null;
		this.activeWorkers = null;

	};

	function WorkerPoolCache ( cfg ) {

		const pools = new Map();

		this.getPool = function ( scriptFile ) {

			var script = cfg.value( 'home', '' ) + 'js/workers/' + scriptFile;

			var pool = pools.get( script );

			if ( pool === undefined ) {

				// no existing pool
				pool = new WorkerPool( script );
				pools.set( script, pool );

			}

			return pool;

		};

		this.terminateActive = function () {

			pools.forEach( function ( pool) { pool.terminateActive(); } );

		};

		this.dispose = function () {

			pools.forEach( function ( pool ) {

				pool.terminateActive();
				pool.dispose();

			} );

			pools.clear();

		};

	}

	const defaultView = {
		autoRotate: false,
		autoRotateSpeed: 0.5,
		box: true,
		cameraType: CAMERA_PERSPECTIVE,
		view: VIEW_PLAN,
		editMode: MOUSE_MODE_NORMAL,
		shadingMode: SHADING_HEIGHT,
		surfaceShading: SHADING_HEIGHT,
		terrainShading: SHADING_RELIEF,
		terrainDirectionalLighting: true,
		terrainOpacity: 0.5,
		terrainDatumShift: false,
		surfaceLegs: false,
		walls: false,
		scraps: false,
		splays: false,
		stations: false,
		stationLabels: false,
		entrances: true,
		entrance_dots: true,
		terrain: false,
		traces: false,
		HUD: true,
		fog: false,
		warnings: false,
		fullscreen: false
	};

	const dynamicView = {
		autoRotate: false,
		walls: true,
		scraps: true,
		box: false,
		terrain: true,
		terrainOpacity: 1,
		terrainDatumShift: true,
		terrainThrough: TERRAIN_BLEND,
		terrainShading: SHADING_LOCATION
	};

	function ViewState ( viewer ) {

		const enumerableProperties = Object.keys( viewer );
		const properties = [];

		Object.getOwnPropertyNames( viewer ).forEach( function ( name ) {

			if ( enumerableProperties.includes( name ) ) return;

			const pDesc = Object.getOwnPropertyDescriptor( viewer, name );

			if ( pDesc.set !==undefined && pDesc.get !== undefined ) {

				properties.push( name );

			}

		} );

		this.saveState = function () {

			const savedState = {};

			properties.forEach( function ( name ) {

				const value = viewer[ name ];

				if ( typeof value === 'object' ) return;

				savedState[ name ] = value;

			} );

			return savedState;

		};

	}

	/**
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author erich666 / http://erichaines.com
	 */

	const MODE_LOCK_UNLOCKED = 0;
	const MODE_LOCK_ROTATE = 1;
	const MODE_LOCK_ZOOM = 2;
	const SVX_DELTA = Math.PI / 60;

	const __v$2 = new Vector3();

	function OrbitControls ( cameraManager, domElement, viewer ) {

		this.cameraManager = cameraManager;

		const element = domElement;

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		this.zoomSpeed = 1.0;
		this.zoomToCursor = false;

		// Set to false to disable panning
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

		// Set to false to disable use of the keys
		this.enableKeys = true;

		// The four arrow keys
		this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

		// mouse wheel mode
		this.wheelTilt = false;

		// for reset

		const camera = cameraManager.activeCamera;

		this.target0 = this.target.clone();
		this.position0 = camera.position.clone();
		this.zoom0 = camera.zoom;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.rotateUp = function ( angle ) {

			rotateUp( angle );
			this.update();

		};

		this.rotateLeft = function ( angle ) {

			rotateLeft( angle );
			this.update();

		};

		this.scaleDolly = function ( scaleFactor ) {

			scale *= scaleFactor;
			this.update();

		};

		this.saveState = function () {

			const camera = cameraManager.activeCamera;

			scope.target0.copy( scope.target );
			scope.position0.copy( camera.position );
			scope.zoom0 = camera.zoom;

		};

		this.reset = function () {

			const camera = cameraManager.activeCamera;

			scope.target.copy( scope.target0 );
			camera.position.copy( scope.position0 );
			camera.zoom = scope.zoom0;

			camera.updateProjectionMatrix();
			scope.dispatchEvent( changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			var offset = new Vector3();
			const up = cameraManager.activeCamera.up;

			// so camera.up is the orbit axis
			var quat = new Quaternion().setFromUnitVectors( up, new Vector3( 0, 1, 0 ) );
			var quatInverse = quat.clone().invert();

			var lastPosition = new Vector3();
			var lastQuaternion = new Quaternion();

			return function update() {

				var camera = cameraManager.activeCamera;
				var target = scope.target;
				var position = camera.position;

				offset.copy( position ).sub( target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

				spherical.theta += sphericalDelta.theta;
				spherical.phi += sphericalDelta.phi;

				// restrict theta to be between desired limits
				spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();

				var prevRadius = Math.max( spherical.radius, EPS );
				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location
				target.add( panOffset );

				// suport zoomToCursor (mouse only)

				if ( scope.zoomToCursor ) {

					if ( camera.isPerspectiveCamera ) {

						scope.target.lerp( mouse3D, 1 - spherical.radius / prevRadius );

					} else if ( camera.isOrthographicCamera ) {

						scope.target.lerp( mouse3D, 1 - zoomFactor );

					}

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( target ).add( offset );

				camera.lookAt( target );

				sphericalDelta.set( 0, 0, 0 );
				panOffset.set( 0, 0, 0 );

				scale = 1;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( camera.quaternion ) ) > EPS ) {

					scope.dispatchEvent( changeEvent );

					lastPosition.copy( position );
					lastQuaternion.copy( camera.quaternion );
					zoomChanged = false;
					zoomFactor = 1;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			element.removeEventListener( 'contextmenu', onContextMenu, false );
			element.removeEventListener( 'mousedown', onMouseDown, false );
			element.removeEventListener( 'wheel', onMouseWheel, false );

			element.removeEventListener( 'touchstart', onTouchStart, false );
			element.removeEventListener( 'touchend', onTouchEnd, false );
			element.removeEventListener( 'touchmove', onTouchMove, false );

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			element.removeEventListener( 'keydown', onKeyDown, false );

		};

		this.end = function () {

			scope.dispatchEvent( endEvent );

		};

		Object.defineProperty( this, 'svxControlMode', {
			set: setControlMode,
			get: function () { return svxControlMode; }

		});

		//
		// internals
		//

		var scope = this;

		var changeEvent = { type: 'change' };
		var startEvent = { type: 'start' };
		var endEvent = { type: 'end' };

		const LEFT_BUTTON = 1;
		const RIGHT_BUTTON = 2;
		const MIDDLE_BUTTON = 4;
		const EMULATED_MIDDLE_BUTTON = 3;

		var buttons = 0;
		var lastButtonDownTime = 0;

		const STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };

		var state = STATE.NONE;

		var EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new Spherical();
		const sphericalDelta = new Spherical();

		var scale = 1;
		var panOffset = new Vector3();
		var zoomChanged = false;
		var zoomFactor = 1;

		const rotateStart = new Vector2();
		const rotateEnd = new Vector2();
		const rotateDelta = new Vector2();

		const panStart = new Vector2();
		const panEnd = new Vector2();
		const panDelta = new Vector2();

		const dollyStart = new Vector2();
		const dollyEnd = new Vector2();
		const dollyDelta = new Vector2();

		const mouse3D = new Vector3();
		const mouseStart = new Vector3();

		var firstWheelMove = true;

		var svxStart = new Vector2();
		var svxEnd = new Vector2();
		var svxDelta = new Vector2();

		var modeLock = MODE_LOCK_UNLOCKED;
		var lastMoveTime = 0;
		var svxReverseSense = -1;

		var svxControlMode  = false;

		// mode specific handlers

		var handleMouseDownLeft;
		var handleMouseDownMiddle;
		var handleMouseMoveLeft;
		var handleMouseMoveMiddle;


		function setControlMode ( svxMode ) {

			if ( svxMode ) {

				handleMouseDownLeft = handleMouseDownSvx;
				handleMouseDownMiddle = handleMouseDownRotate;
				handleMouseMoveLeft = handleMouseMoveSvxLeft;
				handleMouseMoveMiddle = handleMouseMoveSvxMiddle;

			} else {

				handleMouseDownLeft = handleMouseDownRotate;
				handleMouseDownMiddle = handleMouseDownDolly;
				handleMouseMoveLeft = handleMouseMoveRotate;
				handleMouseMoveMiddle = handleMouseMoveDolly;

			}

			svxControlMode = svxMode;

		}

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		var panLeft = function ( distance, objectMatrix ) {

			distance *= svxReverseSense;

			__v$2.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
			__v$2.multiplyScalar( distance );

			panOffset.add( __v$2 );

		};


		var panUp = function ( distance, objectMatrix ) {

			distance *= svxReverseSense;

			__v$2.setFromMatrixColumn( objectMatrix, 1 );
			__v$2.multiplyScalar( - distance );

			panOffset.add( __v$2 );

		};

		// deltaX and deltaY are in pixels; right and down are positive
		var pan = function ( deltaX, deltaY ) {

			const camera = cameraManager.activeCamera;

			if ( camera.isPerspectiveCamera ) {

				// perspective
				__v$2.copy( camera.position ).sub( scope.target );

				var targetDistance = __v$2.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan( ( camera.fov / 2 ) * Math.PI / 180.0 );

				// we use only clientHeight here so aspect ratio does not distort speed
				panLeft( 2 * deltaX * targetDistance / element.clientHeight, camera.matrix );
				panUp( 2 * deltaY * targetDistance / element.clientHeight, camera.matrix );

			} else if ( camera.isOrthographicCamera ) {

				// orthographic
				panLeft( deltaX * ( camera.right - camera.left ) / ( camera.zoom * element.clientWidth ), camera.matrix );
				panUp( deltaY * ( camera.top - camera.bottom ) / ( camera.zoom * element.clientHeight ), camera.matrix );

			}

		};

		function dollyIn( dollyScale ) {

			const camera = cameraManager.activeCamera;

			if ( camera.isPerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( camera.isOrthographicCamera ) {

				zoomFactor = camera.zoom;
				camera.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, camera.zoom * dollyScale ) );
				zoomFactor /= camera.zoom;
				camera.updateProjectionMatrix();
				zoomChanged = true;

			}

		}

		function dollyOut( dollyScale ) {

			const camera = cameraManager.activeCamera;

			if ( camera.isPerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( camera.isOrthographicCamera ) {

				zoomFactor = camera.zoom;
				camera.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, camera.zoom / dollyScale ) );
				zoomFactor /= camera.zoom;
				camera.updateProjectionMatrix();
				zoomChanged = true;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownSvx( event ) {

			svxStart.set( event.clientX, event.clientY );

			modeLock = MODE_LOCK_UNLOCKED;

		}

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}


		function handleMouseDownDolly( event ) {

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function rotateSvx() {

			rotateStart.copy( svxStart );
			rotateLeft( 2 * Math.PI * svxDelta.x * svxReverseSense / element.clientWidth );
			rotateStart.copy( svxEnd );

			scope.update();

		}

		function zoomSvx( event ) {

			dollyStart.copy( svxStart );
			handleMouseMoveDolly( event, svxReverseSense );

		}

		function handleMouseMoveSvxLeft( event ) {

			svxEnd.set( event.clientX, event.clientY );

			svxDelta.subVectors( svxEnd, svxStart );

			const now = performance.now();

			if ( now > lastMoveTime + 1000 ) modeLock = MODE_LOCK_UNLOCKED;

			lastMoveTime = now;

			const deltaX2 = svxDelta.x * svxDelta.x;
			const deltaY2 = svxDelta.y * svxDelta.y;

			switch ( modeLock ) {

			case MODE_LOCK_UNLOCKED:

				if ( Math.abs( svxDelta.x ) > Math.abs( svxDelta.y ) ) {

					modeLock = MODE_LOCK_ROTATE;

				} else {

					modeLock = MODE_LOCK_ZOOM;

				}

				break;

			case MODE_LOCK_ROTATE:

				if ( deltaY2 > 8 * deltaX2 ) modeLock = MODE_LOCK_ZOOM;

				break;

			case MODE_LOCK_ZOOM:

				if ( deltaX2 > 8 * deltaY2 ) modeLock = MODE_LOCK_ROTATE;

				break;

			}

			if ( modeLock === MODE_LOCK_ROTATE ) {

				rotateSvx();

			} else {

				zoomSvx( event );

			}

			svxStart.copy( svxEnd );

		}

		function handleMouseMoveSvxMiddle( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y * svxReverseSense / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart );

			// rotating across whole screen goes 360 degrees around
			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event, sense ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			dollyDelta.y *= sense;

			updateMouse3D( event.clientX, event.clientY );

			if ( dollyDelta.y > 0 ) {

				dollyIn( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyOut( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		var updateMouse3D = function () {

			const v = new Vector3();
			const v1 = new Vector3();

			return function updateMouse3D( x, y ) {

				const camera = cameraManager.activeCamera;
				const up = camera.up;

				var distance;

				// get mouse in ndc
				const mouse = cameraManager.getMouse( x, y );

				if ( firstWheelMove || mouseStart.x != mouse.x || mouseStart.y != mouse.y ) {

					const station = viewer.getStation( mouse );

					if ( station !== null ) station.project( camera );

					mouseStart.set( mouse.x, mouse.y, station == null ? 0.5 : station.z );
					firstWheelMove = false;

				}

				if ( camera.isPerspectiveCamera ) {

					v.set( mouse.x, mouse.y, mouseStart.z );

					v.unproject( camera );

					v.sub( camera.position ).normalize();

					distance = v1.copy( scope.target ).sub( camera.position ).dot( up ) / v.dot( up );

					mouse3D.copy( camera.position ).add( v.multiplyScalar( distance ) );

				} else if ( camera.isOrthographicCamera ) {

					v.set( mouse.x, mouse.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) );

					v.unproject( camera );

					v1.set( 0, 0, - 1 ).applyQuaternion( camera.quaternion );

					distance = - v.dot( up ) / v1.dot( up );

					mouse3D.copy( v ).add( v1.multiplyScalar( distance ) );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type.' );

				}

			};

		}();

		function handleMouseWheel( event ) {

			const deltaY = event.deltaY;

			if ( scope.wheelTilt ) {

				// rotating up and down along whole screen attempts to go 360, but limited to 180
				rotateUp( 2 * Math.PI * deltaY / 12500 );

			} else {

				updateMouse3D( event.clientX, event.clientY );

				if ( deltaY < 0 ) {

					dollyOut( getZoomScale() );

				} else if ( deltaY > 0 ) {

					dollyIn( getZoomScale() );

				}

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			switch ( event.keyCode ) {

			case scope.keys.UP:
				pan( 0, scope.keyPanSpeed );
				scope.update();
				break;

			case scope.keys.BOTTOM:
				pan( 0, - scope.keyPanSpeed );
				scope.update();
				break;

			case scope.keys.LEFT:
				pan( scope.keyPanSpeed, 0 );
				scope.update();
				break;

			case scope.keys.RIGHT:
				pan( - scope.keyPanSpeed, 0 );
				scope.update();
				break;

			case 67: // 'C'

				if ( ! svxControlMode ) break;

				rotateLeft( - SVX_DELTA );
				scope.update();
				break;

			case 82: // 'R'

				if ( ! svxControlMode || ! event.ctrlKey ) break;
				event.preventDefault();
				svxReverseSense *= -1;
				break;

			case 86: // 'V'

				if ( ! svxControlMode ) break;
				rotateLeft( SVX_DELTA );
				scope.update();
				break;

			case 191: // '/

				if ( ! svxControlMode ) break;
				rotateUp( -SVX_DELTA );
				scope.update();
				break;

			case 192: // '''

				if ( ! svxControlMode ) break;
				rotateUp( SVX_DELTA );
				scope.update();
				break;

			case 219: // '['

				if ( ! svxControlMode ) break;
				dollyOut( getZoomScale() );
				scope.update();
				break;

			case 221: // ']'

				if ( ! svxControlMode ) break;
				dollyIn( getZoomScale() );
				scope.update();
				break;

			}

		}

		function handleTouchStartRotate( event ) {

			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		}

		function handleTouchStartDollyPan( event ) {

			const dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			const dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

			const x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			const y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			updateMouse3D( x, y );

			panStart.set( x, y );

		}

		function handleTouchMoveRotate( event ) {

			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			rotateDelta.subVectors( rotateEnd, rotateStart );

			// rotating across whole screen goes 360 degrees around
			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleTouchMoveDollyPan( event ) {

			const dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			const dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyIn( dollyDelta.y );

			dollyStart.copy( dollyEnd );

			const x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
			const y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

			updateMouse3D( x, y );

			panEnd.set( x, y );

			panDelta.subVectors( panEnd, panStart );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function setButtons( button ) {

			// add to current buttons depressed set
			// allows emulation of 3rd button in absence of event.buttons

			var newButtons = 0;

			switch ( button ) {

			case MOUSE.LEFT:

				newButtons = LEFT_BUTTON;
				break;

			case MOUSE.MIDDLE:

				newButtons = MIDDLE_BUTTON;
				break;

			case MOUSE.RIGHT:

				newButtons = RIGHT_BUTTON;
				break;

			}

			var now = performance.now();

			if ( now - lastButtonDownTime < 100 ) {

				buttons |= newButtons;

			} else {

				buttons = newButtons;

			}

			lastButtonDownTime = now;

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onMouseDown( event ) {

			if ( scope.enabled === false ) return;
			event.preventDefault();

			setButtons( event.button );

			switch ( buttons ) {

			case LEFT_BUTTON:

				handleMouseDownLeft( event );

				state = STATE.ROTATE;

				break;

			case MIDDLE_BUTTON:
			case EMULATED_MIDDLE_BUTTON:

				handleMouseDownMiddle( event );

				state = STATE.DOLLY;

				break;

			case RIGHT_BUTTON:

				handleMouseDownPan( event );

				element.style.cursor = 'all-scroll';

				state = STATE.PAN;

				break;

			}

			if ( state !== STATE.NONE ) {

				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'mouseup', onMouseUp, false );

				scope.dispatchEvent( startEvent );

			}

			firstWheelMove = true;

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			switch ( state ) {

			case STATE.ROTATE:

				handleMouseMoveLeft( event );

				break;

			case STATE.DOLLY:

				handleMouseMoveMiddle( event, 1 );

				break;

			case STATE.PAN:

				handleMouseMovePan( event );

				break;

			}

			firstWheelMove = true;

		}

		function onMouseUp( /* event */ ) {

			if ( scope.enabled === false ) return;

			element.style.cursor = 'default';

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			scope.dispatchEvent( endEvent );

			state = STATE.NONE;
			buttons = 0;

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

			event.preventDefault();
			event.stopPropagation();

			scope.dispatchEvent( startEvent );

			handleMouseWheel( event );

			scope.dispatchEvent( endEvent );

		}

		function onKeyDown( event ) {

			event.preventDefault();

			if ( scope.enabled === false || scope.enableKeys === false ) return;
			if ( ! viewer.mouseOver ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			switch ( event.touches.length ) {

			case 1:	// one-fingered touch: rotate

				handleTouchStartRotate( event );

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:	// two-fingered touch: dolly-pan

				handleTouchStartDollyPan( event );

				state = STATE.TOUCH_DOLLY_PAN;

				break;

			default:

				state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( startEvent );

			}

		}

		function onTouchMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			switch ( event.touches.length ) {

			case 1: // one-fingered touch: rotate

				if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?

				handleTouchMoveRotate( event );

				break;

			case 2: // two-fingered touch: dolly-pan

				if ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed?

				handleTouchMoveDollyPan( event );

				break;

			default:

				state = STATE.NONE;

			}

		}

		function onTouchEnd( /* event */ ) {

			if ( scope.enabled === false ) return;

			scope.dispatchEvent( endEvent );

			state = STATE.NONE;

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		//

		element.addEventListener( 'contextmenu', onContextMenu, false );

		element.addEventListener( 'mousedown', onMouseDown, false );
		element.addEventListener( 'wheel', onMouseWheel, false );

		element.addEventListener( 'touchstart', onTouchStart, false );
		element.addEventListener( 'touchend', onTouchEnd, false );
		element.addEventListener( 'touchmove', onTouchMove, false );

		element.addEventListener( 'keydown', onKeyDown, false );

		const cfg = viewer.ctx.cfg;

		setControlMode( cfg.value( 'avenControls', true ) );

		// force an update at start

		this.update();

	}

	OrbitControls.prototype = Object.create( EventDispatcher.prototype );
	OrbitControls.prototype.constructor = OrbitControls;

	/**
	 * @author richt / http://richt.me
	 * @author WestLangley / http://github.com/WestLangley
	 * Modified heavily by Angus Sawyer
	 * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)
	 */

	const __vector3$1 = new Vector3();
	const __euler = new Euler();
	const __quaternion1 = new Quaternion();
	const __quaternion2 = new Quaternion();

	const changeEvent = { type: 'change' };
	const endEvent = { type: 'end' };
	const accuracyEvent = { type: 'accuracy', value: 1000 };

	var LocationControls = function ( cameraManager, ctx ) {

		var scope = this;
		var survey = null;

		this.enabled = false;

		const alphaOffset = 0; // radians

		const location = new Vector3();

		const thresholdHigh = 60;
		const thresholdLow = 30;

		const lastTouch = new Vector2();
		const currentTouch = new Vector2();

		var touchDirection = 0;

		const container = ctx.container;
		const materials = ctx.materials;

		var deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
		var screenOrientation = null;

		var watch = null;
		var gettingHeight = false;

		this.location = location;

		function onDeviceOrientationChangeEvent ( event ) {

			deviceOrientation = event;
			updateOrientation();

		}

		function onScreenOrientationChangeEvent () {

			screenOrientation = window.orientation || 0;
			updateOrientation();

		}

		function onPositionChangeEvent ( GPSPosition ) {

			if ( gettingHeight ) return;

			gettingHeight = true;

			const coords = GPSPosition.coords;

			if ( coords.accuracy !== accuracyEvent.value ) {

				accuracyEvent.value = coords.accuracy;
				scope.dispatchEvent( accuracyEvent );

			}

			location.set( coords.longitude, coords.latitude, 0 );
			survey.getModelSurfaceFromWGS84( location, onHeightReturned );

		}

		function onHeightReturned () {

			updatePosition();
			gettingHeight = false;

		}

		// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

		function getQuaternion ( quaternion, alpha, beta, gamma, orient ) {

			__euler.set( beta, - gamma, alpha, 'ZXY' ); // 'ZXY' for the device, but 'YXZ' for us

			quaternion.setFromEuler( __euler ); // orient the device

			quaternion.multiply( __quaternion2.setFromAxisAngle( Object3D.DefaultUp, - orient ) ); // adjust for screen orientation

		}

		function updatePosition () {

			__vector3$1.copy( location );

			const camera = cameraManager.activeCamera;
			const position = camera.position;

			if ( cameraManager.mode === CAMERA_ORTHOGRAPHIC ) {

				__vector3$1.z += 500;

				survey.getWorldPosition( __vector3$1 );

				position.copy( __vector3$1 );

				//__vector3.z = -Infinity;
				camera.lookAt( __vector3$1 );

				const width = camera.right - camera.left;
				const height = camera.top - camera.bottom;

				camera.zoom = Math.min( width, height ) / ( 2 * accuracyEvent.value * survey.scale.x );

				camera.updateProjectionMatrix();

			} else {

				__vector3$1.z += 2; // adjust to head height
				survey.getWorldPosition( __vector3$1 );

				position.copy( __vector3$1 );

			}

			scope.dispatchEvent( changeEvent );
			scope.dispatchEvent( endEvent );

		}

		function selectCameraType ( angle ) {

			var cameraType = cameraManager.mode;

			// apply hysteresis

			if ( angle > thresholdHigh ) {

				cameraType = CAMERA_ORTHOGRAPHIC;

			} else if ( angle < thresholdLow ) {

				cameraType = CAMERA_PERSPECTIVE;

			} else if ( cameraType === CAMERA_NONE ) {

				cameraType = CAMERA_ORTHOGRAPHIC;

			}

			if ( cameraType !== cameraManager.mode ) {

				cameraManager.setCamera( cameraType, location );

				updatePosition();

			}

		}

		function updateOrientation () {

			if ( scope.enabled === false ) return;

			const alpha = deviceOrientation.alpha ? MathUtils.degToRad( deviceOrientation.alpha ) + alphaOffset : 0; // Z

			const beta = deviceOrientation.beta ? MathUtils.degToRad( deviceOrientation.beta ) : 0; // X'

			const gamma = deviceOrientation.gamma ? MathUtils.degToRad( deviceOrientation.gamma ) : 0; // Y''

			const orient = screenOrientation ? MathUtils.degToRad( screenOrientation ) : 0; // O

			getQuaternion( __quaternion1, alpha, beta, gamma, orient );

			// get angle to vertical
			__vector3$1.set( 0, 0, 1 ).applyQuaternion( __quaternion1 );

			const angle = __vector3$1.angleTo( Object3D.DefaultUp );

			selectCameraType( Math.abs( angle * MathUtils.RAD2DEG - 90 ) );

			if ( cameraManager.mode === CAMERA_PERSPECTIVE ) {

				cameraManager.activeCamera.quaternion.copy( __quaternion1 );

			} else {

				cameraManager.activeCamera.setRotationFromAxisAngle( Object3D.DefaultUp, alpha );

			}

			scope.dispatchEvent( changeEvent );
			scope.dispatchEvent( endEvent );

		}

		function onTouchStart ( event ) {

			const touch = event.touches.item( 0 );

			lastTouch.set( touch.clientX, touch.clientY );
			touchDirection = 0;

		}

		function onTouchMove ( event ) {

			const camera = cameraManager.activeCamera;
			const touch = event.touches.item( 0 );

			currentTouch.set( touch.clientX, touch.clientY );
			lastTouch.sub( currentTouch );

			const deltaX= 100 * lastTouch.x / container.clientWidth;
			const deltaY= 100 * lastTouch.y / container.clientHeight;

			if ( touchDirection === 0 ) {

				touchDirection = Math.abs( deltaY ) > Math.abs( deltaX ) ? 1 : -1;

			}

			if ( touchDirection === 1 ) {

				camera.zoom = Math.max( camera.zoom + deltaY, 1 );
				camera.updateProjectionMatrix();

			} else {

				materials.distanceTransparency = Math.max( materials.distanceTransparency - deltaX, 0 );

			}

			lastTouch.copy( currentTouch );
			scope.dispatchEvent( changeEvent );

		}

		function onTouchEnd ( /* event */ ) {

			touchDirection = 0;

		}

		this.hasLocation = function ( newSurvey, locationChecked ) {

			survey = newSurvey;

			if ( 'geolocation' in navigator && survey.CRS !== null ) {

				navigator.geolocation.getCurrentPosition( _currentPosition );

			}

			function _currentPosition ( GPSPosition ) {

				const coords = GPSPosition.coords;

				location.set( coords.longitude, coords.latitude, 0 );

				if ( survey.containsWGS84Position( location ) ) {

					locationChecked();

				}

			}

		};

		this.connect = function () {

			onScreenOrientationChangeEvent(); // run once on load

			window.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
			window.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );

			container.addEventListener( 'touchstart', onTouchStart, false );
			container.addEventListener( 'touchend', onTouchEnd, false );
			container.addEventListener( 'touchmove', onTouchMove, false );

			var geolocation = navigator.geolocation;

			geolocation.getCurrentPosition( onPositionChangeEvent );
			watch = geolocation.watchPosition( onPositionChangeEvent );

			scope.enabled = true;

			updateOrientation();

		};

		this.disconnect = function () {

			window.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
			window.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );

			container.removeEventListener( 'touchstart', onTouchStart, false );
			container.removeEventListener( 'touchend', onTouchEnd, false );
			container.removeEventListener( 'touchmove', onTouchMove, false );

			navigator.geolocation.clearWatch( watch );

			scope.enabled = false;

		};

		this.dispose = function () {

			scope.disconnect();

		};

	};

	LocationControls.prototype = Object.create( EventDispatcher.prototype );
	LocationControls.prototype.constructor = LocationControls;

	function CaveViewer ( domID, configuration ) {

		console.log( 'CaveView v' + VERSION );

		const container = document.getElementById( domID );

		this.container = container;

		if ( ! container ) alert( 'No container DOM object [' + domID + '] available' );

		// target with css for fullscreen on small screen devices
		container.classList.add( 'cv-container' );

		const cfg = new Cfg( configuration );

		const ctx = {
			cfg: cfg,
			container: container,
			workerPools: new WorkerPoolCache ( cfg ),
			glyphStringCache: new Map(),
			viewer: this
		};

		this.ctx = ctx;

		const materials = new Materials( this );

		ctx.materials = materials;

		container.style.backgroundColor = cfg.themeColorCSS( 'background' );

		var renderer = new WebGLRenderer( { antialias: true, alpha: true } );

		renderer.setSize( container.clientWidth, container.clientHeight );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setClearColor( cfg.themeColor( 'background' ), 0.0 );
		renderer.setRenderTarget( null );
		renderer.clear();
		renderer.autoClear = false;

		container.appendChild( renderer.domElement );

		const fog = new FogExp2( cfg.themeColorCSS( 'background' ), 0.0025 );

		const scene = new Scene();
		scene.fog = fog;
		scene.name = 'CV.Viewer';

		var cameraManager = new CameraManager( ctx, renderer, scene );

		const raycaster = new Raycaster();
		raycaster.layers.enableAll();

		// setup lighting
		const lightingManager = new LightingManager( ctx, scene );

		// setup controllers
		const controls = new OrbitControls( cameraManager, renderer.domElement, this );
		controls.maxPolarAngle = cfg.themeAngle( 'maxPolarAngle' );
		controls.addEventListener( 'change', onCameraMoved );
		controls.addEventListener( 'end', onCameraMoveEnd );

		const locationControls = new LocationControls( cameraManager, ctx );
		locationControls.addEventListener( 'change', onCameraMoved );
		locationControls.addEventListener( 'end', onCameraMoveEnd );
		locationControls.addEventListener( 'accuracy', onLocationAccuracyChange );

		const cameraMove = new CameraMove( controls, onCameraMoved );
		const moveEndEvent = { type: 'moved', cameraManager: cameraManager };

		const formatters = {};

		var caveIsLoaded = false;

		var lastMouseMode = MOUSE_MODE_NORMAL;
		var mouseMode = MOUSE_MODE_NORMAL;
		var mouseTargets = [];
		var clickCount = 0;

		var terrain = null;
		var survey = null;
		var limits = null;
		var stats = {};

		var useFog = false;

		var renderRequired = true;

		var popup = null;

		var clipped = false;

		// preallocated tmp objects

		const __rotation = new Euler();
		const __q = new Quaternion();
		const __v = new Vector3();
		const self = this;

		var viewState;
		var savedView = null;
		var mouseOver = false;

		var hasLocation = false;
		var trackLocation = false;

		// event handler
		window.addEventListener( 'resize', onResize );

		Object.defineProperties( this, {

			'mouseOver': {
				get: function () { return mouseOver; }
			},

			'reset': {
				set: function () { setupView( false ); }
			},

			'surveyLoaded': {
				get: function () { return caveIsLoaded; }
			},

			'terrain': {
				get: function () { return cameraManager.testCameraLayer( FEATURE_TERRAIN ); },
				set: loadTerrain
			},

			'terrainShading': {
				get: function () { return terrain !== null ? terrain.shadingMode : null; },
				set: _stateSetter( setTerrainShadingMode, 'terrainShading')
			},

			'hasTerrain': {
				get: function () { return !! terrain; }
			},

			'hasRealTerrain': {
				get: function () { return ( terrain && ! terrain.isFlat ); }
			},

			'terrainAttributions': {
				get: function () { return terrain !== null ? terrain.attributions : []; }
			},

			'terrainDirectionalLighting': {
				get: function () { return lightingManager.directionalLighting; },
				set: setTerrainLighting
			},

			'terrainThrough': {
				get: function () { return terrain !== null ? terrain.throughMode : null; },
				set: _stateSetter( setTerrainThroughMode, 'terrainThrough' )
			},

			'terrainShadingModes': {
				get: function () { return terrain !== null ? terrain.terrainShadingModes : {}; }
			},

			'terrainTileSet': {
				get: function () { return terrain.tileSet.bind( terrain ); }
			},

			'terrainDatumShift': {
				get: function () { return !! terrain.activeDatumShift; },
				set: applyTerrainDatumShift
			},

			'terrainOpacity': {
				get: function () { return ( terrain !== null ) ? terrain.getOpacity() : 0; },
				set: setTerrainOpacity
			},

			'shadingMode': {
				get: function () { return survey.caveShading; },
				set: _stateSetter( setShadingMode, 'shadingMode' )
			},

			'flatShading': {
				get: function () { return survey.wallsMode; },
				set: function ( x ) { survey.setWallsMode( x ); renderView(); }
			},

			'route': {
				get: function () { return survey.getRoutes().setRoute; },
				set: function ( x ) { survey.getRoutes().setRoute = x; }
			},

			'routeNames': {
				get: function () { return survey.getRoutes().getRouteNames(); },
			},

			'surfaceShading': {
				get: function () { return survey.surfaceShading; },
				set: _stateSetter( setSurfaceShadingMode, 'surfaceShading' )
			},

			'cameraType': {
				get: function () { return cameraManager.mode; },
				set: _stateSetter( setCameraMode, 'cameraType' )
			},

			'eyeSeparation': {
				get: function () { return cameraManager.eyeSeparation; },
				set: setEyeSeparation
			},

			'view': {
				get: function () { return VIEW_NONE; },
				set: _stateSetter( setViewMode, 'view' )
			},

			'cursorHeight': {
				get: function () { return materials.cursorHeight; },
				set: setCursorHeight
			},

			'maxDistance': {
				get: function () { return survey.getMaxDistance(); }
			},

			'maxHeight': {
				get: function () { return ( limits === null ) ? 0 : limits.max.z; }
			},

			'minHeight': {
				get: function () { return ( limits === null ) ? 0 : limits.min.z; }
			},

			'maxLegLength': {
				get: function () { return stats.maxLegLength; }
			},

			'minLegLength': {
				get: function () { return stats.minLegLength; }
			},

			'section': {
				get: function () { return survey.selection.getNode(); },
				set: _stateSetter( selectSection, 'section' )
			},

			'sectionByName': {
				get: getSelectedSectionName,
				set: setSelectedSectionName
			},

			'popup': {
				set: setPopup
			},

			'highlight': {
				set: _stateSetter( highlightSelection, 'highlight' )
			},

			'polarAngle': {
				get: function () { return controls.getPolarAngle(); },
				set: function (x ) { cameraMove.setPolarAngle( x ); }
			},

			'azimuthAngle': {
				set: function ( x ) { cameraMove.setAzimuthAngle( x ); }
			},

			'editMode': {
				get: function () { return mouseMode; },
				set: function ( x ) { setEditMode( x ); self.dispatchEvent( { type: 'change', name: 'editMode' } ); }
			},

			'setPOI': {
				//get: function () { return true; },
				set: _stateSetter( setCameraPOI, 'setPOI' )
			},

			'HUD': {
				get: function () { return hud.getVisibility(); },
				set: function ( x ) { hud.setVisibility( x ); }
			},

			'cut': {
				// get: function () { return true; },
				set: cutSection
			},

			'zScale': {
				get: function () { return survey.zScale; },
				set: setZScale
			},

			'autoRotate': {
				get: function () { return controls.autoRotate; },
				set: function ( x ) { setAutoRotate( !! x ); }
			},

			'wheelTilt': {
				get: function () { return controls.wheelTilt; },
				set: function ( x ) {
					controls.wheelTilt = !! x;
					self.dispatchEvent( { type: 'change', name: 'wheelTilt' } );
				}
			},

			'svxControlMode': {
				get: function () { return controls.svxControlMode; },
				set: function ( x ) {
					controls.svxControlMode = !! x;
					// force refresh of help tab
					self.dispatchEvent( { type: 'newCave', name: 'newCave' } );
				}
			},

			'zoomToCursor': {
				get: function () { return controls.zoomToCursor; },
				set: function ( x ) {
					controls.zoomToCursor = !! x;
					self.dispatchEvent( { type: 'change', name: 'zoomToCursor' } );
				}
			},

			'autoRotateSpeed': {
				get: function () { return controls.autoRotateSpeed / 11; },
				set: setAutoRotateSpeed
			},

			'fullscreen': {
				get: isFullscreen,
				set: setFullscreen
			},

			'hasContours': {
				get: function () { return ! ( renderer.extensions.get( 'OES_standard_derivatives' ) === null ); }
			},

			'fog': {
				get: function () { return useFog; },
				set: setFog
			},

			'isClipped': {
				get: function () { return clipped; }
			},

			'hasLocation': {
				get: function () { return hasLocation; }
			},

			'trackLocation': {
				get: function () { return trackLocation; },
				set: setLocation
			},

			'maxSnapshotSize': {
				get: function () {
					const context = renderer.getContext();
					return context.getParameter( context.MAX_RENDERBUFFER_SIZE );
				}
			},

			'focalLength': {
				get: function () { return cameraManager.focalLength; },
				set: setFocalLength
			}
		} );

		_enableLayer( FEATURE_BOX,       'box' );
		_enableLayer( FEATURE_ENTRANCES, 'entrances' );
		_enableLayer( FEATURE_ENTRANCE_DOTS, 'entrance_dots' );
		_enableLayer( FEATURE_STATIONS,  'stations' );
		_enableLayer( FEATURE_TRACES,    'traces' );
		_enableLayer( FACE_SCRAPS,       'scraps' );
		_enableLayer( FACE_WALLS,        'walls' );
		_enableLayer( LEG_CAVE,          'legs' );
		_enableLayer( LEG_SPLAY,         'splays' );
		_enableLayer( LEG_SURFACE,       'surfaceLegs' );
		_enableLayer( LABEL_STATION,     'stationLabels' );
		_enableLayer( LABEL_STATION_COMMENT, 'stationComments' );
		_enableLayer( SURVEY_WARNINGS,     'warnings' );

		container.addEventListener( 'mouseover', onMouseOver );
		container.addEventListener( 'mouseleave', onMouseLeave );

		container.addEventListener( 'fullscreenchange', onFullscreenChange );
		container.addEventListener( 'msfullscreenchange', onFullscreenChange );
		container.addEventListener( 'webkitfullscreenchange', onFullscreenChange );

		this.addEventListener( 'change', viewChanged );

		cfg.addEventListener( 'colors', () => {

			container.style.backgroundColor = cfg.themeColorCSS( 'background' );
			renderer.setClearColor( cfg.themeColor( 'background' ), 0.0 );

			if ( survey ) survey.refreshColors();

			renderView();

		} );

		function onMouseOver () {

			mouseOver = true;

		}

		function onMouseLeave () {

			mouseOver = false;

		}

		function viewChanged( event ) {

			if ( survey !== null && event.name === 'splays' ) {

				survey.stations.setSplaysVisibility( self.splays );

			}

		}

		this.getControls = function () {

			return controls;

		};

		const hud = new HUD( this, renderer );

		const caveLoader = new CaveLoader( ctx, caveLoaded );

		hud.getProgressDial( 0 ).watch( caveLoader );

		viewState = new ViewState( this );

		this.renderView = renderView;

		onResize();

		function _enableLayer ( layerTag, name ) {

			Object.defineProperty( self, name, {
				get: function () { return cameraManager.testCameraLayer( layerTag ); },
				set: function ( x ) {
					cameraManager.setCameraLayer( layerTag, x );
					self.dispatchEvent( { type: 'change', name: name } );
					renderView();
				}
			} );

			const hasName = 'has' + name.substr( 0, 1 ).toUpperCase() + name.substr( 1 );

			Object.defineProperty( self, hasName, {
				get: function () { return survey.hasFeature( layerTag ); }
			} );

		}

		function _stateSetter ( modeFunction, name ) {

			return function ( newMode ) {

				modeFunction( isNaN( newMode ) ? newMode : Number( newMode ) );
				self.dispatchEvent( { type: 'change', name: name } );

			};

		}

		function setEditMode ( x ) {

			mouseMode = Number( x );
			lastMouseMode = mouseMode;

			clickCount = 0;
			survey.markers.clear();
			survey.selectSection( survey.surveyTree );

			renderView();

			raycaster.params.Points.threshold = 3;

			switch ( mouseMode ) {

			case MOUSE_MODE_TRACE_EDIT:

				mouseTargets = survey.pointTargets.concat( [ survey.dyeTraces ] );

				break;

			case MOUSE_MODE_NORMAL:

				mouseTargets = survey.pointTargets;

				break;

			case MOUSE_MODE_ROUTE_EDIT:

				mouseTargets = survey.legTargets;

				break;

			case MOUSE_MODE_ENTRANCES:

				mouseTargets = survey.entranceTargets;
				raycaster.params.Points.threshold = 15;

				break;

			default:

				console.warn( 'invalid mouse mode', x );

			}

		}

		function isFullscreen () {

			return (
				window.innerHeight === container.clientHeight &&
				window.innerWidth === container.clientWidth
			);

		}

		function onFullscreenChange () {

			if ( document.fullscreenElement || document.msFullscreenElement || document.webkitFullscreenElement ) {

				container.classList.add( 'toggle-fullscreen' );

			} else {

				container.classList.remove( 'toggle-fullscreen' );

			}

			onResize();
			self.dispatchEvent( { type: 'change', name: 'fullscreen' } );

		}

		function setFullscreen ( targetState ) {

			if ( isFullscreen() === targetState ) return;

			if ( targetState ) {

				container.classList.add( 'toggle-fullscreen' );

				if ( document.fullscreenElement === null ) {

					container.requestFullscreen();

				} else if ( document.msfullscreenElement === null) {

					container.msRequestFullscreen();

				} else if ( document.webkitFullscreenElement === null) {

					container.webkitRequestFullscreen();

				}

			} else {

				container.classList.remove( 'toggle-fullscreen' );

				if ( document.fullscreenElement ) {

					document.exitFullscreen();

				} else if ( document.msFullscreenElement ) {

					document.msExitFullscreen();

				} else if ( document.webkitFullscreenElement ) {

					if ( document.webkitExitFullscreen ) {

						document.webkitExitFullscreen();

					} else if ( document.webkitCancelFullScreen ) {

						document.webkitCancelFullScreen();

					}

				}

			}

		}

		function setZScale ( scale ) {

			survey.zScale = scale;
			renderView();

		}

		function setAutoRotate ( state ) {

			cameraMove.setAutoRotate( state );

			self.dispatchEvent( { type: 'change', name: 'autoRotate' } );

		}

		function setAutoRotateSpeed ( speed ) {

			controls.autoRotateSpeed = Math.max( Math.min( speed, 1.0 ), -1.0 ) * 11;

			self.dispatchEvent( { type: 'change', name: 'autoRotateSpeed' } );

		}

		function setCursorHeight ( x ) {

			materials.cursorHeight = x;
			self.dispatchEvent( { type: 'cursorChange', name: 'cursorHeight' } );

			renderView();

		}

		function setTerrainShadingMode ( mode ) {

			if ( survey.terrain === null ) return;

			terrain.setShadingMode( mode, renderView );

			renderView();

			if ( terrain.isTiled ) terrain.zoomCheck( cameraManager );

		}

		function setTerrainThroughMode ( mode ) {

			if ( terrain === null ) return;

			terrain.setThroughMode( mode );

			materials.distanceTransparency = mode === TERRAIN_BLEND ? 200 : 0;

			setTerrainShadingMode( terrain.shadingMode );

		}

		function setTerrainOpacity ( x ) {

			if ( terrain === null ) return;

			terrain.setOpacity( x );
			self.dispatchEvent( { type: 'change', name: 'terrainOpacity' } );

			renderView();

		}

		function setTerrainLighting ( on ) {

			lightingManager.directionalLighting = on;

			renderView();

		}

		function applyTerrainDatumShift ( x ) {

			if ( terrain === null ) return;

			terrain.applyDatumShift( x );
			self.dispatchEvent( { type: 'change', name: 'terrainDatumShift' } );

			renderView();

		}

		function setupTerrain ( newTerrain ) {

			if ( newTerrain.isLoaded ) {

				terrain = newTerrain;

				terrain.setup( renderer, scene, survey );

				if ( cfg.value( 'useGPS', false ) ) {

					locationControls.hasLocation( survey, locationChecked );

				}

				if ( terrain.isTiled ) {

					terrain.addEventListener( 'progress', onEnd );
					terrain.watch( self );

				}

			}

			setupView( true );

		}

		function locationChecked () {

			hasLocation = true;
			self.dispatchEvent( { type: 'newCave', name: 'newCave' } );

		}

		function setLocation ( x ) {

			if ( x ) {

				savedView = viewState.saveState();

				controls.saveState();

				locationControls.connect();

				self.setView( dynamicView, null );
				cameraMove.cancel();


			} else {

				// disable location controls
				locationControls.disconnect();

				if ( terrain !== null ) terrain.setScale( 0.0 );

				// restore previous settings
				self.setView( savedView, null );

				// setting the saved view may attempt to reset this.view
				cameraMove.cancel();

				controls.reset();

				savedView = null;

			}

			controls.enabled = ! x;
			trackLocation = x;

			renderView();

		}

		function onLocationAccuracyChange ( event ) {

			terrain.setAccuracy( event.value );

		}

		function setCameraMode ( mode ) {

			cameraManager.setCamera( mode, controls.target );

			renderView();

		}

		function setFocalLength( f ) {

			const fChange = f / cameraManager.focalLength;

			cameraManager.focalLength = f;

			// adjust camera position to maintain view
			controls.scaleDolly( fChange );

		}

		function onCameraMoved () {

			const camera = cameraManager.activeCamera;

			__rotation.setFromQuaternion( camera.getWorldQuaternion( __q ) );

			lightingManager.setRotation( __rotation );

			if ( trackLocation && terrain !== null ) {

				if ( camera.isOrthographicCamera ) {

					terrain.setScale( camera.zoom * survey.scale.z );
					terrain.setTarget( locationControls.location );

				} else {

					terrain.setScale( 0.0 );

				}

			}

			renderView();

		}

		function setEyeSeparation ( x ) {

			cameraManager.eyeSeparation = x;
			renderView();

		}

		function setViewMode ( mode ) {

			const targetAxis = __v;

			switch ( mode ) {

			case VIEW_NONE:

				return;

			case VIEW_PLAN:

				targetAxis.set( 0, 0, -1 );

				break;

			case VIEW_ELEVATION_N:

				targetAxis.set( 0, 1, 0 );

				break;

			case VIEW_ELEVATION_S:

				targetAxis.set( 0, -1, 0 );

				break;

			case VIEW_ELEVATION_E:

				targetAxis.set( 1, 0, 0 );

				break;

			case VIEW_ELEVATION_W:

				targetAxis.set( -1, 0, 0 );

				break;

			default:

				console.warn( 'invalid view mode specified: ', mode );
				return;

			}

			cameraMove.prepare( survey.getWorldBoundingBox(), targetAxis );
			cameraMove.start( renderRequired );

		}

		function setFog ( enable ) {

			useFog = enable;
			fog.density = useFog ? 0.0025 : 0;

			renderView();

		}

		function setShadingMode ( mode ) {

			const shadingMode = survey.setShadingMode( mode );

			if ( shadingMode === SHADING_DISTANCE ) {

				lastMouseMode = mouseMode;
				mouseMode = MOUSE_MODE_DISTANCE;
				mouseTargets = survey.pointTargets;

			} else {

				mouseMode = lastMouseMode;

			}

			renderView();

		}

		function setSurfaceShadingMode ( mode ) {

			survey.setSurfaceShading( mode );

			renderView();

		}

		this.addOverlay = function ( name, overlayProvider, locationDefault ) {

			CommonTerrain.addOverlay( ctx, name, overlayProvider, locationDefault );

		};

		this.addFormatters = function ( stationFormatter ) {

			formatters.station = stationFormatter;

		};

		function cutSection () {

			const selection = survey.selection;

			if ( selection.isEmpty() || selection.isStation() ) return;

			cameraMove.cancel();

			survey.remove( terrain );
			survey.cutSection( selection.getNode() );

			// grab a reference to prevent survey being destroyed in clearView()
			const cutSurvey = survey;

			savedView = viewState.saveState();

			// reset view
			self.clearView();

			clipped = true;

			loadSurvey( cutSurvey );

		}

		function highlightSelection ( node ) {

			survey.highlightSelection( node );

			renderView();

		}

		function selectSection ( node ) {

			if ( node.isStation() ) {

				_selectStation( node );

			} else {

				_selectSection( node );

			}

			renderView();

			return;

			function _selectSection ( node ) {

				survey.selectSection( node );

				cameraMove.cancel();
				cameraMove.prepare( survey.selection.getWorldBoundingBox() );

				if ( survey.selection.isEmpty() ) cameraMove.start( renderRequired );

				return;

			}

			function _selectStation ( node ) {

				if ( mouseMode === MOUSE_MODE_TRACE_EDIT ) {

					selectTraceStation( node );

				} else {

					survey.selectStation( node );

					cameraMove.preparePoint( survey.getWorldPosition( node.p.clone() ) );

				}

			}

		}

		function getSelectedSectionName () {

			return survey.selection.getName();

		}

		function setSelectedSectionName ( name ) {

			selectSection( survey.surveyTree.getByPath( name ) || survey.surveyTree );

		}

		function onResize () {

			// adjust the renderer to the new canvas size
			const w = container.clientWidth;
			const h = container.clientHeight;

			renderer.setSize( w, h );

			self.dispatchEvent( { type: 'resized', name: 'rts', 'width': w, 'height': h } );

			renderView();

		}

		this.clearView = function () {

			// clear the current cave model, and clear the screen
			caveIsLoaded = false;

			renderer.clear();

			hud.setVisibility( false );

			// terminate all running workers (tile loading/wall building etc)
			ctx.workerPools.terminateActive();

			if ( terrain && terrain.isTiled ) {

				terrain.unwatch( self );

			}

			scene.remove( survey );

			controls.enabled = false;

			survey          = null;
			terrain         = null;
			limits          = null;
			mouseMode       = MOUSE_MODE_NORMAL;
			mouseTargets    = [];
			hasLocation     = false;

			// remove event listeners

			container.removeEventListener( 'mousedown', onMouseDown );

			cameraManager.resetCameras();

			controls.reset();

		};

		this.loadCave = function ( file, section ) {

			caveLoader.reset();
			caveLoader.loadFile( file, section );

			clipped = ( section !== undefined && section != '' );

		};

		this.loadCaves = function ( files ) {

			caveLoader.reset();
			caveLoader.loadFiles( files );

		};

		function caveLoaded ( cave ) {

			if ( ! cave ) {

				alert( 'failed loading cave information' );
				return;

			}

			onResize();
			loadSurvey( new Survey( ctx, cave ) );
			caveLoader.reset();

		}

		this.setView = function ( properties1, properties2 ) {

			// don't render until all settings made.
			if ( ! renderRequired ) return;

			renderRequired = false;

			Object.assign( this, properties1, properties2 );

			renderRequired = true;

			renderView();

		};

		function setupView ( final ) {

			renderRequired = true;

			if ( savedView === null ) {

				self.setView( defaultView, cfg.value( 'view', {} ) );

			} else {

				self.setView( savedView );
				savedView = null;

			}

			if ( final ) {

				// signal any listeners that we have a new cave

				self.dispatchEvent( { type: 'newCave', name: 'newCave' } );

			}

		}

		function loadSurvey ( newSurvey ) {

			// only render after first SetupView()
			renderRequired = false;

			survey = newSurvey;

			hud.getProgressDial( 1 ).watch( survey );

			stats = self.getLegStats( LEG_CAVE );

			setScale();

			materials.flushCache();

			scene.addStatic( survey );

			mouseTargets = survey.pointTargets;

			scene.matrixAutoUpdate = false;

			container.addEventListener( 'mousedown', onMouseDown, false );

			controls.enabled = true;

			survey.getRoutes().addEventListener( 'changed', onSurveyChanged );
			survey.addEventListener( 'changed', onSurveyChanged );

			caveIsLoaded = true;

			// have we got built in terrain
			let terrain = survey.terrain;

			if ( terrain !== null ) {

				setupTerrain( terrain );

			} else if ( navigator.onLine ) {

				terrain = new WebTerrain( ctx, survey, setupTerrain );

				hud.getProgressDial( 0 ).watch( terrain );

				setupView( false );

			} else {

				setupView( true );

			}

		}

		function onEnd ( event ) {

			if ( event.name === 'end' ) renderView();

		}

		function onSurveyChanged ( /* event */ ) {

			setShadingMode( survey.caveShading );

		}

		function loadTerrain ( mode ) {

			if ( terrain !== null && terrain.isLoaded ) {

				terrain.setVisibility( mode );

				cameraManager.setCameraLayer( FEATURE_TERRAIN, mode );

				self.dispatchEvent( { type: 'change', name: 'terrain' } );

				renderView();

			}

		}

		function showStationImagePopup ( station, imageUrl ) {

			if ( popup !== null ) return;

			popup = new ImagePopup( ctx, station, imageUrl, renderView );
			survey.add( popup );

			renderView();

		}

		function showStationPopup ( station ) {

			if ( popup !== null ) return;

			const depth = ( terrain ) ? station.p.z - terrain.getHeight( station.p ) : null;

			popup = new StationPopup( ctx, station, survey, depth, formatters.station, ( survey.caveShading === SHADING_DISTANCE ), self.warnings );
			survey.add( popup );

			renderView();

		}

		function closePopup () {

			if ( popup === null ) return;

			popup.close();
			popup = null;

		}

		function mouseUpLeft () {

			container.removeEventListener( 'mouseup', mouseUpLeft );

			closePopup();
			renderView();

			self.dispatchEvent( { type: 'select', node: null } );

		}


		function setPopup ( station ) {

			closePopup();

			if ( station.isStation() ) showStationPopup( station );

		}

		this.getStation = function ( mouse ) {

			const threshold = raycaster.params.Points.threshold;

			raycaster.setFromCamera( mouse, cameraManager.activeCamera );
			raycaster.params.Points.threshold = 20;

			const intersects = raycaster.intersectObjects( survey.pointTargets, false );

			raycaster.params.Points.threshold = threshold;

			if ( intersects.length < 1 ) return null;

			const station = visibleStation( intersects );

			if ( station === null ) return null;

			return survey.getWorldPosition( station.p.clone() );

		};

		function onMouseDown ( event ) {

			if ( event.target !== renderer.domElement ) return;

			const scale = __v.set( container.clientWidth / 2, container.clientHeight / 2, 0 );
			const mouse = cameraManager.getMouse( event.clientX, event.clientY );

			raycaster.setFromCamera( mouse, cameraManager.activeCamera );
			const intersects = raycaster.intersectObjects( mouseTargets, false );

			var entrance;

			if ( mouseMode === MOUSE_MODE_NORMAL && self.entrances ) {

				entrance = survey.entrances.intersectLabels( mouse, cameraManager.activeCamera, scale );

				if ( entrance !== null ) {

					const station = survey.surveyTree.findById( entrance.stationID );

					const e = {
						type: 'entrance',
						node: station,
						handled: false,
						mouseEvent: event
					};

					self.dispatchEvent( e );

					if ( e.handled ) return;

					_selectStation( station );
					return;

				}

			}

			if ( intersects.length < 1 ) return;

			switch ( mouseMode ) {

			case MOUSE_MODE_NORMAL:

				_selectStation( visibleStation( intersects ) );

				break;

			case MOUSE_MODE_ROUTE_EDIT:

				_selectSegment( intersects[ 0 ] );

				break;

			case MOUSE_MODE_DISTANCE:

				_selectDistance( visibleStation( intersects ) );

				break;

			case MOUSE_MODE_TRACE_EDIT:

				if ( event.button === MOUSE.LEFT ) {

					if ( intersects[ 0 ].object.type === 'Mesh' ) {

						selectTrace( intersects[ 0 ] );

					} else {

						selectTraceStation( visibleStation( intersects ) );

					}

				}

				break;
			/*
			case MOUSE_MODE_ENTRANCES:

				selectEntrance( intersects[ 0 ] );

				break;

			*/

			}

			function _selectStation ( station ) {

				if ( station === null ) return;

				survey.selectStation( station );

				const selectEvent = {
					type: 'select',
					node: station,
					handled: false,
					mouseEvent: event
				};

				self.dispatchEvent( selectEvent );

				if ( selectEvent.handled ) return;

				if ( event.button === MOUSE.LEFT ) {

					_showStationPopup( station );

				} else if ( event.button === MOUSE.RIGHT ) {

					_setStationPOI( station );

				}


			}

			function _setStationPOI( station ) {

				if ( ! survey.selection.contains( station.id ) ) {

					survey.selectSection( survey.surveyTree );

				}

				selectSection( station );

				cameraMove.start( true );
				event.stopPropagation();

				container.addEventListener( 'mouseup', _mouseUpRight );

			}

			function _selectDistance ( station ) {

				if ( station === null ) return;

				if ( event.button === MOUSE.LEFT ) {

					survey.showShortestPath( station );

					_showStationPopup( station );

				} else if ( event.button === MOUSE.RIGHT ) {

					survey.shortestPathSearch( station );

					self.dispatchEvent( { type: 'change', name: 'shadingMode' } );
					renderView();

				}

			}

			function _showStationPopup ( station ) {

				showStationPopup( station );

				container.addEventListener( 'mouseup', mouseUpLeft );
				cameraMove.preparePoint( survey.getWorldPosition( station.p.clone() ) );

				return true;

			}

			function _selectSegment ( picked ) {

				survey.getRoutes().toggleSegment( picked.index );

				setShadingMode( SHADING_PATH );

				renderView();

				return true;

			}

			function _mouseUpRight ( /* event */ ) {

				container.removeEventListener( 'mouseup', _mouseUpRight );

				if ( ! trackLocation ) controls.enabled = true;

				renderView();

				self.dispatchEvent( { type: 'select', node: null } );

			}

		}

		/*

		function selectEntrance ( hit ) {

			const entrances = survey.entrances;
			const info = entrances.getStation( hit.index );

			self.dispatchEvent( {
				type: 'selectedEntrance',
				entrance: info
			} );

		}

		*/

		function selectTrace ( hit ) {

			const dyeTraces = survey.dyeTraces;
			const traceIndex = hit.faceIndex;

			survey.markers.clear();

			dyeTraces.outlineTrace( traceIndex );

			self.dispatchEvent( {
				type: 'selectedTrace',
				trace: dyeTraces.getTraceStations( traceIndex ),
				delete: function _deleteTrace () {
					dyeTraces.deleteTrace( traceIndex );
					renderView();
				}
			} );

			renderView();

		}

		function selectTraceStation ( station ) {

			if ( station === null ) return;

			const dyeTraces = survey.dyeTraces;
			const markers = survey.markers;

			dyeTraces.outlineTrace( null );

			if ( ++clickCount === 3 ) {

				markers.clear();
				clickCount = 1;

			}

			markers.mark( station );

			const list = markers.getStations();

			var start, end;

			if ( list[ 0 ] !== undefined ) start = list[ 0 ].getPath();
			if ( list[ 1 ] !== undefined ) end = list[ 1 ].getPath();

			self.dispatchEvent( {
				type: 'selectedTrace',
				start: start,
				end: end,
				add: function () {
					if ( list.length !== 2 ) return;

					dyeTraces.addTrace( list[ 0 ], list[ 1 ] );

					markers.clear();
					renderView();

				}
			} );

			renderView();

		}

		function visibleStation ( intersects ) {

			return survey.stations.getClosestVisibleStation( cameraManager.activeCamera, intersects );

		}

		function renderView () {

			if ( ! renderRequired ) return;

			renderer.clear();

			if ( caveIsLoaded ) {

				survey.update( cameraManager, controls.target, ! trackLocation );

				if ( useFog ) materials.setFog( true );

				cameraManager.activeRenderer();

			}

			if ( useFog ) materials.setFog( false );

			hud.renderHUD();

		}

		this.renderView = renderView;

		function onCameraMoveEnd () {

			self.dispatchEvent( moveEndEvent );

		}

		function setCameraPOI () {

			cameraMove.start( true );

		}

		function setScale () {

			const width  = container.clientWidth;
			const height = container.clientHeight;

			// scaling to compensate distortion introduced by projection ( x and y coords only ) - approx only
			const scaleFactor = survey.scaleFactor;

			limits = survey.limits;

			const range = survey.combinedLimits.getSize( __v );

			var hScale = Math.min( width / range.x, height / range.y );

			if ( hScale === Infinity ) hScale = 1;

			const vScale = hScale * scaleFactor;

			survey.setScale( hScale, vScale );

			hud.setScale( vScale );

		}

		this.getLegStats = function ( type ) {

			const legs = survey.getFeature( type );

			return ( legs !== undefined ) ? survey.getFeature( type ).stats : {
				legs: 0,
				legLength: 0,
				minLegLength: 0,
				maxLegLength: 0
			};

		};

		this.getControls = function () {

			return controls;

		};

		this.getMetadata = function () {

			return survey.metadata;

		};

		this.getGLTFExport = function ( selection, options, callback ) {

			survey.gltfExport( selection, options, callback );

		};

		this.getSurveyTree = function () {

			return survey.surveyTree;

		};

		this.showImagePopup = function ( event, imageUrl ) {

			showStationImagePopup( event.node, imageUrl );
			container.addEventListener( 'mouseup', mouseUpLeft );

		};

		this.getSnapshot = function ( exportSize, lineScale ) {

			var width  = container.clientWidth;
			var height = container.clientHeight;

			var newWidth = exportSize;
			var newHeight = Math.round( height * newWidth / width );

			const renderTarget = new WebGLRenderTarget( newWidth, newHeight, { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat, stencilBuffer: true } );

			renderTarget.texture.generateMipmaps = false;
			renderTarget.texture.name = 'CV.snapshot';

			renderer.setSize( newWidth, newHeight );
			renderer.setPixelRatio( 1 );
			renderer.setRenderTarget( renderTarget );
			renderer.setClearAlpha( 1.0 );

			// reset camera and materials using renderer size/resolution
			self.dispatchEvent( { type: 'resized', name: 'rts', 'width': newWidth, 'height': newHeight, lineScale: lineScale } );

			renderView();

			const bSize = newWidth * newHeight * 4;
			const buffer = new Uint8ClampedArray( bSize );

			// restore renderer to normal render size and target
			renderer.readRenderTargetPixels( renderTarget, 0, 0, newWidth, newHeight, buffer );

			// invert image
			const line = newWidth * 4;
			const invertedBuffer = new Uint8ClampedArray( bSize );

			for ( let i = 0; i < bSize; i += line ) {

				const dst = bSize - i - line;

				for ( let j = 0; j < line; j++ ) {

					invertedBuffer[ dst + j ] = buffer[ i + j ];

				}

			}

			const id = new ImageData( invertedBuffer, newWidth, newHeight );

			var canvas = document.createElement( 'canvas' );

			canvas.width = newWidth;
			canvas.height = newHeight;

			var ctx = canvas.getContext( '2d' );

			ctx.putImageData( id, 0, 0 );

			renderTarget.dispose();

			renderer.setRenderTarget( null );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setClearAlpha( 0.0 );

			// reset renderer etc to new sizes

			onResize();

			return canvas.toDataURL();

		};

		this.dispose = function () {

			ctx.workerPools.dispose();
			scene.remove( survey );
			controls.dispose();
			locationControls.dispose();
			hud.dispose();

			ctx.glyphStringCache = null;
			ctx.cfg = null;
			ctx.workerPools = null;
			ctx.materials = null;
			ctx.container = null;

			window.removeEventListener( 'resize', onResize );

			container.removeChild( renderer.domElement );

			container.removeEventListener( 'mouseover', onMouseOver );
			container.removeEventListener( 'mouseleave', onMouseLeave );
			container.removeEventListener( 'mousedown', onMouseDown );

			container.removeEventListener( 'fullscreenchange', onFullscreenChange );
			container.removeEventListener( 'msfullscreenchange', onFullscreenChange );

			renderer.clear();
			renderer.dispose();

			renderer = null;

		};

	}

	CaveViewer.prototype = Object.create( EventDispatcher.prototype );

	var viewer;

	function init$v ( domID, configuration ) {

		viewer = new CaveViewer( domID, configuration );
		CV.Viewer = viewer;

	}

	var Viewer = {
		init: init$v
	};

	function Frame ( ctx ) {

		this.ctx = ctx;
		this.openPageId = null;
		this.reset();

	}

	Frame.prototype.reset = function () {

		const self = this;
		// create UI side panel and reveal tabs
		const frame = document.createElement( 'div' );
		frame.classList.add( 'cv-frame' );

		const frameHeader = document.createElement( 'div' );
		frameHeader.classList.add( 'cv-frame-header' );
		frameHeader.textContent = 'frame header';
		frame.appendChild( frameHeader );

		// create UI box to contain tabs - reorients for small screen widths
		const tabBox = document.createElement( 'div' );
		tabBox.classList.add( 'cv-tab-box' );

		if ( this.pages ) this.pages.forEach( function ( p ) { p.owner.dispose(); } );

		this.frame = frame;
		this.header = frameHeader;
		this.tabBox = tabBox;
		this.pages = [];
		this.listeners = [];
		this.inHandler = false;
		this.controls = [];
		this.seq = 0;

		const close = document.createElement( 'div' );
		close.classList.add( 'close' );
		close.classList.add( 'tab' );

		this.addListener( close, 'click', _closeFrame );

		tabBox.appendChild( close );

		function _closeFrame ( /* event */ ) {

			self.openPageId = null;
			self.tabBox.classList.remove( 'onscreen' );
			self.frame.classList.remove( 'onscreen' );

		}

	};

	Frame.seq = 0;

	Frame.prototype.addPage = function ( page ) {

		const pageDiv = page.page;
		const tab = page.tab;

		page.frame = this;

		this.addListener( tab, 'click', page.tabHandleClick.bind( page ) );

		if ( page.onTop !== undefined ) {

			// callback when this page is made visible
			this.addListener( tab, 'click', page.onTop );

		}

		this.tabBox.appendChild( tab );
		this.frame.appendChild( pageDiv );

		this.pages.push( { tab: tab, page: pageDiv, owner: page } );

		if ( this.openPageId === page.id ) page.open();

		return this;

	};

	Frame.prototype.getSeq = function () {

		return Frame.seq++;

	};


	Frame.prototype.onScreen = function ( title ) {

		this.tabBox.classList.add( 'onscreen' );
		this.frame.classList.add( 'onscreen' );
		this.header.textContent = title;

	};

	Frame.prototype.setParent = function ( parent ) {

		parent.appendChild( this.tabBox );
		parent.appendChild( this.frame );

	};

	Frame.prototype.setControlsVisibility = function ( list, visible ) {

		const display = visible ? 'block' : 'none';

		list.forEach( function ( element ) {

			if ( element === null ) return;
			element.style.display = display;

		} );

	};

	Frame.prototype.clear = function () {

		const frame  = this.frame;
		const tabBox = this.tabBox;

		if ( frame  !== null && frame.parentElement  !== null ) frame.parentElement.removeChild( frame );
		if ( tabBox !== null && tabBox.parentElement !== null ) tabBox.parentElement.removeChild( tabBox );

		this.listeners.forEach( function ( listener ) {

			listener.obj.removeEventListener( listener.name, listener.handler );

		} );

		this.reset();

		return;

	};

	Frame.prototype.addFullscreenButton = function ( id, obj, property ) {

		const tabBox = this.tabBox;
		const fullscreen = document.createElement( 'div' );

		fullscreen.classList.add( id );
		fullscreen.classList.add( 'tab' );

		this.addListener( fullscreen, 'click', _toggleButton );

		this.addListener( obj, 'change', _setButton );

		tabBox.appendChild( fullscreen );

		_setButton();

		return fullscreen;

		function _toggleButton () {

			obj[ property ] = ! obj[ property ];

			_setButton();

		}

		function _setButton () {

			if ( obj[ property ] ) {

				fullscreen.classList.remove( 'expand' );
				fullscreen.classList.add( 'collapse' );

			} else {

				fullscreen.classList.add( 'expand' );
				fullscreen.classList.remove( 'collapse' );

			}

		}

	};

	Frame.prototype.addListener = function ( obj, name, handler ) {

		obj.addEventListener( name, handler, false );

		this.listeners.push( {
			obj: obj,
			name: name,
			handler: handler
		} );

	};

	Frame.prototype.handleChange = function ( event ) {

		const obj = event.target;
		const property = event.name;

		if ( ! this.displayinHandle ) {

			if ( this.controls[ property ] ) {

				const ctrl = this.controls[ property ];

				switch ( ctrl.type ) {

				case 'checkbox':

					ctrl.checked = obj[ property ];

					break;

				case 'select-one':
				case 'range':

					ctrl.value = obj[ property ];

					break;

				case 'download':

					ctrl.href = obj[ property ];

					break;

				}

			}

		}

		this.pages.forEach( function ( p ) {

			const page = p.owner;

			if ( page.onChange !== null ) page.onChange( event );

		} );

	};

	function Page ( id, x18nPrefix, onTop, onLeave ) {

		const tab  = document.createElement( 'div' );
		const page = document.createElement( 'div' );

		page.classList.add( 'page' );

		tab.classList.add( id );
		tab.classList.add( 'tab' );

		this.page = page;
		this.tab = tab;
		this.onTop = onTop;
		this.frame = null;
		this.onLeave = onLeave;
		this.slide = undefined;
		this.x18nPrefix = x18nPrefix + '.';
		this.onChange = null;
		this.id = id;

	}

	Page.prototype.constructor = Page;

	Page.prototype.i18n = function ( text ) {

		const cfg = this.frame.ctx.cfg;
		const tr = cfg.i18n( this.x18nPrefix + text );

		return ( tr === undefined ) ? text : tr;

	};

	Page.prototype.addListener = function ( obj, name, handler ) {

		this.frame.addListener( obj, name, handler );
		// redirect to frame method - allows later rework to page specific destruction

	};

	Page.prototype.tabHandleClick = function ( event ) {

		event.preventDefault();
		event.stopPropagation();

		this.open();

	};

	Page.prototype.open = function () {

		const tab = this.tab;
		const pages = this.frame.pages;

		tab.classList.add( 'toptab' );

		this.frame.onScreen( this.i18n( 'title' ) );
		this.frame.openPageId = this.id;

		pages.forEach( function ( page ) {

			const otherPage = page.page;
			const otherTab = page.tab;
			const owner = page.owner;

			if ( otherTab === tab ) {

				otherPage.style.display = 'block';

			} else {

				otherPage.style.display = 'none';

				if ( otherTab.classList.contains( 'toptab' ) ) {

					otherTab.classList.remove( 'toptab' );

					if ( owner.onLeave !== undefined ) owner.onLeave();

				}

			}

		} );

	};

	Page.prototype.appendChild = function ( domElement ) {

		this.page.appendChild( domElement );

		return domElement;

	};

	Page.prototype.addHeader = function ( text ) {

		const div = document.createElement( 'div' );

		div.classList.add( 'header' );
		div.textContent = this.i18n( text );

		this.page.appendChild( div );

		return div;

	};

	Page.prototype.addCollapsingHeader = function ( text ) {

		const div = document.createElement( 'div' );

		div.classList.add( 'header' );
		div.textContent = this.i18n( text );
		div.classList.add( 'header_full' );

		this.page.appendChild( div );

		const container = document.createElement( 'div' );

		container.classList.add( 'container_full' );

		this.page.appendChild( container );

		div.addEventListener( 'click', function () {

			if ( div.classList.contains( 'header_collapsed' ) ) {

				container.style.display = 'block';

				container.addEventListener( 'transitionend', _onReveal );

				container.clientHeight; // lgtm
				container.classList.remove( 'container_collapsed' );

			} else {

				container.addEventListener( 'transitionend', _onCollapse );

				container.classList.add( 'container_collapsed' );

			}

			function _onReveal () {

				container.removeEventListener( 'transitionend', _onReveal );

				div.classList.remove( 'header_collapsed' );

			}

			function _onCollapse () {

				container.removeEventListener( 'transitionend', _onCollapse );

				div.classList.add( 'header_collapsed' );
				container.style.display = 'none';

			}

		} );

		return container;

	};

	Page.prototype.addText = function ( text ) {

		const p = this.addLine( text );

		p.classList.add( 'spaced' );

		return p;

	};

	Page.prototype.addLine = function ( text ) {

		const p = document.createElement( 'p' );

		p.textContent = text;

		this.page.appendChild( p );

		return p;

	};

	Page.prototype.addLink = function ( url, text ) {

		const a = document.createElement( 'a' );

		a.href = url;
		a.textContent = text;
		a.target = '_blank';

		this.page.appendChild( a );

		return a;

	};

	Page.prototype.makeLabel = function ( title, labelClass, idFor = 'na' ) {

		const label = document.createElement( 'label' );

		label.textContent = this.i18n( title );
		label.htmlFor = idFor;
		label.classList.add( labelClass );

		return label;

	};

	Page.prototype.addSelect = function ( title, obj, trgObj, property, replace ) {

		const div    = document.createElement( 'div' );
		const select = document.createElement( 'select' );

		div.classList.add( 'control' );

		if ( obj instanceof Array ) {

			obj.forEach( function ( element ) {

				const opt = document.createElement( 'option' );

				opt.value = element;
				opt.text = element;

				if ( opt.text === trgObj[ property ] ) opt.selected = true;

				select.add( opt, null );

			} );

		} else {

			for ( var p in obj ) {

				const opt = document.createElement( 'option' );

				// translate each space delimited substring of ui text
				opt.text = p.split( ' ' ).reduce( ( res, val ) => { return res + ' ' + this.i18n( val ); }, '' ).trim();
				opt.value = obj[ p ];

				if ( opt.value == trgObj[ property ] ) opt.selected = true;

				select.add( opt, null );

			}

		}

		const frame = this.frame;

		this.addListener( select, 'change', function onChange ( event ) { frame.inHandler = true; trgObj[ property ] = event.target.value; frame.inHandler = false; } );

		frame.controls[ property ] = select;

		div.appendChild( this.makeLabel( title, 'cv-select' ) );
		div.appendChild( select );

		if ( replace === undefined ) {

			this.page.appendChild( div );

		} else {

			this.page.replaceChild( div, replace );

		}

		return div;

	};

	Page.prototype.addFileSelect = function ( title, obj, trgObj, property ) {

		const frame = this.frame;
		const div = this.addSelect( title, obj, trgObj, property );

		const label = div.firstChild;
		const id = 'cv-' + frame.getSeq();

		label.for = id;
		label.classList.add( 'cv-file-label' );

		const input = document.createElement( 'input' );

		input.id = id;
		input.classList.add( 'cv-file' );
		input.type = 'file';
		input.accept = '.svx,.lox,.plt';
		input.multiple = true;

		this.addListener( input, 'change', function _handleFileChange () {

			const count = input.files.length;
			const files = [];

			if ( count > 0 ) {

				for ( var i = 0; i < count; i++ ) files.push( input.files[ i ] );

				trgObj[ property ] = files;

			}

		} );

		label.appendChild( input );

		return div;

	};

	Page.prototype.addCheckbox = function ( title, obj, property ) {

		const frame = this.frame;
		const cb    = document.createElement( 'input' );
		const div   = document.createElement( 'div' );

		const id = 'cv-' + frame.getSeq();

		div.classList.add( 'control' );

		cb.type = 'checkbox';
		cb.checked = obj[ property ];
		cb.id = id;

		this.addListener( cb, 'change', _checkboxChanged );

		frame.controls[ property ] = cb;

		div.appendChild( cb );
		div.appendChild( this.makeLabel( title, 'check', id ) );

		this.page.appendChild( div );

		return div;

		function _checkboxChanged ( event ) {

			frame.inHandler = true;

			obj[ property ] = event.target.checked;

			frame.inHandler = false;

		}

	};

	Page.prototype.addRange = function ( title, obj, property ) {

		const frame = this.frame;
		const div = document.createElement( 'div' );
		const range = document.createElement( 'input' );

		div.classList.add( 'control' );

		range.type = 'range';

		range.min = 0;
		range.max = 1;

		range.step = 0.05;
		range.value = obj[ property ];

		this.addListener( range, 'input', _rangeChanged );
		this.addListener( range, 'change', _rangeChanged ); // for IE11 support

		frame.controls[ property ] = range;

		div.appendChild( this.makeLabel( title, 'cv-range' ) );
		div.appendChild( range );

		this.page.appendChild( div );

		return div;

		function _rangeChanged ( event ) {

			frame.inHandler = true;

			obj[ property ] = event.target.value;

			frame.inHandler = false;

		}

	};

	Page.prototype.addSlide = function ( domElement, depth ) {

		const slide = document.createElement( 'div' );

		slide.classList.add( 'slide' );
		slide.style.zIndex = 200 - depth;

		slide.appendChild( domElement );

		this.page.appendChild( slide );

		this.slide = slide;
		this.slideDepth = depth;

		return slide;

	};

	Page.prototype.replaceSlide = function ( domElement, depth ) {

		const newSlide = document.createElement( 'div' );
		const page = this.page;

		var oldSlide = this.slide;

		newSlide.classList.add( 'slide' );
		newSlide.style.zIndex = 200 - depth;

		if ( depth < this.slideDepth ) {

			newSlide.classList.add( 'slide-out' );

		}

		newSlide.appendChild( domElement );

		page.appendChild( newSlide );

		if ( depth > this.slideDepth ) {

			oldSlide.addEventListener( 'transitionend', afterSlideOut );
			oldSlide.classList.add( 'slide-out' );

			oldSlide.clientHeight; // lgtm

		} else if ( depth < this.slideDepth ) {

			newSlide.addEventListener( 'transitionend', afterSlideIn );

			newSlide.clientHeight; // lgtm

			newSlide.classList.remove( 'slide-out' );

		} else {

			page.removeChild( oldSlide );

		}

		this.slide = newSlide;
		this.slideDepth = depth;

		return newSlide;

		function afterSlideOut () {

			oldSlide.removeEventListener( 'transitionend', afterSlideOut );
			page.removeChild( oldSlide );

			oldSlide = null;

		}

		function afterSlideIn () {

			page.removeChild( oldSlide );
			newSlide.removeEventListener( 'transitionend', afterSlideIn );

			oldSlide = null;

		}

	};

	Page.prototype.addButton = function ( title, func ) {

		const button = document.createElement( 'button' );

		button.type = 'button';
		button.textContent = this.i18n( title );

		this.addListener( button, 'click', func );

		this.page.appendChild( button );

		return button;

	};

	Page.prototype.addTextBox = function ( title, placeholder, getResultGetter ) {

		const div = document.createElement( 'div' );
		const input = document.createElement( 'input' );

		var value;

		input.type = 'text';
		input.placeholder = placeholder;

		div.appendChild( this.makeLabel( title, 'text' ) );
		div.appendChild( input );

		this.page.appendChild( div );

		this.addListener( input, 'change', function ( e ) { value = e.target.value; return true; } ) ;

		getResultGetter( _result );

		return div;

		function _result() {

			input.value = '';
			return value;

		}

	};

	Page.prototype.addDownloadButton = function ( title, urlProvider, fileName ) {

		const a = document.createElement( 'a' );

		if ( typeof a.download === 'undefined' ) return null;

		this.addListener( a, 'click', _setHref );

		a.textContent = this.i18n( title );
		a.type = 'download';
		a.download = fileName;
		a.href = 'javascript:void();';

		a.classList.add( 'download' );

		this.page.appendChild( a );

		return a;

		function _setHref() {

			a.href = urlProvider( a );

		}

	};

	Page.canDownload = function () {

		const a = document.createElement( 'a' );
		return ( typeof a.download !== 'undefined' );

	};

	Page.prototype.download = function ( data, fileName ) {

		const a = document.createElement( 'a' );

		if ( typeof a.download === 'undefined' ) return null;

		a.type = 'download';
		a.download = fileName;
		a.href = data;
		a.click();

	};

	Page.prototype.addColor = function ( title, name ) {

		const frame = this.frame;
		const cb    = document.createElement( 'input' );
		const div   = document.createElement( 'div' );
		const cfg = frame.ctx.cfg;

		const id = 'cv-' + frame.getSeq();

		div.classList.add( 'control' );

		cb.type = 'color';
		cb.value = cfg.themeColorHex( name ),

		cb.id = id;

		this.addListener( cb, 'change', _colorChanged );

		frame.controls[ name ] = cb;

		div.appendChild( cb );
		div.appendChild( this.makeLabel( title, 'color', id ) );

		this.page.appendChild( div );

		this.addListener( cfg, 'colors', e => { if (e.name === 'all' ) cb.value = cfg.themeColorHex( name ); } );

		return div;

		function _colorChanged ( event ) {

			frame.inHandler = true;

			cfg.setThemeColorCSS( name, event.target.value );

			frame.inHandler = false;

		}

	};

	Page.prototype.addLogo = function () {

		const img = document.createElement( 'div' );

		img.classList.add( 'logo' );
		img.title = 'logo';

		this.appendChild( img );

	};

	Page.prototype.dispose = function () {
		if ( this._dispose ) this._dispose();
	};

	function HelpPage ( frame, avenControls ) {

		Page.call( this, 'icon_help', 'help' );

		frame.addPage( this );
		const self = this;

		var dl;

		this.addHeader( avenControls ? 'header_svx' : 'header_native' );

		this.addHeader( 'shading.header' );

		dl = document.createElement( 'dl' );

		_addKey( '1', 'shading.height' );
		_addKey( '2', 'shading.inclination' );
		_addKey( '3', 'shading.length' );
		_addKey( '4', 'shading.height_cursor' );
		_addKey( '5', 'shading.single' );
		_addKey( '6', 'shading.survey' );
		_addKey( '7', 'shading.route' );
		_addKey( '8', 'shading.depth' );
		_addKey( '9', 'shading.depth_cursor' );
		_addKey( '0', 'shading.distance' );

		if ( ! avenControls ) {

			_addKey( '[', 'shading.cursor_up' );
			_addKey( ']', 'shading.cursor_down' );

		}

		this.appendChild( dl );

		this.addHeader( 'view.header' );

		dl = document.createElement( 'dl' );

		if ( avenControls ) {

			_addKey( 'P', 'view.plan' );
			_addKey( 'L', 'view.elevation' );

			_addKey( '', '-' );

			_addKey( 'N', 'view.north' );
			_addKey( 'E', 'view.east' );
			_addKey( 'S', 'view.south' );
			_addKey( 'W', 'view.west' );

			_addKey( '', '-' );

			_addKey( 'C', 'view.rotate_clockwise' );
			_addKey( 'V', 'view.rotate_anticlockwise' );

			_addKey( ']', 'view.zoom_in' );
			_addKey( '[', 'view.zoom_out' );

			_addKey( 'F', 'view.full_screen' );

			_addKey( '', '-' );

			_addKey( '" "', 'view.auto_rotate' );
			_addKey( 'Z', 'view.rotate_speed_up' );
			_addKey( 'V', 'view.rotate_speed_down' );
			_addKey( 'R', 'view.reverse_rotation' );

			_addKey( '', '-' );

			_addKey( '<del>', 'view.reset' );

		} else {

			_addKey( 'F', 'view.full_screen' );
			_addKey( 'O', 'view.orthogonal' );
			_addKey( 'P', 'view.perspective' );
			_addKey( 'R', 'view.reset' );
			_addKey( '.', 'view.center' );
			_addKey( 'N', 'view.next' );

		}

		_addKey( '<alt>S', 'view.control_mode' );
		_addKey( '<alt>X', 'view.zoom_to_cursor' );
		_addKey( '(', 'view.decrease_focal_length' );
		_addKey( ')', 'view.increase_focal_length' );

		this.appendChild( dl );

		this.addHeader( 'visibility.header' );

		dl = document.createElement( 'dl' );

		if ( avenControls ) {

			_addKey( 'J', 'visibility.station_labels' );
			_addKey( 'Q', 'visibility.splays' );
			_addKey( 'T', 'visibility.terrain' );
			_addKey( '<ctrl>N', 'visibility.station_labels' );
			_addKey( '<ctrl>X', 'visibility.stations' );
			_addKey( '<ctrl>L', 'visibility.survey' );
			_addKey( '<ctrl>F', 'visibility.surface' );

			_addKey( '', '-' );

			_addKey( '<', 'visibility.opacity_down' );
			_addKey( '>', 'visibility.opacity_up' );

		} else {

			_addKey( 'C', 'visibility.scraps' );
			_addKey( 'J', 'visibility.station_labels' );
			_addKey( 'L', 'visibility.entrance_labels' );
			_addKey( 'Q', 'visibility.splays' );
			_addKey( 'S', 'visibility.surface' );
			_addKey( 'T', 'visibility.terrain' );
			_addKey( 'W', 'visibility.walls' );
			_addKey( 'Z', 'visibility.stations' );

			_addKey( '', '-' );

			_addKey( '<', 'visibility.opacity_down' );
			_addKey( '>', 'visibility.opacity_up' );

		}

		this.appendChild( dl );

		if ( ! avenControls ) {

			this.addHeader( 'selection.header' );

			dl = document.createElement( 'dl' );

			_addKey( 'V', 'selection.remove' );

			this.appendChild( dl );

		}

		function _addKey( key, description ) {

			const dt = document.createElement( 'dt' );
			const dd = document.createElement( 'dd' );

			dt.textContent = key;
			dd.textContent = self.i18n( description );

			dl.appendChild( dt );
			dl.appendChild( dd );

		}

	}

	HelpPage.prototype = Object.create( Page.prototype );

	function InfoPage ( frame, viewer, fileSelector ) {

		Page.call( this, 'icon_info', 'info' );

		frame.addPage( this );

		this.addHeader( 'header' );

		this.addHeader( 'stats.header' );

		this.addText( 'file: ' + fileSelector.file );

		const stats = viewer.getLegStats( LEG_CAVE );

		this.addLine( this.i18n( 'stats.legs' ) + ': ' + stats.legCount );
		this.addLine( this.i18n( 'stats.totalLength' ) + ': ' + stats.legLength.toFixed( 2 ) + '\u202fm' );
		this.addLine( this.i18n( 'stats.minLength' ) + ': ' + stats.minLegLength.toFixed( 2 ) + '\u202fm' );
		this.addLine( this.i18n( 'stats.maxLength' ) + ': ' + stats.maxLegLength.toFixed( 2 ) + '\u202fm' );

		this.addHeader( 'CaveView v' + VERSION + '.' );

		this.addLogo();
		this.addText( 'A WebGL 3d cave viewer for Survex (.3d), Therion (.lox) and Compass (.plt) models.' );

		this.addText( 'For more information see: ' );
		this.addLink( 'https://aardgoose.github.io/CaveView.js/', 'CaveView on GitHub' );
		this.addText( ' Angus Sawyer, 2020' );

	}

	InfoPage.prototype = Object.create( Page.prototype );

	function SelectionCommonPage ( frame, viewer, container, fileSelector ) {

		Page.call( this, 'icon_explore', 'selection', _onTop, _onLeave );

		frame.addPage( this );

		this.surveyTree = viewer.getSurveyTree();
		this.currentTop = this.surveyTree;

		this.nodes = new WeakMap();
		this.leafSections = new WeakSet();
		this.lastSelected = null;
		this.lastSection = 0;
		this.lastShadingMode = viewer.shadingMode;
		this.currentHover = null;
		this.stringCompare = new Intl.Collator( 'en-GB', { numeric: true } ).compare;
		this.isOntop = false;

		const titleBar = document.createElement( 'div' );
		const cfg = viewer.ctx.cfg;

		titleBar.id = 'ui-path';
		titleBar.classList.add( 'header' );

		if ( viewer.isClipped ) {

			this.addListener( titleBar, 'click', __handleLoadFull );
			titleBar.classList.add( 'reload' );
			titleBar.textContent = this.currentTop.name;

		} else {

			titleBar.textContent = this.currentTop.name;

			this.nodes.set( titleBar, this.currentTop );

		}

		this.titleBar = titleBar;
		this.appendChild( titleBar );

		this.addListener( this.page, 'mouseover', _handleMouseover );
		this.addListener( this.page, 'mouseleave', _handleMouseleave );

		this.addListener( this.page, 'click', _handleSelectSurveyClick );
		this.addListener( this.page, 'dblclick', _handleSelectSurveyDblClick );

		const self = this;
		container.clientHeight; /* lgtm[js/unused-local-variable] */ // eslint-disable-line no-unused-vars

		this.addLine = function ( ul, child ) {

			const connections = ( child.p === undefined ) ? null : child.p.connections;

			// track which sections have stations as children

			if ( connections !== null && !this.leafSections.has( ul) ) this.leafSections.add( ul );

			// omit splays if now displaying

			if ( connections === 0 && ! viewer.splays && child.type !== STATION_ENTRANCE ) return;

			const li  = document.createElement( 'li' );
			const text = ( child.comment === undefined ) ? child.name : child.name + ' ( ' + child.comment + ' )';
			const txt = document.createTextNode( text );

			var key;

			self.nodes.set( li, child );

			if ( viewer.section === child ) li.classList.add( 'selected' );

			if ( connections === null ) {

				key = _makeKey( '\u2588 ', '#444444' );

				li.classList.add( 'section' );

			} else if ( child.type !== undefined && child.type === STATION_ENTRANCE ) {

				key = _makeKey( '\u2229 ', cfg.themeColorCSS( 'stations.entrances.marker' ) );
				key.classList.add( 'cv-entrance' );

			} else if ( connections > 2 ) { // station at junction

				key = _makeKey( '\u25fc ', cfg.themeColorCSS( 'stations.junctions.marker' ) );

			} else if ( connections === 0 ) { // end of splay

				key = _makeKey( '\u25fb ', cfg.themeColorCSS( 'stations.default.marker' ) );

			} else { // normal station in middle or end of leg

				key = _makeKey( '\u25fc ', cfg.themeColorCSS( 'stations.default.marker' ) );

			}

			li.appendChild( key );
			li.appendChild( txt );

			if ( child.children.length > 0 ) {

				const descend = document.createElement( 'div' );

				descend.classList.add( 'descend-tree' );

				self.nodes.set( descend, child );

				li.appendChild( descend );

			}

			ul.appendChild( li );

		};

		this.displaySectionCommon = function ( top ) {

			const children = top.children;
			const self = this;

			if ( ! top.sorted ) {

				children.sort( _sortSurveys );
				top.sorted = true;

			}

			const ul = document.createElement( 'ul' );
			ul.classList.add( 'cv-tree' );

			top.forEachChild( function ( child ) { self.addLine( ul, child ); } );

			_colourSections( ul );

			this.currentTop = top;
			// this.lastSelected = null;
			this.lastShadingMode = viewer.shadingMode;

			return ul;

			function _sortSurveys ( s1, s2 ) {

				return self.stringCompare( s1.name, s2.name );

			}

		};

		this.reloadSections = function () {

			const uls = this.page.getElementsByTagName( 'UL' );
			const targetSections = [];
			const self = this;
			var i;

			// find leaf sections that need reloading

			for ( i = 0; i < uls.length; i++ ) {

				const ul = uls[ i ];
				if ( this.leafSections.has( ul ) ) targetSections.push( ul );

			}

			targetSections.forEach( function ( ul ) {

				const node = self.nodes.get( ul.previousSibling ) || self.currentTop;

				if ( node ) ul.replaceWith( self.displaySectionCommon( node ) );

			});

		};

		this.onChange = _onChange;

		return;

		function _makeKey ( text, color ) {

			const key = document.createElement( 'span' );

			key.style.color = color;
			key.textContent = text;

			return key;

		}

		function _handleMouseleave ( /* event */ ) {

			viewer.highlight = self.surveyTree;
			viewer.popup = self.surveyTree;

		}

		function _handleMouseover ( event ) {

			const target = event.target;

			if ( target.nodeName !== 'LI' ) return;

			const node = self.nodes.get( target );

			if ( node !== self.currentHover ) {

				viewer.highlight = ( viewer.section !== node ) ? node : self.surveyTree;
				viewer.popup = node;

				self.currentHover = node;

			}

		}

		function _handleSelectSurveyClick ( event ) {

			event.stopPropagation();
			event.preventDefault();

			const target = event.target;
			const node = self.nodes.get( target );

			switch ( target.tagName ) {

			case 'LI':

				viewer.section = node;
				viewer.setPOI = true;

				target.classList.add( 'selected' );

				if ( self.lastSelected !== null ) self.lastSelected.classList.remove( 'selected' );

				self.lastSelected = target;

				break;

			case 'DIV':

				self.handleNext( target, node );
				break;

			case 'SPAN':

				self.handleBack( target );
				break;

			}

		}

		function _handleSelectSurveyDblClick ( event ) {

			event.stopPropagation();
			event.preventDefault();

			const target = event.target;
			const node = self.nodes.get( target );

			if ( ! target.classList.contains( 'section' ) ) return;

			if ( node !== self.surveyTree ) viewer.cut = true;

		}

		function _onChange( event ) {

			if ( ! viewer.surveyLoaded ) return;

			if ( event.name === 'splays' ) {

				self.reloadSections();
				return;
			}

			if (
				( self.lastSection !== viewer.section ) ||
				( self.lastShadingMode === SHADING_SURVEY && viewer.shadingMode !== SHADING_SURVEY ) ||
				( self.lastShadingMode !== SHADING_SURVEY && viewer.shadingMode === SHADING_SURVEY )
			) {

				_colourSections();

				self.lastShadingMode = viewer.shadingMode;
				self.lastSection = viewer.section;

			}

		}

		function _colourSections( ul ) {

			const root = ( ul === undefined ) ? self.page : ul;
			const lis = root.getElementsByTagName( 'li' );

			var i;

			const surveyColourMapper = viewer.ctx.surveyColourMapper;
			const surveyColourMap = ( viewer.shadingMode === SHADING_SURVEY ) ? surveyColourMapper.getColourMap( viewer.section ) : null;

			for ( i = 0; i < lis.length; i++ ) {

				const li = lis[ i ];
				const node = self.nodes.get( lis[ i ] );

				if ( node !== undefined && node.p === undefined ) {

					const span = li.firstChild;
					const id = node.id;
					let colour;

					if ( surveyColourMap !== null && surveyColourMap[ id ] !== undefined ) {

						colour = '#' + surveyColourMap[ id ].getHexString();

					} else {

						colour = '#444444';

					}

					span.style.color = colour;

				}

			}

		}

		function __handleLoadFull () {

			fileSelector.reload();

		}

		function _onTop( ) {

			self.isOntop = true;

		}

		function _onLeave( ) {

			self.isOntop = false;

		}

	}

	SelectionCommonPage.prototype = Object.create( Page.prototype );

	function SelectionPage ( frame, viewer, container, fileSelector ) {

		SelectionCommonPage.call( this, frame, viewer, container, fileSelector );

		const self = this;
		var depth = 0;

		this.addSlide( _displaySection( self.currentTop ), depth );

		container.clientHeight; /* lgtm[js/unused-local-variable] */ // eslint-disable-line no-unused-vars

		this.handleNext = function ( target, node ) {

			if ( node !== undefined && node !== self.surveyTree ) {

				self.replaceSlide( _displaySection( node ), ++depth );

			} else if ( target.id === 'ui-path' ) {

				viewer.section = self.currentTop;

			}

		};

		this.handleBack = function ( target ) {

			if ( target.id === 'surveyBack' ) {

				if ( self.currentTop === self.surveyTree ) return;

				self.replaceSlide( _displaySection( self.currentTop.parent ), --depth );

			}

		};

		return this;

		function _displaySection ( top ) {

			self.nodes = new WeakMap();

			var tmp;

			while ( tmp = self.titleBar.firstChild ) self.titleBar.removeChild( tmp ); // eslint-disable-line no-cond-assign

			if ( top === self.surveyTree ) {

				self.titleBar.textContent = ( top.name === '' ) ? '[model]' : top.name;
				self.nodes.set( self.titleBar, top );

			} else {

				const span = document.createElement( 'span' );

				span.id ='surveyBack';
				span.textContent = ' \u25C4';

				self.nodes.set( span, top );

				self.titleBar.appendChild( span );
				self.titleBar.appendChild( document.createTextNode( ' ' + top.name ) );

			}

			return self.displaySectionCommon( top );

		}

	}

	SelectionPage.prototype = Object.create( SelectionCommonPage.prototype );

	function SelectionTreePage ( frame, viewer, container, fileSelector ) {

		SelectionCommonPage.call( this, frame, viewer, container, fileSelector );

		const self = this;
		const domTop = self.displaySectionCommon( this.currentTop );

		var hightlitElement = null;
		var lastHighlitScroll = 0;

		this.appendChild( domTop );

		container.clientHeight; /* lgtm[js/unused-local-variable] */ // eslint-disable-line no-unused-vars

		this.handleNext = function ( target, node ) {

			if ( node !== undefined && node !== self.surveyTree ) {

				const li = target.parentNode;

				if ( target.classList.contains( 'open' ) ) {

					li.removeChild( li.lastElementChild );
					target.classList.remove( 'open' );

				} else {

					const ul = self.displaySectionCommon( node );
					li.appendChild( ul );
					target.classList.add( 'open' );

					return ul;

				}

			} else if ( target.id === 'ui-path' ) {

				viewer.section = self.currentTop;

			}

		};

		this.handleBack = function () {};

		viewer.addEventListener( 'select', _selectNode );

		this._dispose = function () {

			viewer.removeEventListener( 'select', _selectNode );

		};

		return this;

		function _selectNode ( event ) {

			if ( ! self.isOntop) return;

			// traverse DOM to find existing tree elements and add required
			// until selected node is visible and can be highlighted

			const selectedNode = event.node;

			if ( selectedNode === null  ) {

				_clearHighlitElement();
				return;

			}

			// get list of tree nodes from selectedNode to root - 1

			const path = [];
			var node = selectedNode;

			do {
				path.push( node );
				node = node.parent;
			} while ( node.id !== 0 );

			// search dom tree for list Element <LI> mapped to selected node

			var topElement = domTop; // start from top of dom tree
			var children = topElement.childNodes;

			node = path.pop();

			while ( node !== undefined ) {

				let i = 0;
				let listElement;

				// find matching child
				for ( i = 0; i < children.length; i++ ) {

					listElement = children[ i ];
					if ( self.nodes.get( listElement ) == node ) break;

				}

				if ( i == children.length ) break;

				if ( node === selectedNode ) {

					_setHighlight( listElement );
					break;

				} else {

					let nextTopElement = listElement.lastElementChild;

					// expand tree if not already visible
					if ( nextTopElement.tagName === 'DIV' ) {

						nextTopElement = self.handleNext( nextTopElement, node );

					}

					node = path.pop();
					children = nextTopElement.childNodes;
					topElement = nextTopElement;

				}

			}

		}

		function _setHighlight( element ) {

			lastHighlitScroll = 0;
			self.frame.frame.addEventListener( 'scroll', _onScroll );

			element.classList.add( 'highlight' );
			element.scrollIntoView( { behavior: 'smooth', block: 'center' } );

			if ( hightlitElement !== null ) _clearHighlight();
			hightlitElement = element;

		}

		function _clearHighlitElement () {

			self.frame.frame.removeEventListener( 'scroll', _onScroll );

			if ( lastHighlitScroll > performance.now() - 1000 ) {

				setTimeout( _clearHighlight, 1000 );

			} else {

				_clearHighlight();

			}

		}

		function _clearHighlight () {

			if ( hightlitElement == null ) return;

			hightlitElement.classList.remove( 'highlight' );
			hightlitElement = null;
			lastHighlitScroll = 0;

		}

		function _onScroll( event ) {

			lastHighlitScroll = event.timeStamp;

		}

	}

	SelectionTreePage.prototype = Object.create( SelectionCommonPage.prototype );

	const legShadingModes = {
		'shading.height':        SHADING_HEIGHT,
		'shading.length':        SHADING_LENGTH,
		'shading.inclination':   SHADING_INCLINATION,
		'shading.height_cursor': SHADING_CURSOR,
		'shading.fixed':         SHADING_SINGLE,
		'shading.survey':        SHADING_SURVEY,
		'shading.route':         SHADING_PATH,
		'shading.distance':      SHADING_DISTANCE
	//	'shading.back':          SHADING_BECK
	};

	const cameraViews = {
		'view.viewpoints.none':        VIEW_NONE,
		'view.viewpoints.plan':        VIEW_PLAN,
		'view.viewpoints.elevation_n': VIEW_ELEVATION_N,
		'view.viewpoints.elevation_s': VIEW_ELEVATION_S,
		'view.viewpoints.elevation_e': VIEW_ELEVATION_E,
		'view.viewpoints.elevation_w': VIEW_ELEVATION_W
	};

	const cameraModes = {
		'view.camera.orthographic': CAMERA_ORTHOGRAPHIC,
		'view.camera.perspective':  CAMERA_PERSPECTIVE,
		'view.camera.anaglyph':     CAMERA_ANAGLYPH
	};

	function SettingsPage ( frame, viewer, fileSelector ) {

		Page.call( this, 'icon_settings', 'settings' );

		frame.addPage( this );

		const controls = [];
		const routeControls = [];
		const cfg = viewer.ctx.cfg;

		const legShadingModesActive = Object.assign( {}, legShadingModes );

		const routeNames = viewer.routeNames;

		if ( viewer.hasRealTerrain ) {

			legShadingModesActive[ 'shading.depth' ] = SHADING_DEPTH;
			legShadingModesActive[ 'shading.depth_cursor' ] = SHADING_DEPTH_CURSOR;

		}

		this.addHeader( 'survey.header' );

		if ( fileSelector.fileCount > 1 ) {

			this.addFileSelect( 'survey.caption', fileSelector.fileList, fileSelector, 'file' );

		} else {

			this.addLine( fileSelector.selectedFile );

		}

		const cvw = this.addCollapsingHeader( 'view.header' );

		cvw.appendChild( this.addSelect( 'view.camera.caption', cameraModes, viewer, 'cameraType' ) );

		//	controls.push( this.addRange( 'view.eye_separation', viewer, 'eyeSeparation' ) );

		cvw.appendChild( this.addSelect( 'view.viewpoints.caption', cameraViews, viewer, 'view' ) );

		cvw.appendChild( this.addRange( 'view.vertical_scaling', viewer, 'zScale' ) );

		cvw.appendChild( this.addCheckbox( 'view.autorotate', viewer, 'autoRotate' ) );

		cvw.appendChild( this.addRange( 'view.rotation_speed', viewer, 'autoRotateSpeed' ) );

		const sh = this.addCollapsingHeader( 'shading.header' );

		sh.appendChild( this.addSelect( 'shading.caption', legShadingModesActive, viewer, 'shadingMode' ) );

		if ( routeNames.length !== 0 ) {

			if ( ! viewer.route ) viewer.route = routeNames[ 0 ];

			routeControls.push( this.addSelect( 'selected_route', routeNames, viewer, 'route' ) );

		} else {

			routeControls.push( this.addText( this.i18n( 'no_routes') ) );

		}

		const cv = this.addCollapsingHeader( 'visibility.header' );

		if ( viewer.hasLegs            ) cv.appendChild( this.addCheckbox( 'visibility.legs', viewer, 'legs' ) );
		if ( viewer.hasEntrances       ) cv.appendChild( this.addCheckbox( 'visibility.entrances', viewer, 'entrances' ) );
		if ( viewer.hasEntrances       ) cv.appendChild( this.addCheckbox( 'visibility.entrance_dots', viewer, 'entrance_dots' ) );
		if ( viewer.hasStations        ) cv.appendChild( this.addCheckbox( 'visibility.stations', viewer, 'stations' ) );
		if ( viewer.hasStationLabels   ) cv.appendChild( this.addCheckbox( 'visibility.labels', viewer, 'stationLabels' ) );
		if ( viewer.hasStationComments ) cv.appendChild( this.addCheckbox( 'visibility.comments', viewer, 'stationComments' ) );
		if ( viewer.hasSplays          ) cv.appendChild( this.addCheckbox( 'visibility.splays', viewer, 'splays' ) );
		if ( viewer.hasWalls           ) cv.appendChild( this.addCheckbox( 'visibility.walls', viewer, 'walls' ) );
		if ( viewer.hasScraps          ) cv.appendChild( this.addCheckbox( 'visibility.scraps', viewer, 'scraps' ) );
		if ( viewer.hasTraces          ) cv.appendChild( this.addCheckbox( 'visibility.traces', viewer, 'traces' ) );

		cv.appendChild( this.addCheckbox( 'visibility.fog', viewer, 'fog' ) );
		cv.appendChild( this.addCheckbox( 'visibility.hud', viewer, 'HUD' ) );
		cv.appendChild( this.addCheckbox( 'visibility.box', viewer, 'box' ) );

		if ( viewer.hasWarnings ) cv.appendChild( this.addCheckbox( 'visibility.warnings', viewer, 'warnings' ) );

		const ch = this.addCollapsingHeader( 'controls.header' );

		ch.appendChild( this.addCheckbox( 'controls.svx_control_mode', viewer, 'svxControlMode' ) );
		ch.appendChild( this.addCheckbox( 'controls.zoom_to_cursor', viewer, 'zoomToCursor' ) );
		ch.appendChild( this.addCheckbox( 'ui.selection_tree', cfg, 'selectionTree' ) );

		const cc = this.addCollapsingHeader( 'colors.header' );

		cc.appendChild( this.addColor( 'colors.background_color', 'background' ) );
		cc.appendChild( this.addColor( 'colors.entrance_text', 'stations.entrances.text' ) );
		cc.appendChild( this.addColor( 'colors.entrance_background', 'stations.entrances.background' ) );
		cc.appendChild( this.addColor( 'colors.entrance_marker', 'stations.entrances.marker' ) );
		cc.appendChild( this.addColor( 'colors.bounding_box', 'box.bounding' ) );
		cc.appendChild( this.addColor( 'colors.legs_fixed', 'shading.single' ) );
		cc.appendChild( this.addColor( 'colors.surface_fixed', 'shading.surface' ) );
		cc.appendChild( this.addColor( 'colors.hud_text', 'hud.text' ) );
		cc.appendChild( this.addButton( 'colors.defaults', cfg.resetColors.bind( cfg ) ) );

		if ( viewer.svxControlMode ) ch.appendChild( this.addCheckbox( 'controls.wheel_tilt', viewer, 'wheelTilt' ) );

		_onChange( { name: 'cameraType' } );
		_onChange( { name: 'shadingMode' } );

		this.onChange = _onChange;

		return this;

		function _onChange ( event ) {

			if ( event.name === 'shadingMode' ) {

				frame.setControlsVisibility( routeControls, ( viewer.shadingMode === SHADING_PATH ) );

			}

			// change UI dynamicly to only display useful controls
			if ( event.name === 'cameraType' ) {

				frame.setControlsVisibility( controls, ( viewer.cameraType === CAMERA_ANAGLYPH ) );

			}

		}

	}

	SettingsPage.prototype = Object.create( Page.prototype );

	const surfaceShadingModes = {
		'surface.shading.height':        SHADING_HEIGHT,
		'surface.shading.inclination':   SHADING_INCLINATION,
		'surface.shading.height_cursor': SHADING_CURSOR,
		'surface.shading.fixed':         SHADING_SURFACE
	};

	/*
	const terrainThroughModes = {
		'terrain.through.basic':   TERRAIN_BASIC,
		'terrain.through.blend':   TERRAIN_BLEND,
		'terrain.through.stencil': TERRAIN_STENCIL
	};
	*/

	function SurfacePage ( frame, viewer ) {

		const controls = [];

		Page.call( this, 'icon_terrain', 'surface' );

		frame.addPage ( this );

		this.addHeader( 'surface.header' );

		if ( viewer.hasSurfaceLegs ) {

			this.addCheckbox( 'surface.legs', viewer, 'surfaceLegs' );
			this.addSelect( 'surface.shading.caption', surfaceShadingModes, viewer, 'surfaceShading' );

		}

		if ( viewer.hasTerrain ) {

			this.addHeader( 'terrain.header' );

			this.addCheckbox( 'terrain.terrain', viewer, 'terrain' );

			controls.push( this.addSelect( 'terrain.shading.caption', viewer.terrainShadingModes, viewer, 'terrainShading' ) );

			// controls.push( this.addSelect( 'terrain.through.caption', terrainThroughModes, viewer, 'terrainThrough' ) );

			controls.push( this.addRange( 'terrain.opacity', viewer, 'terrainOpacity' ) );

			controls.push( this.addCheckbox( 'terrain.datum_shift', viewer, 'terrainDatumShift' ) );
			controls.push( this.addCheckbox( 'terrain.lighting', viewer, 'terrainDirectionalLighting' ) );

			if ( ! viewer.hasRealTerrain ) {

				controls.push( this.addDownloadButton( 'terrain.downloadTileSet', viewer.terrainTileSet, 'tileSetEntry.json' ) );

			}

			const attributions = viewer.terrainAttributions;

			for ( var i = 0; i < attributions.length; i++ ) {

				this.addText( attributions[ i ] );

			}

		}

		_onChange( { name: 'terrain' } );

		this.onChange = _onChange;

		return this;

		function _onChange ( event ) {

			// change UI dynamicly to only display useful controls
			if ( event.name === 'terrain' ) {

				frame.setControlsVisibility( controls, viewer.terrain );

			}

		}

	}

	SurfacePage.prototype = Object.create( Page.prototype );

	function Panel ( page ) {

		this.page = page;
		this.elements = [];

		this.dynamic = [];

		this.onShow = function () {

			this.dynamic.forEach ( function _deleteDynamic( element ) {

				element.parentElement.removeChild( element );

			} );

			this.dynamic = [];

		};

	}

	Panel.prototype.add = function ( element ) {

		this.elements.push( element );

		return element;

	};

	Panel.prototype.addDynamic = function ( element ) {

		this.dynamic.push ( element );

		return element;

	};

	Panel.prototype.setVisibility = function ( visible ) {

		const frame = this.page.frame;

		frame.setControlsVisibility( this.elements, visible );
		frame.setControlsVisibility( this.dynamic, visible );

		if ( visible && this.onShow !== null ) this.onShow();

	};

	function RoutePanel ( page, viewer, fileSelector ) {

		Panel.call( this, page );

		const self = this;
		const metadata = viewer.getMetadata();
		const routeNames = viewer.routeNames;

		this.add( page.addHeader( 'route.header' ) );

		var routeSelector = page.addSelect( 'route.current', routeNames, viewer, 'route' );
		var getNewRouteName;

		this.add( routeSelector );

		this.add( page.addButton( 'route.save', _saveRoute ) );

		this.add( page.addTextBox( 'route.new', '---', function ( getter ) { getNewRouteName = getter; } ) );

		this.add( page.addButton( 'route.add', _newRoute ) );

		this.add( page.addDownloadButton( 'route.download', metadata.getURL, replaceExtension( fileSelector.file, 'json' ) ) );

		function _newRoute () {

			console.log( getNewRouteName );
			//routes.addRoute( getNewRouteName() );

			// update selector

			routeSelector = self.addSelect( 'Current Route', viewer.routeNames, viewer, 'route', routeSelector );

		}

		function _saveRoute () {

			//routes.saveCurrent();

		}

	}

	RoutePanel.prototype = Object.create( Panel.prototype );

	function TracePanel ( page, viewer ) {

		Panel.call( this, page );

		const self = this;

		page.addListener( viewer, 'selectedTrace', _onSelect );

		this.add( page.addHeader( 'trace.header' ) );

		var line1 = this.add( page.addLine( 'Start:' ) );
		var line2 = this.add( page.addLine( 'End:' ) );

		function _initPanel () {

			self.onShow();
			line1.textContent = 'Start:';
			line2.textContent = 'End:';

		}

		function _onSelect ( event ) {

			if ( event.add !== undefined ) {

				_showStations( event );

			} else if ( event.delete !== undefined ) {

				_showTrace ( event );

			}

		}

		function _showTrace ( event ) {

			const traceInfo = event.trace;

			_initPanel();

			line1.textContent = 'Start: ' + traceInfo.start;
			line2.textContent = 'End: ' + traceInfo.end;

			self.addDynamic( page.addButton( 'trace.delete', function() {
				event.delete();
				_initPanel();
			} ) );

		}

		function _showStations ( event ) {

			_initPanel();

			if ( event.start !== undefined ) line1.textContent = 'Start: ' + event.start;

			if ( event.end !== undefined ) {

				line2.textContent = 'End: ' + event.end;

				self.addDynamic( page.addButton( 'trace.add', function() {
					event.add();
					_initPanel();
				} ) );

			}

		}

	}

	TracePanel.prototype = Object.create( Panel.prototype );

	//import { EntrancePanel } from './EntrancePanel';

	const mode$1 = {
		'modes.none': MOUSE_MODE_NORMAL,
		// 'modes.entrances': MOUSE_MODE_ENTRANCES,
		'modes.route': MOUSE_MODE_ROUTE_EDIT,
		'modes.trace': MOUSE_MODE_TRACE_EDIT
	};

	function EditPage ( frame, viewer, fileSelector ) {

		Page.call( this, 'icon_route', 'edit', _onTop, _onLeave );

		frame.addPage( this );

		const self = this;
		const intro = [];

		var initialState;

		var routePanel = null;
		var tracePanel = null;
		// var entrancePanel = null;

		this.addSelect( 'mode', mode$1, viewer, 'editMode' );

		intro.push( this.addText( this.i18n( 'intro' ) ) );

		this.onChange = _onChange;

		return this;

		function _onChange ( event ) {

			// change UI dynamicly to only display appropriate controls
			if ( event.name === 'editMode' ) {

				const newState = Object.assign( {}, initialState );

				switch ( viewer.editMode ) {

				case MOUSE_MODE_TRACE_EDIT:

					if ( tracePanel === null ) tracePanel = new TracePanel( self, viewer );

					newState.traces = true;

					break;

				case MOUSE_MODE_ROUTE_EDIT:

					if ( routePanel === null ) routePanel = new RoutePanel( self, viewer, fileSelector );

					newState.shadingMode = SHADING_PATH;

					break;
				/*
				case MOUSE_MODE_ENTRANCES:

					if ( entrancePanel === null ) entrancePanel = new EntrancePanel( self, viewer );

					newState.entrances = true;

					break;

				*/

				}

				viewer.setView( newState );

				frame.setControlsVisibility( intro, viewer.editMode === MOUSE_MODE_NORMAL );

				// if ( entrancePanel !== null ) entrancePanel.setVisibility( viewer.editMode === MOUSE_MODE_ENTRANCES );
				if ( routePanel !== null ) routePanel.setVisibility( viewer.editMode === MOUSE_MODE_ROUTE_EDIT );
				if ( tracePanel !== null ) tracePanel.setVisibility( viewer.editMode === MOUSE_MODE_TRACE_EDIT );

			}

		}

		function _onTop () {

			// save initial view settings

			initialState = {
				shadingMode: viewer.shadingMode,
				// entrances: viewer.entrances,
				stations: viewer.stations,
				traces: viewer.traces
			};

			_onChange( { type: 'change', name: 'editMode' } );

		}

		function _onLeave () {

			// restore inital view settings

			viewer.setView( initialState );

		}

	}

	EditPage.prototype = Object.create( Page.prototype );

	function LocationButton ( viewer, container ) { // public method

		var oldButtons = container.getElementsByClassName( 'cv-gps-button' ); //FIXME Id can be duplicated

		if ( oldButtons.length != 0 ) container.removeChild( oldButtons[ 0 ] );

		if ( ! viewer.hasLocation ) return;

		var div = document.createElement( 'div' );

		div.classList.add( 'cv-gps-button' );

		div.addEventListener( 'click', function () {

			if ( viewer.trackLocation ) {

				div.classList.remove( 'on' );

			} else {

				div.classList.add( 'on' );

			}

			viewer.trackLocation = ! viewer.trackLocation;

		} );

		container.appendChild( div );

		this.dispose = function () {

			container.removeChild( div );

		};

	}

	function KeyboardControls ( viewer, fileSelector, avenControls ) {

		document.addEventListener( 'keydown', keyDown );

		function keyDown ( event ) {

			event.preventDefault();

			if ( ! viewer.surveyLoaded || ! viewer.mouseOver ) return;

			if ( handleKeyCommon( event ) ) return;

			if ( avenControls ) {

				handleKeyAven( event );

			} else {

				handleKeyDefault( event );

			}

		}

		function handleKeyAven( event ) {

			if ( event.ctrlKey ) {

				switch ( event.key ) {

				case 'b':

					viewer.box = ! viewer.box;

					break;

				case 'e':

					viewer.wheelTilt = ! viewer.wheelTilt;

					break;

				case 'f':

					if ( viewer.hasSurfaceLegs ) viewer.surfaceLegs = ! viewer.surfaceLegs;

					break;

				case 'l':

					if ( viewer.hasLegs ) viewer.legs = ! viewer.legs;

					break;

				case 'n': // (not available in Chrome)

					if ( viewer.hasStationLabels ) viewer.stationLabels = ! viewer.stationLabels;

					break;

				case 'x':

					viewer.stations = ! viewer.stations;

					break;

				}

			} else {

				switch ( event.key ) {

				case 'Delete': // '<delete>' reset view

					viewer.reset = true;

					break;

				case 'Enter':

					viewer.autoRotate = true;

					break;

				case ' ':

					viewer.autoRotate = ! viewer.autoRotate;

					break;

				case 'l': // elevation

					viewer.polarAngle = Math.PI / 2;

					break;

				case 'e': // East

					viewer.azimuthAngle = 3 * Math.PI / 2;

					break;

				case 'n': // North

					viewer.azimuthAngle = 0;

					break;

				case 'p': // plan

					viewer.polarAngle = 0;

					break;

				case 'r': // reverse rotation direction

					viewer.autoRotateSpeed *= -1;

					break;

				case 's': // South

					viewer.azimuthAngle = Math.PI;

					break;

				case 'w': // West

					viewer.azimuthAngle = Math.PI / 2;

					break;

				case 'x': // decrease rotation speed

					viewer.autoRotateSpeed -= 0.1;

					break;

				case 'z': // increase rotation speed

					viewer.autoRotateSpeed += 0.1;

					break;

				}

			}

		}

		function handleKeyDefault( event ) {

			if ( event.ctrlKey ) return;

			switch ( event.key ) {

			case 'c': // toggle scraps visibility

				if ( viewer.hasScraps ) viewer.scraps = ! viewer.scraps;

				break;

			case 'd': // toggle dye traces visibility

				if ( viewer.hasTraces ) viewer.traces = ! viewer.traces;

				break;

			case 'f': // toggle full screen

				viewer.fullscreen = ! viewer.fullscreen;

				break;

			case 'j': // toggle entrance labels

				if ( viewer.hasStationLabels ) viewer.stationLabels = ! viewer.stationLabels;

				break;

			case 'l': // toggle entrance labels

				if ( viewer.hasEntrances ) viewer.entrances = ! viewer.entrances;

				break;

			case 'n': // load next cave in list

				fileSelector.nextFile();

				break;

			case 'o': // switch view to orthoganal'

				viewer.cameraType = CAMERA_ORTHOGRAPHIC;

				break;

			case 'p': // switch view to perspective

				viewer.cameraType = CAMERA_PERSPECTIVE;

				break;

			case 'q': // switch view to perspective

				if ( viewer.hasSplays ) viewer.splays = ! viewer.splays;

				break;

			case 'r': // reset camera positions and settings to initial plan view

				viewer.view = VIEW_PLAN;

				break;

			case 's': // surface leg visibility

				if ( viewer.hasSurfaceLegs ) viewer.surfaceLegs = ! viewer.surfaceLegs;

				break;

			case 't': // switch terrain on/off

				if ( viewer.hasTerrain ) viewer.terrain = ! viewer.terrain;

				break;

			case 'v': // cut selected survey section

				Page.clear();
				viewer.cut = true;

				break;

			case 'w': // switch walls on/off

				if ( viewer.hasWalls ) viewer.walls = ! viewer.walls;

				break;

			case 'x': // look at last POI

				viewer.setPOI = true; // actual value here is ignored.

				break;

			case 'z': // show station markers

				viewer.stations = ! viewer.stations;

				break;

			case ']':

				viewer.cursorHeight++;

				break;

			case '[':

				viewer.cursorHeight--;

				break;

			}

		}

		function handleKeyCommon( event ) {

			if ( event.ctrlKey ) return false;

			var handled = true;

			if ( event.altKey ) {

				switch ( event.key ) {

				case 's':

					viewer.svxControlMode = ! viewer.svxControlMode;

					break;

				case 'f':

					viewer.flatShading = ! viewer.flatShading;

					break;

				case 'x':

					viewer.zoomToCursor = ! viewer.zoomToCursor;

					break;

				default:

					handled = false;

				}

			} else {

				switch ( event.key ) {

				case '0': // change colouring scheme to distance

					viewer.shadingMode = SHADING_DISTANCE;

					break;

				case '1': // change colouring scheme to depth

					viewer.shadingMode = SHADING_HEIGHT;

					break;

				case '2': // change colouring scheme to angle

					viewer.shadingMode = SHADING_INCLINATION;

					break;

				case '3': // change colouring scheme to length

					viewer.shadingMode = SHADING_LENGTH;

					break;

				case '4': // change colouring scheme to height cursor

					viewer.shadingMode = SHADING_CURSOR;

					break;

				case '5': // change colouring scheme to white

					viewer.shadingMode = SHADING_SINGLE;

					break;

				case '6': // change colouring scheme to per survey section

					viewer.shadingMode = SHADING_SURVEY;

					break;

				case '7': // change colouring scheme to per survey section

					viewer.shadingMode = SHADING_PATH;

					break;

				case '8': // change colouring scheme to per survey section

					viewer.shadingMode = SHADING_DEPTH;

					break;

				case '9': // change colouring scheme to depth

					viewer.shadingMode = SHADING_DEPTH_CURSOR;

					break;

				case 'f': // toggle full screen

					viewer.fullscreen = ! viewer.fullscreen;

					break;

				case 'j': // toggle entrance labels

					if ( viewer.hasStationLabels ) viewer.stationLabels = ! viewer.stationLabels;

					break;

				case 'o': // switch view to orthoganal

					viewer.cameraType = CAMERA_ORTHOGRAPHIC;

					break;

				case 'q': // switch view to perspective

					if ( viewer.hasSplays ) viewer.splays = ! viewer.splays;

					break;

				case 't': // switch terrain on/off

					if ( viewer.hasTerrain ) viewer.terrain = ! viewer.terrain;

					break;

				case '+': // increase cursor depth

					viewer.cursorHeight++;

					break;

				case '-': // decrease cursor depth

					viewer.cursorHeight--;

					break;

				case '<': // decrease terrain opacity

					if ( viewer.hasTerrain ) viewer.terrainOpacity = Math.max( viewer.terrainOpacity - 0.05, 0 );

					break;

				case '>': // increase terrain opacity

					if ( viewer.hasTerrain ) viewer.terrainOpacity = Math.min( viewer.terrainOpacity + 0.05, 1 );

					break;

				case '(':

					viewer.focalLength = Math.max( 10, viewer.focalLength - 10 );

					break;

				case ')':

					viewer.focalLength = Math.min( 300, viewer.focalLength + 10 );

					break;

				default:

					handled = false;

				}

			}

			return handled;

		}

		this.dispose = function () {

			document.removeEventListener( 'keydown', keyDown );

		};

	}

	function FileSelector ( container, ctx ) {

		this.fileList = [];
		this.fileCount = 0;
		this.currentIndex = Infinity;
		this.loadedFile = null;
		this.isMultiple = false;
		this.splash = null;
		this.localFilename = null;

		const self = this;

		container.addEventListener( 'drop', _handleDrop );
		container.addEventListener( 'dragenter', _handleDragenter );
		container.addEventListener( 'dragover', _handleDragover );
		container.addEventListener( 'dragleave', _handleDragleave );

		Object.defineProperty( this, 'file', {
			get: function () { return this.selectedFile; },
			set: this.selectFile
		} );

		function _closeSpash () {

			const splash = self.splash;
			container.classList.remove( 'cv-splash' );

			if ( splash !== null ) {

				splash.parentNode.removeChild( splash );
				self.splash = null;

			}

		}

		function _handleDragenter ( event ) {

			event.preventDefault();

			if ( self.splash !== null ) return;

			const splash = document.createElement( 'div' );

			splash.innerHTML = ctx.cfg.i18n( 'dnd.splash_text' ) || 'dnd.splash_text';
			splash.id = 'cv-splash';

			container.appendChild( splash );
			container.classList.add( 'cv-splash' );

			self.splash = splash;

		}

		function _handleDragover ( event ) {

			event.preventDefault();
			event.dataTransfer.dropEffect = 'copy';

		}


		function _handleDragleave ( event ) {

			event.preventDefault();
			if ( event.relatedTarget === container.parentNode ) _closeSpash();

		}

		function _handleDrop ( event ) {

			_closeSpash();

			const dt = event.dataTransfer;

			event.preventDefault();

			const count = dt.files.length;
			const files = [];

			if ( count > 0 ) {

				for( var i = 0; i < count; i++ ) {

					files.push( dt.files[ i ] );

				}

				self.selectFile( files, null );

			}

		}

		this.dispose = function () {

			container.removeEventListener( 'drop', _handleDrop );
			container.removeEventListener( 'dragover', _handleDragover );
			container.removeEventListener( 'dragleave', _handleDragleave );
			container.removeEventListener( 'dragenter', _handleDragenter );

		};

	}

	FileSelector.prototype = Object.create( EventDispatcher.prototype );

	FileSelector.prototype.addList = function ( list ) {

		this.fileList = list;
		this.fileCount = list.length;

	};

	FileSelector.prototype.nextFile = function () {

		const fileList = this.fileList;

		//cycle through caves in list provided
		if ( this.fileCount === 0 ) return false;

		if ( ++this.currentIndex >= this.fileCount ) this.currentIndex = 0;

		this.selectFile( fileList[ this.currentIndex ] );

	};

	FileSelector.prototype.selectFile = function ( file, section ) {

		if ( Array.isArray( file ) ) {

			if ( file.length === 1 ) {

				this.localFilename = file[ 0 ].name;
				this.selectedFile = file[ 0 ];
				this.isMultiple = false;

			} else {

				this.selectedFile = '[multiple]';
				this.localFilename = 'multiple';
				this.isMultiple = true;

			}

		} else {

			this.selectedFile = file;
			this.localFilename = file;

		}

		this.loadedFile = file;

		this.dispatchEvent( { type: 'selected', file: file, section: section } );

	};

	FileSelector.prototype.reload = function () {

		this.selectFile( this.loadedFile );

	};

	function ExportPage ( frame, viewer, fileSelector ) {

		Page.call( this, 'icon_export', 'exports' );

		frame.addPage( this );

		this.addHeader( 'png_export.header' );

		const sizes = [];
		let mss = viewer.maxSnapshotSize;

		do { sizes.push( mss ); } while ( (mss /= 2) > 512 );

		const scales = [ 1, 2, 3, 4, 5, 6 ];

		const pngParams = {
			exportSize: sizes[ 0 ],
			lineScale: 1
		};

		this.addSelect( 'png_export.line_scale', scales, pngParams, 'lineScale' );
		this.addSelect( 'png_export.size', sizes, pngParams, 'exportSize' );

		this.addDownloadButton(
			'png_export.export',
			() => {
				const url = viewer.getSnapshot( pngParams.exportSize, pngParams.lineScale );
				return url;
			},
			'snapshot.png'
		);

		this.addHeader( 'gltf_export.header' );

		const selection = { legs: false, walls: false, scraps: false  };
		const options = { rotate: false, binary: false };

		if ( viewer.hasWalls ) {

			selection.walls = true;
			this.addCheckbox( 'gltf_export.walls', selection, 'walls' );

		}

		if ( viewer.hasScraps ) {

			selection.scraps = true;
			this.addCheckbox( 'gltf_export.scraps', selection, 'scraps' );

		}

		this.addCheckbox( 'gltf_export.legs', selection, 'legs' );

		this.addCheckbox( 'gltf_export.rotate_axes', options, 'rotate' );
		// this.addCheckbox( 'gltf_export.binary_format', options, 'binary' );

		this.addButton( 'gltf_export.export', function () {

			viewer.getGLTFExport( selection, options, handleExport );

		} );

		const self = this;

		return this;


		function handleExport ( gltfData, binary ) {

			var filename = replaceExtension( fileSelector.localFilename, ( binary ? 'glb' : 'gltf' ) );

			self.download( URL.createObjectURL( gltfData ), filename );

		}

	}

	ExportPage.prototype = Object.create( Page.prototype );

	function CaveViewUI ( viewer ) {

		const ctx = viewer.ctx;
		const container = viewer.container;
		const frame = new Frame( ctx );
		const cfg = ctx.cfg;

		const fileSelector = new FileSelector( container, ctx );
		fileSelector.addEventListener( 'selected', selectFile );

		// add active property for runtime selection mode
		cfg.setPropertyValue( 'selectionTree', true ) ;

		// event handlers
		viewer.addEventListener( 'change', frame.handleChange.bind( frame ) );
		viewer.addEventListener( 'newCave', initUI );

		// make sure we get new language strings if slow loading
		cfg.addEventListener( 'change', initUI );

		const keyboardControls = new KeyboardControls( viewer, fileSelector, cfg.value( 'avenControls', true ) );
		var locationButton;

		function selectFile( event ) {

			frame.clear();
			viewer.clearView();

			if ( Array.isArray( event.file ) ) {

				viewer.loadCaves( event.file );

			} else {

				viewer.loadCave( event.file, event.section );

			}

		}

		function initUI () {

			if ( ! viewer.surveyLoaded ) return;

			// create UI side panel and reveal tabs
			frame.clear();

			new SettingsPage( frame, viewer, fileSelector );

			if ( viewer.hasSurfaceLegs || viewer.hasTerrain ) new SurfacePage( frame, viewer );

			if ( cfg.selectionTree ) {

				new SelectionTreePage( frame, viewer, container, fileSelector );

			} else {

				new SelectionPage( frame, viewer, container, fileSelector );

			}

			if ( cfg.value( 'showEditPage', false ) && ! fileSelector.isMultiple ) new EditPage( frame, viewer, fileSelector );

			if ( cfg.value( 'showExportPage', false) && Page.canDownload() ) new ExportPage( frame, viewer, fileSelector );

			new InfoPage( frame, viewer, fileSelector );
			new HelpPage( frame, viewer.svxControlMode );

			frame.setParent( container );

			frame.addFullscreenButton( 'fullscreen', viewer, 'fullscreen' );
			locationButton = new LocationButton( viewer, container );

		}

		this.loadCaveList = function ( list ) {

			fileSelector.addList( list );
			fileSelector.nextFile();

		};

		this.loadCave = function ( file, section ) {

			fileSelector.selectFile( file, section );

		};

		this.loadCaves = function ( files ) {

			viewer.clearView();
			viewer.loadCaves( files );

		};

		this.clearView = function () {

			frame.clear();
			viewer.clearView();

		};

		this.dispose = function () {

			frame.clear();
			viewer.clearView();
			fileSelector.dispose();
			locationButton.dispose();
			keyboardControls.dispose();
			viewer.dispose();

		};

	}

	// export public interface
	var UI = {
		init: function ( domID, configuration ) {
			CV.Viewer.init( domID, configuration );
			var UI = new CaveViewUI( CV.Viewer );
			CV.UI = UI;
		}
	};

	exports.CAMERA_ANAGLYPH = CAMERA_ANAGLYPH;
	exports.CAMERA_NONE = CAMERA_NONE;
	exports.CAMERA_OFFSET = CAMERA_OFFSET;
	exports.CAMERA_ORTHOGRAPHIC = CAMERA_ORTHOGRAPHIC;
	exports.CAMERA_PERSPECTIVE = CAMERA_PERSPECTIVE;
	exports.CLUSTER_MARKERS = CLUSTER_MARKERS;
	exports.DIVING = DIVING;
	exports.FACE_SCRAPS = FACE_SCRAPS;
	exports.FACE_WALLS = FACE_WALLS;
	exports.FEATURE_BOX = FEATURE_BOX;
	exports.FEATURE_ENTRANCES = FEATURE_ENTRANCES;
	exports.FEATURE_ENTRANCE_DOTS = FEATURE_ENTRANCE_DOTS;
	exports.FEATURE_SELECTED_BOX = FEATURE_SELECTED_BOX;
	exports.FEATURE_STATIONS = FEATURE_STATIONS;
	exports.FEATURE_SURVEY = FEATURE_SURVEY;
	exports.FEATURE_TERRAIN = FEATURE_TERRAIN;
	exports.FEATURE_TRACES = FEATURE_TRACES;
	exports.LABEL_STATION = LABEL_STATION;
	exports.LABEL_STATION_COMMENT = LABEL_STATION_COMMENT;
	exports.LEG_CAVE = LEG_CAVE;
	exports.LEG_SPLAY = LEG_SPLAY;
	exports.LEG_SURFACE = LEG_SURFACE;
	exports.MATERIAL_LINE = MATERIAL_LINE;
	exports.MATERIAL_SURFACE = MATERIAL_SURFACE;
	exports.MOUSE_MODE_DISTANCE = MOUSE_MODE_DISTANCE;
	exports.MOUSE_MODE_ENTRANCES = MOUSE_MODE_ENTRANCES;
	exports.MOUSE_MODE_NORMAL = MOUSE_MODE_NORMAL;
	exports.MOUSE_MODE_ROUTE_EDIT = MOUSE_MODE_ROUTE_EDIT;
	exports.MOUSE_MODE_TRACE_EDIT = MOUSE_MODE_TRACE_EDIT;
	exports.NORMAL = NORMAL;
	exports.SHADING_BECK = SHADING_BECK;
	exports.SHADING_CONTOURS = SHADING_CONTOURS;
	exports.SHADING_CURSOR = SHADING_CURSOR;
	exports.SHADING_DEPTH = SHADING_DEPTH;
	exports.SHADING_DEPTH_CURSOR = SHADING_DEPTH_CURSOR;
	exports.SHADING_DISTANCE = SHADING_DISTANCE;
	exports.SHADING_HEIGHT = SHADING_HEIGHT;
	exports.SHADING_INCLINATION = SHADING_INCLINATION;
	exports.SHADING_LENGTH = SHADING_LENGTH;
	exports.SHADING_LOCATION = SHADING_LOCATION;
	exports.SHADING_OVERLAY = SHADING_OVERLAY;
	exports.SHADING_PATH = SHADING_PATH;
	exports.SHADING_RELIEF = SHADING_RELIEF;
	exports.SHADING_SHADED = SHADING_SHADED;
	exports.SHADING_SINGLE = SHADING_SINGLE;
	exports.SHADING_SURFACE = SHADING_SURFACE;
	exports.SHADING_SURVEY = SHADING_SURVEY;
	exports.SPLAY = SPLAY;
	exports.STATION_ENTRANCE = STATION_ENTRANCE;
	exports.STATION_NORMAL = STATION_NORMAL;
	exports.SURFACE = SURFACE;
	exports.SURVEY_WARNINGS = SURVEY_WARNINGS;
	exports.TERRAIN_BASIC = TERRAIN_BASIC;
	exports.TERRAIN_BLEND = TERRAIN_BLEND;
	exports.TERRAIN_STENCIL = TERRAIN_STENCIL;
	exports.UI = UI;
	exports.VERSION = VERSION;
	exports.VIEW_ELEVATION_E = VIEW_ELEVATION_E;
	exports.VIEW_ELEVATION_N = VIEW_ELEVATION_N;
	exports.VIEW_ELEVATION_S = VIEW_ELEVATION_S;
	exports.VIEW_ELEVATION_W = VIEW_ELEVATION_W;
	exports.VIEW_NONE = VIEW_NONE;
	exports.VIEW_PLAN = VIEW_PLAN;
	exports.Viewer = Viewer;
	exports.WALL_DIAMOND = WALL_DIAMOND;
	exports.WALL_OVAL = WALL_OVAL;
	exports.WALL_SQUARE = WALL_SQUARE;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
